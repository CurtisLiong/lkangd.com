__NUXT_JSONP__("/post/design-patterns-in-javascript", (function(a){return {data:[{post:{attributes:{title:"Design Patterns In Javascript",date:"2019-09-03",spoiler:"总结常用设计模式在 Javascript 中的实现",link:a,min2read:"🍱🍱 31 min read",wordcount:"7.6k"},body:"\u003Cp\u003E\u003Cdiv class=\"cs-toc-dom\"\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#danlimoshi\"\u003E单例模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#celvemoshi\"\u003E策略模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#dailimoshi\"\u003E代理模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#diedaiqimoshi\"\u003E迭代器模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#fabudingyuemoshi\"\u003E发布订阅模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#minglingmoshi\"\u003E命令模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zuhemoshi\"\u003E组合模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#mobanfangfamoshi\"\u003E模板方法模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#xiangyuanmoshi\"\u003E享元模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zhizelianmoshi\"\u003E职责链模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zhongjiezhemoshi\"\u003E中介者模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zhuangshizhemoshi\"\u003E装饰者模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zhuangtaimoshi\"\u003E状态模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#shipeiqimoshi\"\u003E适配器模式\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jieyan\"\u003E结言\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E设计模式：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E设计模式这个术语是上个世纪 90 年代由 Erich Gamma、Richard Helm、Raplh Johnson 和 Jonhn Vlissides 四个人总结提炼出来的，并且写了一本叫 \u003Ca href=\"https:\u002F\u002Fbook.douban.com\u002Fsubject\u002F1052241\u002F\" target=\"_blank\"\u003E《Design Patterns》\u003C\u002Fa\u003E 的书。这四人也被称为四人帮（GoF）。\u003C\u002Fp\u003E\n\u003Cp\u003E为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。\u003C\u002Fp\u003E\n\u003Cp\u003E在 JavaScript 这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另一个类，并且可以将函数作为参数随意传递，所以在 JavaScript 里很多设计模式的实现与传统的静态类型语言不尽相同。\u003C\u002Fp\u003E\n\u003Ch2 id=\"danlimoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'danlimoshi')\"\u003E¶\u003C\u002Fa\u003E 单例模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E保证一个类仅有一个实例，并提供一个访问它的全局访问点。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E单例模式（Singleton）的目的很简单，就是为了保证某个「类」在全局范围内有且仅有一个实例。在 JavaScript 开发中，单例模式用途也非常广泛，比如用户界面中的登录浮窗、全局的状态管理实例等。\u003C\u002Fp\u003E\n\u003Cp\u003E单例模式在 JavaScript 中的实现方式很简单：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E通过静态属性\u003Ccode\u003Einstance\u003C\u002Fcode\u003E变量持有唯一属性，保证全局唯一性；\u003C\u002Fli\u003E\n\u003Cli\u003E通过静态方法\u003Ccode\u003EgetInstance\u003C\u002Fcode\u003E返回这个唯一实例，使外部调用方法能获取到实例；\u003C\u002Fli\u003E\n\u003Cli\u003E限制构造函数的返回结果，以保证使用\u003Ccode\u003Enew SomeClass\u003C\u002Fcode\u003E方式时仍能返回唯一实例。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Singleton {\n  static instance = null; \u002F\u002F 记录单实例\n  \u002F\u002F 返回已存在的实例，否则创建一个实例\n  static getInstance(name) {\n    return Singleton.instance || new Singleton(name);\n  }\n  constructor(name) {\n    this.name = name;\n    return Singleton.instance || (Singleton.instance = this);\n  }\n  showName() {\n    return this.name;\n  }\n}\n\nconst s1 = Singleton.getInstance('s1');\nconst s2 = Singleton.getInstance('s2');\n\nconsole.log(s1 === s2); \u002F\u002F true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E仔细观察上面的代码不难发现，单例限制部分其实与构造函数本身要实现的行为没有太大的关联，因此可以将单例限制的部分抽取出来作为公共的单例化函数。此函数接收一个构造函数，返回一个经过包装后的\u003Cstrong\u003E单例化构造函数\u003C\u002Fstrong\u003E，实现如下。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Efunction getSingleton(ctor) {\n  return class Singleton extends ctor {\n    static instance = null; \u002F\u002F 记录单实例\n    \u002F\u002F 返回已存在的实例，否则创建一个实例\n    static getInstance(...args) {\n      return Singleton.instance || new Singleton(...args);\n    }\n    constructor(...args) {\n      super(...args);\n      return Singleton.instance || (Singleton.instance = this);\n    }\n  };\n}\n\nclass SomeClass {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst SingleSomeClass = getSingleton(SomeClass);\n\nconst s1 = SingleSomeClass.getInstance('s1');\nconst s2 = SingleSomeClass.getInstance('s2');\n\nconsole.log(s1 === s2); \u002F\u002F true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E也可以使用 JavaScript 闭包和高阶函数的特性来达到目的，注意使用此方式时，输入的构造函数只能为\u003Cstrong\u003E函数声明\u003C\u002Fstrong\u003E形式，因为\u003Ccode\u003Eclass\u003C\u002Fcode\u003E只能用\u003Ccode\u003Enew SomeClass\u003C\u002Fcode\u003E的方式进行实例化。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Efunction getSingleton(ctor) {\n  function Singleton(...args) {\n    if (Singleton.instance) return Singleton.instance;\n    ctor.apply(this, args); \u002F\u002F 借用构造函数逻辑\n    return (Singleton.instance = this);\n  }\n  Singleton.prototype = Object.create(ctor.prototype); \u002F\u002F 维持原型链\n  Singleton.instance = null;\n  Singleton.getInstance = function(...args) {\n    return Singleton.instance || new Singleton(...args);\n  };\n  return Singleton;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"celvemoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'celvemoshi')\"\u003E¶\u003C\u002Fa\u003E 策略模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。此模式使得算法和逻辑可独立于使用它的消费者而变化。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E策略模式在 JavaScript 应用非常广泛，最常见的就是表单校验，常见的数组的高阶函数 api \u003Ccode\u003EArray.prototype.sort\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.map\u003C\u002Fcode\u003E等也是其中一种典型的体现。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Econst arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10];\n\narr.sort((a, b) =&gt; a - b); \u002F\u002F [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.sort((a, b) =&gt; b - a); \u002F\u002F [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E通过不同的回调函数，将数组进行正向排序和反向排序，而两个回调函数就是独立的策略。\u003C\u002Fp\u003E\n\u003Cp\u003E一个基于策略模式的程序至少由两部分组成：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E定义一组策略类，策略类封装了具体的算法，并负责具体的计算过程。\u003C\u002Fli\u003E\n\u003Cli\u003E定义一个环境类 Context，Context 接受客户的请求，随后将请求委托给某一个策略类。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E策略模式在 JavaScript 中经常用于解决多重条件选择语句带来的强耦合问题。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 优化前\nfunction func(condition) {\n  if (condition === 'A') {\n    \u002F\u002F do some stuff ...\n  } else if (condition === 'B') {\n    \u002F\u002F do some stuff ...\n  } else if (condition === 'C') {\n    \u002F\u002F do some stuff ...\n  } else if (condition === 'D') {\n    \u002F\u002F do some stuff ...\n  }\n}\n\n\u002F\u002F 优化后\nconst strategies = {\n  A() {\n    \u002F\u002F do some stuff ...\n  },\n  B() {\n    \u002F\u002F do some stuff ...\n  },\n  C() {\n    \u002F\u002F do some stuff ...\n  },\n  D() {\n    \u002F\u002F do some stuff ...\n  },\n};\n\nstrategies[condition]();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 id=\"moshiyoudian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian')\"\u003E¶\u003C\u002Fa\u003E 模式优点：\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E利用组合、委托和多态等技术和思想，可有效避免多重条件选择语句。\u003C\u002Fli\u003E\n\u003Cli\u003E提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得策略易于切换，易于理解，易于扩展。\u003C\u002Fli\u003E\n\u003Cli\u003E算法可复用在其它地方，从而避免了许多重复的复制黏贴工作。\u003C\u002Fli\u003E\n\u003Cli\u003E利用组合和委托来让 Context 拥有执行算法的能力，相对传统的继承来说更加轻便。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch5 id=\"moshiquedian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian')\"\u003E¶\u003C\u002Fa\u003E 模式缺点：\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E会在程序中增加许多策略类或者策略对象，存在额外开销。\u003C\u002Fli\u003E\n\u003Cli\u003Estrategy 需要向消费者暴露所有实现，违反了最少知识原则。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"dailimoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dailimoshi')\"\u003E¶\u003C\u002Fa\u003E 代理模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E为一个对象提供一个代用品或占位符，以便控制对这个对象的访问。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E使用代理模式的主要目的是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求作出一些处理之后，再把请求转交给本体对象。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E客户 ====&gt; 本体 \u002F\u002F 不使用代理模式\n客户 ====&gt; 代理 ====&gt; 本体 \u002F\u002F 使用代理模式\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E代理模式可以理解成，在目标对象之前架设一层「拦截」，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。因为代理对象对客户是透明的，所以代理对象必须实现与本体一致的接口。在最新的 ES6 语法中，已经实现了原生的\u003Ccode\u003EProxy\u003C\u002Fcode\u003E，直接在“元编程”（meta programming）的层面对本体行为增加拦截。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 使用get拦截，实现数组读取负数的索引。\nconst arr = ['a', 'b', 'c'];\n\nfunction createArray(arr) {\n  const handler = {\n    get(target, propKey, receiver) {\n      const index = Number(propKey);\n      if (index &lt; 0) {\n        propKey = String(target.length + index);\n      }\n      return Reflect.get(target, propKey, receiver);\n    },\n  };\n\n  return new Proxy(arr, handler);\n}\n\nlet arrProxy = createArray(arr);\narrProxy[-1]; \u002F\u002F c\narr[-1]; \u002F\u002F undefined\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"diedaiqimoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'diedaiqimoshi')\"\u003E¶\u003C\u002Fa\u003E 迭代器模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。\u003C\u002Fp\u003E\n\u003Cp\u003E迭代器可以分为外部迭代器和内部迭代器。\u003C\u002Fp\u003E\n\u003Ch5 id=\"neibudiedaiqi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'neibudiedaiqi')\"\u003E¶\u003C\u002Fa\u003E 内部迭代器\u003C\u002Fh5\u003E\n\u003Cp\u003E内部迭代器的特点是外界跟迭代器的交互仅仅只是一次初始调用。\u003C\u002Fp\u003E\n\u003Cp\u003E常见的数组的高阶函数 api \u003Ccode\u003EArray.prototype.forEach\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.map\u003C\u002Fcode\u003E等就已经很好地实现了迭代器模式。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Econst arr = [1, 2, 3];\n\narr.forEach((item, index) =&gt; {\n  \u002F\u002F do some stuff ...\n});\n\n\u002F\u002F 手动实现内部迭代器\nfunction each(arr, callback) {\n  for (let i = 0; i &lt; arr.length; i++) {\n    callback(arr[i], i, arr);\n  }\n}\n\neach(arr, (item, index) =&gt; {\n  \u002F\u002F do some stuff ...\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 id=\"waibudiedaiqi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'waibudiedaiqi')\"\u003E¶\u003C\u002Fa\u003E 外部迭代器\u003C\u002Fh5\u003E\n\u003Cp\u003E外部迭代器的特点是必须显式地请求迭代下一个元素。它的迭代过程一般遵循下面四个步骤：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E创建一个指针对象，指向当前数据结构的起始位置。也就是说，迭代器对象本质上，就是一个指针对象。\u003C\u002Fli\u003E\n\u003Cli\u003E第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。\u003C\u002Fli\u003E\n\u003Cli\u003E第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。\u003C\u002Fli\u003E\n\u003Cli\u003E不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Econst it = makeIterator(['hello', 'world', 'ending']);\n\nit.next(); \u002F\u002F { value: &quot;hello&quot;, done: false }\nit.next(); \u002F\u002F { value: &quot;world&quot;, done: false }\nit.next(); \u002F\u002F { value: &quot;ending&quot;, done: false }\nit.next(); \u002F\u002F { value: undefined, done: true }\n\nfunction makeIterator(array) {\n  let nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex &lt; array.length ? { value: array[nextIndex++], done: false } : { value: undefined, done: true };\n    },\n  };\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EES6 已经对外部迭代器进行了原生实现，它就是\u003Ccode\u003EGenerator\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Efunction* itGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nconst it = itGenerator();\nit.next(); \u002F\u002F { value: 'hello', done: false }\nit.next(); \u002F\u002F { value: 'world', done: false }\nit.next(); \u002F\u002F { value: 'ending', done: true }\nit.next(); \u002F\u002F { value: undefined, done: true }\n\n\u002F\u002F 可以很方便地使用 for...of 进行迭代\nfor (let l of it) {\n  console.log(l);\n}\n\u002F\u002F hello world ending\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"fabudingyuemoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'fabudingyuemoshi')\"\u003E¶\u003C\u002Fa\u003E 发布订阅模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E发布-订阅模式（Publish-Subscribe：Pub\u002FSub），它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。又称为「观察者模式」。\u003C\u002Fp\u003E\n\u003Cp\u003E它的特点是：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E可广泛应用于异步编程中，是一种替代传递回调函数的解决方案。\u003C\u002Fli\u003E\n\u003Cli\u003E可取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在 JavaScript 开发中，一般使用事件模型来替代传统的发布订阅模式。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Elet i = 0;\ndocument.body.addEventListener('click', () =&gt; {\n  i++;\n  console.log(`点击了 ${i} 次。`);\n});\n\ndocument.body.click(); \u002F\u002F 点击了 1 次。\ndocument.body.click(); \u002F\u002F 点击了 2 次。\ndocument.body.click(); \u002F\u002F 点击了 3 次。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在 JavaScript 中实现一个自定义的发布订阅模式一般需要下面三个步骤：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E创建一个发布者；\u003C\u002Fli\u003E\n\u003Cli\u003E在发布者内部创建一个缓存列表，用于存放回调函数以便通知订阅者；\u003C\u002Fli\u003E\n\u003Cli\u003E在发布者内部创建一个遍历执行器函数，在发布消息（发生了指定的变化）时，依次触发缓存列表内订阅者的回调函数。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Econst event = {\n  clientList: [], \u002F\u002F 收集订阅回调\n  \u002F\u002F 订阅回调\n  listen(key, fn) {\n    if (!this.clientList[key]) {\n      this.clientList[key] = [];\n    }\n  },\n  \u002F\u002F 取消订阅\n  remove(key, fn) {\n    const fns = this.clientList[key];\n    if (!fns || fns.length === 0) {\n      return false;\n    }\n    if (!fn) {\n      fns &amp;&amp; (fns.length = 0);\n      return;\n    }\n    const targetIndex = fns.findIndex(fnI =&gt; fnI === fn);\n    ~targetIndex &amp;&amp; fns.splice(targetIndex, 1);\n  },\n  \u002F\u002F 触发回调\n  trigger(...args) {\n    const key = args.shift();\n    const fns = this.clientList[key];\n    if (!fns || fns.length === 0) {\n      return false;\n    }\n    fns.forEach(fn =&gt; fn.apply(null, args));\n  },\n};\n\n\u002F\u002F 动态安装发布订阅功能\nconst installEvent = function(obj) {\n  for (let key in event) {\n    obj[key] = event[key];\n  }\n};\n\n\u002F\u002F 使用\nconst source = {};\ninstallEvent(source);\n\nconst typeACb = arg =&gt; console.log('typeA', arg);\nconst typeBCb = arg =&gt; console.log('typeB', arg);\n\nsource.listen('typeA', typeACb);\nsource.listen('typeB', typeBCb);\n\nsource.trigger('typeA', ' is trigger'); \u002F\u002F typeA is trigger\nsource.trigger('typeB', ' is trigger'); \u002F\u002F typeB is trigger\nsource.trigger('typeC', 'may cause error'); \u002F\u002F false\n\nsource.remove('typeA', typeACb);\nsource.remove('typeB');\nsource.trigger('typeA', ' is trigger'); \u002F\u002F false\nsource.trigger('typeB', ' is trigger'); \u002F\u002F false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ENodes.js 中的 EventEmitter 就是一个经典的发布订阅模式的实现，它实质上是将发布订阅的逻辑抽离出来作为复用的通用函数，使发布者和订阅者呈松散耦合。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass EventBus {\n  constructor(evtMap = new Map()) {\n    this.evtMap = evtMap;\n  }\n  \u002F\u002F 添加订阅\n  on(type, handler) {\n    const handlers = this.evtMap.get(type);\n    const added = handlers &amp;&amp; handlers.push(handler);\n    !added &amp;&amp; this.evtMap.set(type, [handler]);\n  }\n  \u002F\u002F 取消订阅\n  off(type, handler) {\n    const handlers = this.evtMap.get(type);\n    if (!handlers) return false;\n    if (!handler) {\n      handlers.length = 0;\n      return;\n    }\n    handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; 0, 1);\n  }\n  \u002F\u002F 触发回调\n  emit(type, evt) {\n    (this.evtMap || []).forEach(handler =&gt; handler(evt));\n  }\n}\n\n\u002F\u002F 使用\nconst eventBus = EventBus();\n\neventBus.on('foo', e =&gt; console.log('foo', e)); \u002F\u002F 订阅事件\neventBus.emit('foo', { a: 'b' }); \u002F\u002F 触发事件\neventBus.evtMap.clear(); \u002F\u002F 清除所有订阅\n\nfunction onFoo() {}\neventBus.on('foo', onFoo); \u002F\u002F 订阅\neventBus.off('foo', onFoo); \u002F\u002F 取消订阅\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 id=\"moshiyoudian-2\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian-2')\"\u003E¶\u003C\u002Fa\u003E 模式优点\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E时间上进行了解耦。\u003C\u002Fli\u003E\n\u003Cli\u003E对象之间进行了解耦。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch5 id=\"moshiquedian-2\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian-2')\"\u003E¶\u003C\u002Fa\u003E 模式缺点\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E需要额外消耗一定的时间和内存。\u003C\u002Fli\u003E\n\u003Cli\u003E当订阅一个消息后，如果这个消息最后都未发生，这个订阅者却会一直存在于内存当中。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"minglingmoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'minglingmoshi')\"\u003E¶\u003C\u002Fa\u003E 命令模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E从代码结构分析命令模式，其实它与策略模式很类似，都定义一系列的算法，把它们一个个封装起来，再根据实际的类型去调用它们。但是从行为分析会发现它们大大不同，命令模式会将所有发出的命令收集到一个命令队列，记录了这些命令的执行类型和顺序，必要时可对指定命令执行撤销操作或者对整个命令队列进行重放等。\u003C\u002Fp\u003E\n\u003Cp\u003E下面是一个典型的编辑器例子：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass TextEditor {\n  constructor() {}\n  copy() {\n    console.log('editor copy!');\n    \u002F\u002F do some stuff...\n  }\n  paste() {\n    console.log('editor paste!');\n    \u002F\u002F do some stuff...\n  }\n  delete() {\n    console.log('editor delete!');\n    \u002F\u002F do some stuff...\n  }\n  insert() {\n    console.log('editor insert!');\n    \u002F\u002F do some stuff...\n  }\n}\n\nclass CommandCollector {\n  constructor(commandList = []) {\n    this.commandList = commandList;\n  }\n  add(command) {\n    this.commandList.push(command);\n  }\n  execute() {\n    this.commandList.forEach(command =&gt; command.execute());\n  }\n}\n\nfunction noop() {}\n\nclass Command {\n  constructor(receiver = {}, commandType) {\n    this.receiver = receiver;\n    this.callback = receiver[commandType] || noop;\n  }\n  execute(...args) {\n    this.callback(...args);\n  }\n}\n\nconst editor = new TextEditor();\nconst commandCollector = new CommandCollector();\nconst commands = ['copy', 'paste', 'delete', 'insert'];\n\ncommands.forEach(commandType =&gt; {\n  const command = new Command(editor, commandType);\n  command.execute(); \u002F\u002F editor copy!\n  \u002F\u002F editor paste!\n  \u002F\u002F editor delete!\n  \u002F\u002F editor insert!\n  commandCollector.add(command);\n});\n\n\u002F\u002F 重播命令\ncommandCollector.execute(); \u002F\u002F editor copy!\n\u002F\u002F editor paste!\n\u002F\u002F editor delete!\n\u002F\u002F editor insert!\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"zuhemoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zuhemoshi')\"\u003E¶\u003C\u002Fa\u003E 组合模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E将对象组合成树形结构以表示「部分-整体」的层次结构，使得用户对单个对象和组合对象的使用具有一致性。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E从上面的定义可以知道组合模式的两个特点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cstrong\u003E表示树形结构\u003C\u002Fstrong\u003E。组合模式的「组合对象」由「叶对象」组成，形成一种特殊的树形结构，并提供了一种遍历树形结构的方案，通过调用组合对象的指定方法，递归调用下游「叶对象」同名方法。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E利用对象多态统一对待组合对象和单一对象\u003C\u002Fstrong\u003E。利用对象的多态表现，可以使客户端忽略组合对象和叶对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它是组合对象还是叶对象。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E             ┌───────────┐\n             │ Composite │ \u002F\u002F 组合对象\n             └───────────┘\n                   ▲\n      ┌────────────┼────────────┐\n      │            │            │\n┌───────────┐┌───────────┐┌───────────┐\n│   leaf    ││   leaf    ││ Composite │\n└───────────┘└───────────┘└───────────┘\n                                ▲\n                   ┌────────────┼────────────┐\n                   │            │            │\n             ┌───────────┐┌───────────┐┌───────────┐\n             │   leaf    ││   leaf    ││   leaf    │ \u002F\u002F 叶对象\n             └───────────┘└───────────┘└───────────┘\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E关键的一点就是「组合对象」和「叶对象」具有统一的接口，并且「组合对象」由「叶对象」组成，下面是实现方式。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Composite {\n  constructor(leavesMap = []) {\n    if (new.target === Composite) {\n      this.leavesMap = leavesMap;\n    }\n  }\n  add(leaf) {\n    this.leavesMap.push(leaf);\n  }\n  execute() {\n    this.leavesMap.forEach(leaf =&gt; leaf.execute());\n  }\n}\n\nfunction noop() {}\n\nclass Leaf extends Composite {\n  constructor(callback = noop) {\n    super();\n    this.callback = callback;\n  }\n  add() {\n    throw new Error('叶对象不能添加子结点'); \u002F\u002F 统一接口，但需要限制叶结点不能调用 add 方法\n  }\n  execute() {\n    this.callback();\n  }\n}\n\n\u002F\u002F 使用组合模式表示上图的树形结构\nconst com1 = new Composite();\nconst leaf1 = new Leaf(() =&gt; {\n  console.log('leaf1 execute!');\n});\nconst leaf2 = new Leaf(() =&gt; {\n  console.log('leaf2 execute!');\n});\nconst com2 = new Composite();\nconst leaf3 = new Leaf(() =&gt; {\n  console.log('leaf3 execute!');\n});\nconst leaf4 = new Leaf(() =&gt; {\n  console.log('leaf4 execute!');\n});\nconst leaf5 = new Leaf(() =&gt; {\n  console.log('leaf5 execute!');\n});\n\ncom1.add(leaf1);\ncom1.add(leaf2);\ncom1.add(com2);\ncom2.add(leaf3);\ncom2.add(leaf4);\ncom2.add(leaf5);\n\ncom1.execute(); \u002F\u002F leaf1 execute!\n\u002F\u002F leaf2 execute!\n\u002F\u002F leaf3 execute!\n\u002F\u002F leaf4 execute!\n\u002F\u002F leaf5 execute!\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"mobanfangfamoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'mobanfangfamoshi')\"\u003E¶\u003C\u002Fa\u003E 模板方法模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E模板方法模式的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，也即：\u003Cstrong\u003E父类定义骨架，子类实现某些细节\u003C\u002Fstrong\u003E。由此可知此模式主要由两部分结构构成：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cstrong\u003E抽象父类\u003C\u002Fstrong\u003E。通常在抽象父类中封装了子类的算法框架，包括实现了一些公共方法以及封装子类中所有方法的执行顺序。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E具体的实现子类\u003C\u002Fstrong\u003E。子类通过继承抽象父类的方式继承整个算法框架，并且可重写除公共方法以外的父类方法。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E传统 OOP 抽象类的主要作用是为它的子类定义公共接口，需要注意的是 JavaScript 不存在抽象类的概念（Typescript 实现了），所以没有办法从语言层面去强制子类重写一些细节方法。因此，必须使用在父类的细节方法定义里以抛出异常的方式去强制子类重写细节方法。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass SuperClass {\n  \u002F\u002F 公共方法\n  stepStart() {\n    console.log('start');\n  }\n  \u002F\u002F 细节方法\n  stepSecond() {\n    throw new Error('子类必须重写 stepSecond 方法');\n  }\n  \u002F\u002F 细节方法\n  stepThird() {\n    throw new Error('子类必须重写 stepThird 方法');\n  }\n  \u002F\u002F 公共方法\n  stepEnd() {\n    console.log('end');\n  }\n  \u002F\u002F 定义算法\n  run() {\n    this.stepStart();\n    this.stepSecond();\n    this.stepThird();\n    this.stepEnd();\n  }\n}\n\nclass SubClassA extends SuperClass {\n  constructor() {\n    super();\n  }\n  \u002F\u002F 重写细节方法\n  stepSecond() {\n    console.log('subClassA step second');\n  }\n  \u002F\u002F 重写细节方法\n  stepThird() {\n    console.log('subClassA step third');\n  }\n}\n\nclass SubClassB extends SuperClass {\n  constructor() {\n    super();\n  }\n  \u002F\u002F 重写细节方法\n  stepSecond() {\n    console.log('subClassB step second');\n  }\n  \u002F\u002F 重写细节方法\n  stepThird() {\n    console.log('subClassB step third');\n  }\n}\n\nconst subA = new SubClassA();\nsubA.run(); \u002F\u002F start\n\u002F\u002F subClassA step second\n\u002F\u002F subClassA step third\n\u002F\u002F end\n\nconst subB = new SubClassB();\nsubB.run(); \u002F\u002F start\n\u002F\u002F subClassA step second\n\u002F\u002F subClassA step third\n\u002F\u002F end\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"xiangyuanmoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangyuanmoshi')\"\u003E¶\u003C\u002Fa\u003E 享元模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E运用共享技术有效地支持大量细粒度的对象。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E享元模式（Flyweight）是一种性能优化方案，当程序中需要用到大量相似的对象，而这些对象又可以区分出「内部状态」和「外部状态」的时候，就可以使用享元模式来共享单一实例。在实际使用具体对象的时候，通过将「外部状态」与单一实例进行实时组装，从而获得短暂可用的目标对象，在使用完目标对象后再还原成原来的单一实例（视实际情况）。\u003C\u002Fp\u003E\n\u003Cp\u003E具体来说，判断一个业务场景时候适合使用享元模式来进行优化，一般需要满足以下几点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E一个程序中使用了大量相似的对象。\u003C\u002Fli\u003E\n\u003Cli\u003E由于使用了大量对象，造成很大的内存开销。\u003C\u002Fli\u003E\n\u003Cli\u003E对象的大多数状态可以变为外部状态。\u003C\u002Fli\u003E\n\u003Cli\u003E剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E下面是一个文件上传功能的例子，这个文件上传功能具有多个上传类型，用户可以根据实际情况选择不同的上传类型。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Upload {\n  constructor(uploadType) {\n    this.uploadType = uploadType;\n  }\n  delFile(id) {\n    uploadManager.setExternalState(id, this);\n    if (this.fileSize &lt; 3000) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n    if (window.confirm(`Are sure to delete this file: ${this.dom}?`)) {\n      return this.dom.parentNode.removeChild(this.dom);\n    }\n  }\n}\n\nconst UploadFactory = {\n  createdFlyweightObjs: {},\n  create(uploadType) {\n    if (this.createdFlyweightObjs[uploadType]) {\n      return this.createdFlyweightObjs[uploadType];\n    }\n    return (this.createdFlyweightObjs[uploadType] = new Upload(uploadType));\n  },\n};\n\nconst UploadManager = {\n  uploadDatabase: {},\n  add(id, uploadType, filename, fileSize) {\n    const flyweightObj = UploadFactory.create(uploadType);\n    const dom = document.createElement('div');\n    dom.innerHTML = `&lt;span&gt;File name: ${filename},File size: ${fileSize}&lt;\u002Fspan&gt;\n    &lt;button class=&quot;delFile&quot;&gt;Delete&lt;\u002Fbutton&gt;`;\n    document.querySelector('.delFile').onclick = () =&gt; flyweightObj.delFile(id);\n    document.body.appendChild(dom);\n    uploadDatabase[id] = { filename, fileSize, dom };\n    return flyweightObj;\n  },\n  setExternalState(id, flyweightObj) {\n    const uploadData = this.database[id];\n    for (let key in uploadData) {\n      flyweightObj[key] = uploadData[key];\n    }\n  }\n};\n\n\u002F\u002F 使用\nlet id = 0;\nconst startUpload = (uploadType, files) =&gt; {\n  for(let i = 0, file; file = files[i++]) {\n    uploadManager.add(++id, uploadType, file.filename, file.fileSize);\n  }\n}\n\nstartUpload('plugin', [{\n  filename: '1.txt',\n  fileSize: 1000,\n},{\n  filename: '2.txt',\n  fileSize: 3000,\n},{\n  filename: '3.txt',\n  fileSize: 5000,\n}]);\n\nstartUpload('flash', [{\n  filename: '4.txt',\n  fileSize: 1000,\n},{\n  filename: '5.txt',\n  fileSize: 3000,\n},{\n  filename: '6.txt',\n  fileSize: 5000,\n}]);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E对于使用大量相似对象还有一种与享元模式类似的优化方案，它就是「对象池」。对象池维护了一个装载空闲对象的池子，如果需要对象的时候，不是直接创建新对象，而是先从对象池里获取，如果对象池里没有空闲对象，再去创建新对象，当创建的新对象完成了它的职责之后，再放入对象池等待被下次获取。这里需要注意的是，对象池没有分离内部状态和外部状态。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Efunction noop() {\n  return {};\n}\n\nclass ObjectPool {\n  constructor(creator = noop, pool = []) {\n    this.pool = pool;\n    this.creator = creator;\n  }\n  getObject(...args) {\n    return this.pool.shift() || this.creator(...args);\n  }\n  recoverObject(poolItem) {\n    this.pool.push(poolItem);\n  }\n}\n\nfunction createIframe() {\n  const iframe = document.createElement('iframe');\n  document.body.appendChild(iframe);\n\n  iframe.onload = () =&gt; {\n    iframe.onload = null;\n    iframePool.recoverObject(iframe); \u002F\u002F 加载完成后回收\n  };\n\n  return iframe;\n}\n\nconst iframePool = new ObjectPool(createIframe);\n\nconst iframe1 = iframePool.getObject();\niframe1.src = 'https:\u002F\u002Flkangd.com\u002F';\n\nconst iframe2 = iframePool.getObject();\niframe2.src = 'https:\u002F\u002Fgithub.com\u002F';\n\nsetTimeout(() =&gt; {\n  const iframe3 = iframePool.getObject();\n  iframe3.src = 'https:\u002F\u002Fgoogle.com\u002F';\n}, 3000);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"zhizelianmoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhizelianmoshi')\"\u003E¶\u003C\u002Fa\u003E 职责链模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象炼成一条链，并沿着这条链传递改请求，知道有一个对象处理它为止。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。\u003C\u002Fp\u003E\n\u003Cp\u003E职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接受者之间的强联系。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E     ┌─────────┐\n     │ Request │\n     └─────────┘\n          │\n┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐ ─ ─ ─ ─┐\n          ▼\n│  ┌─────────────┐  │        │\n   │ ProcessorA  │\n│  └─────────────┘  │        │\n          │\n│         ▼         │        │\n   ┌─────────────┐\n│  │ ProcessorB  │  │   HandlerChain\n   └─────────────┘\n│         │         │        │\n          ▼\n│  ┌─────────────┐  │        │\n   │ ProcessorC  │\n│  └─────────────┘  │        │\n          │\n└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘ ─ ─ ─ ─┘\n          │\n          ▼\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E使用代码现实上图。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Request {\n  constructor(amount = 0) {\n    this.amount = amount;\n  }\n  getAmount() {\n    return this.amount;\n  }\n}\n\nclass HandlerChain {\n  constructor(handlers = []) {\n    this.handlers = [];\n  }\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n  process(...args) {\n    for (let i = 0, handler; (handler = this.handlers[i++]); ) {\n      const result = handler.process(...args);\n      if (result !== null) {\n        return result;\n      }\n    }\n    throw new Error(`Could not handle request: ${args}`);\n  }\n}\n\nclass ProcessorA {\n  constructor() {}\n  process(request) {\n    if (request.getAmount() &gt; 1000) return null; \u002F\u002F 设置职责门槛\n    console.log('ProcessorA success!');\n  }\n}\nclass ProcessorB {\n  constructor() {}\n  process(request) {\n    if (request.getAmount() &gt; 2000) return null; \u002F\u002F 设置职责门槛\n    console.log('ProcessorB success!');\n  }\n}\nclass ProcessorC {\n  constructor() {}\n  process(request) {\n    if (request.getAmount() &gt; 3000) return null; \u002F\u002F 设置职责门槛\n    console.log('ProcessorC success!');\n  }\n}\n\n\u002F\u002F 使用\nconst chain = new HandlerChain();\n\u002F\u002F 设置职责链，注意顺序\nchain.addHandler(new ProcessorA());\nchain.addHandler(new ProcessorB());\nchain.addHandler(new ProcessorC());\n\nconst req1 = new Request(999);\nconst req2 = new Request(1999);\nconst req3 = new Request(2999);\nconst req4 = new Request(3001); \u002F\u002F 超出职责范围\n\nchain.process(req1); \u002F\u002F ProcessorA success!\nchain.process(req2); \u002F\u002F ProcessorB success!\nchain.process(req3); \u002F\u002F ProcessorC success!\nchain.process(req4); \u002F\u002F Uncaught Error: Could not handle request: [object Object]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"zhongjiezhemoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhongjiezhemoshi')\"\u003E¶\u003C\u002Fa\u003E 中介者模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变他们之间的交互。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E中介者模式（Mediator）的作用是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是相互作用，所以当一个对象发生改变时，只需要通知中介者即可。\u003C\u002Fp\u003E\n\u003Cp\u003E使用中介者之前对象间相互影响。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E┌─────────────────┐     ┌─────────────────┐\n│        A        │&lt;───&gt;│        B        │\n└─────────────────┘     └─────────────────┘\n         ▲ ▲                     ▲\n         │ └─────────────────────┤\n         ▼                       │\n┌─────────────────┐     ┌────────┴────────┐\n│        C        │&lt;────│        D        │\n└─────────────────┘     └─────────────────┘\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E使用中介者后对象只与中介者交互，从而解除了对象间的强耦合关系。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E            ┌─────────────────┐\n     ┌─────&gt;│        A        │\n     │      └─────────────────┘\n     │      ┌─────────────────┐\n     │ ┌───&gt;│        B        │\n     ▼ ▼    └─────────────────┘\n┌─────────┐\n│  中介者  │\n└─────────┘\n     ▲ ▲    ┌─────────────────┐\n     │ └───&gt;│        C        │\n     │      └─────────────────┘\n     │      ┌─────────────────┐\n     └─────&gt;│        D        │\n            └─────────────────┘\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E使用代码现实上图。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 使用中介者模式前\nclass Node {\n  constructor(status = true, influenceNodes = []) {\n    this.status = status;\n    this.influenceNodes = influenceNodes;\n  }\n  addInfluence(node) {\n    this.influenceNodes.push(node);\n  }\n  change(status) {\n    const newStatus = status === undefined ? !this.status : status;\n    this.status = newStatus;\n    this.influenceNodes.forEach(node =&gt; (node.status = !newStatus));\n  }\n}\n\nconst A = new Node(false);\nconst B = new Node();\nconst C = new Node();\nconst D = new Node();\n\n\u002F\u002F A 影响 B, C\nA.addInfluence(B);\nA.addInfluence(C);\n\u002F\u002F B 影响 A\nB.addInfluence(A);\n\u002F\u002F C 影响 A\nC.addInfluence(A);\n\u002F\u002F D 影响 A, B, C\nD.addInfluence(A);\nD.addInfluence(B);\nD.addInfluence(C);\n\nA.change();\nconsole.log(A.status, B.status, C.status, D.status); \u002F\u002F true, false, false, true\n\nD.change();\nconsole.log(A.status, B.status, C.status, D.status); \u002F\u002F true, true, true, false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 引入中介者\nclass Node {\n  constructor(type, status = true) {\n    this.status = status;\n    this.type = type;\n  }\n  change(status) {\n    const newStatus = status === undefined ? !this.status : status;\n    this.status = newStatus;\n  }\n}\n\nconst A = new Node('A', false);\nconst B = new Node('B');\nconst C = new Node('C');\nconst D = new Node('D');\n\n\u002F\u002F 将对象间影响的逻辑封装到中介者\nconst mediator = function(node) {\n  const newStatus = !node.status;\n  switch (node.type) {\n    case 'A': \u002F\u002F A 影响 B, C\n      B.change(newStatus);\n      C.change(newStatus);\n      break;\n    case 'B': \u002F\u002F B 影响 A\n      A.change(newStatus);\n      break;\n    case 'C': \u002F\u002F C 影响 A\n      A.change(newStatus);\n      break;\n    case 'D': \u002F\u002F D 影响 A, B, C\n      A.change(newStatus);\n      B.change(newStatus);\n      C.change(newStatus);\n      break;\n    default:\n      console.log('unsupported type!', node.type);\n  }\n};\n\nA.change();\nmediator(A);\nconsole.log(A.status, B.status, C.status, D.status); \u002F\u002F true, false, false, true\n\nD.change();\nmediator(D);\nconsole.log(A.status, B.status, C.status, D.status); \u002F\u002F true, true, true, false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"zhuangshizhemoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhuangshizhemoshi')\"\u003E¶\u003C\u002Fa\u003E 装饰者模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在不改变对象的基础上，动态地给对象添加一些额外的职责。就增加功能而言，相比生成子类更加灵活。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E装饰器（Decorator）模式的核心思想与流行的 AOP（面向切面）编程方法论是一致的，目的都是为了在不改变对象本身的前提上，在对象方法的出入口去改变方法的行为。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 入口切面\nFunction.prototype.before = function(beforeFn) {\n  const originFn = this;\n  return function(...args) {\n    beforeFn.apply(this, args);\n    return originFn.apply(this, args);\n  };\n};\n\n\u002F\u002F 出口切面\nFunction.prototype.after = function(afterFn) {\n  const originFn = this;\n  return function(...args) {\n    const ret = originFn.apply(this, args);\n    afterFn.call(this, ret);\n    return ret;\n  };\n};\n\nfunction execute(number) {\n  console.log('execute!');\n  return number * number;\n}\n\nexecute(10); \u002F\u002F execute! 100\n\nfunction logBefore(number) {\n  console.log('before fn log, number is:', number);\n}\nfunction logAfter(result) {\n  console.log('after fn log, result is:', result);\n}\n\nexecute.before(logBefore)(10); \u002F\u002F before fn log, number is: 10\n\u002F\u002F execute!\n\nexecute.after(logAfter)(10); \u002F\u002F execute!\n\u002F\u002F after fn log, result is: 100\n\nexecute.before(logBefore).after(logAfter)(10); \u002F\u002F before fn log, number is: 10\n\u002F\u002F execute!\n\u002F\u002F after fn log, result is: 100\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E最新的 ES \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-decorators\" target=\"_blank\"\u003E提案\u003C\u002Fa\u003E 里已经实现了原生的装饰器语法，ES 的装饰器可以很便捷地修改类和类方法的行为。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Efunction log(target, name, descriptor) {\n  const oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nclass Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nconst math = new Math();\n\nmath.add(2, 4); \u002F\u002F Calling add with 2, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"zhuangtaimoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhuangtaimoshi')\"\u003E¶\u003C\u002Fa\u003E 状态模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E状态模式（State）经常用在带有状态的对象中，可以按两个部分来理解上面的定义：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。\u003C\u002Fli\u003E\n\u003Cli\u003E从客户的角度来看，使用对象时，在不同状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E传统的面向对象语言的状态模式实现会为每种状态定义一个状态子类，然后在 Context 中持有这些状态对象的引用，以便把当前状态切换为当前的状态对象。但在 JavaScript 这种“无类”语言中，没有规定让状态对象一定要从类中创建出来。另外一点，JavaScript 可以非常方便地使用委托技术，并不需要事先让一个对象只有另一个对象。下面是 JavaScript 对状态模式的实现。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 一个使用状态模式的开关灯程序\nconst delegate = function(client, delegation) {\n  return {\n    \u002F\u002F 将客户的操作委托给 delegation 对象\n    buttonWasPressed() {\n      return delegation.buttonWasPressed.apply(client, arguments);\n    },\n  };\n};\n\n\u002F\u002F 状态类封装\nconst FSM = {\n  off: {\n    buttonWasPressed() {\n      console.log('关灯');\n      this.button.innerHTML = '下一次按我就是开灯。';\n      this.currentState = this.onState;\n    },\n  },\n  on: {\n    buttonWasPressed() {\n      console.log('开灯');\n      this.button.innerHTML = '下一次按我就是关灯。';\n      this.currentState = this.offState;\n    },\n  },\n};\n\nclass Light {\n  constructor() {\n    this.offState = delegate(this, FSM.off);\n    this.onState = delegate(this, FSM.on);\n    this.currentState = this.offState; \u002F\u002F 设置初始状态为关闭状态\n    this.button = null;\n  }\n  init() {\n    const button = document.createElement('button');\n    button.innerHTML = '已关灯';\n    this.button = document.body.appendChild(button);\n    this.button.onclick = function() {\n      this.currentState.buttonWasPressed();\n    }.bind(this);\n  }\n}\n\nconst light = new Light();\nlight.init();\n\nlight.button.click(); \u002F\u002F 开灯\nlight.button.click(); \u002F\u002F 关灯\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch5 id=\"moshiyoudian-3\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian-3')\"\u003E¶\u003C\u002Fa\u003E 模式优点\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。\u003C\u002Fli\u003E\n\u003Cli\u003E避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过于多的条件分支。\u003C\u002Fli\u003E\n\u003Cli\u003E用对象代替字符串记录当前状态，是的状态的切换更加一目了然。\u003C\u002Fli\u003E\n\u003Cli\u003EContext 中的请求动作和状态类中封装的行为可以非常容易地独立变化而不受影响。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch5 id=\"moshiquedian-3\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian-3')\"\u003E¶\u003C\u002Fa\u003E 模式缺点\u003C\u002Fh5\u003E\n\u003Cul\u003E\n\u003Cli\u003E定义了许多状态类，因此系统中会增加不少对象。\u003C\u002Fli\u003E\n\u003Cli\u003E虽然避开了不受欢迎的条件分支，但也造成了逻辑松散的问题，无法在一个地方就看出这个状态机的逻辑。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"shipeiqimoshi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shipeiqimoshi')\"\u003E¶\u003C\u002Fa\u003E 适配器模式\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E适配器（Adapter）模式的别名是包装器（wrapper），是一个相对简单的模式，它作用是解决两个软件之间接口不兼容的问题，使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配器模式是一种“亡羊补牢”的模式，一般不会在程序设计之初就是用它。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass NormalProcessor {\n  constructor(action) {\n    this.action = action;\n  }\n  show() {\n    console.log('start doing ', this.action);\n  }\n}\n\nconst makeAction = processor =&gt; processor.show(); \u002F\u002F 原有逻辑\nconst processors = [new NormalProcessor('stand'), new NormalProcessor('walk')];\n\nprocessors.forEach(p =&gt; makeAction(p)); \u002F\u002F stand walk\n\n\u002F\u002F 非兼容接口\nclass IncompatibleProcessor {\n  constructor(action) {\n    this.action = action;\n  }\n  display() {\n    console.log('start doing ', this.action);\n  }\n}\n\nconst runProcessor = new IncompatibleProcessor('run');\n\nprocessors.push(runProcessor);\nprocessors.forEach(p =&gt; makeAction(p)); \u002F\u002F stand walk Uncaught TypeError: processor.show is not a function\n\n\u002F\u002F 生成一个适配器对象\nconst makeAdapter = (originObj, originFnName, adapterFnName) =&gt; {\n  return {\n    [adapterFnName](...args) {\n      return originObj[originFnName](...args);\n    },\n  };\n};\n\nconst runProcessorAdapter = makeAdapter(runProcessor, 'display', 'show');\nprocessors.splice(processors.length - 1, 1, runProcessorAdapter);\nprocessors.forEach(p =&gt; makeAction(p)); \u002F\u002F stand walk run\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2 id=\"jieyan\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyan')\"\u003E¶\u003C\u002Fa\u003E 结言\u003C\u002Fh2\u003E\n\u003Cp\u003E所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部分封装起来，那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。这也是设计模式为什么描写的是可复用面向对象软件基础的原因。\u003C\u002Fp\u003E\n\u003Cp\u003E学习设计模式时不应该根据模式的名字去臆测该模式的一切，而是要理解模式具体能解决的问题和改模式的适用场景，才能避免对模式的滥用和误用，让模式为开发赋能。\u003C\u002Fp\u003E\n\u003Ch4 id=\"cankao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cankao')\"\u003E¶\u003C\u002Fa\u003E 参考\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fbook.douban.com\u002Fsubject\u002F26382780\u002F\" target=\"_blank\"\u003EJavaScript 设计模式与开发实践\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fbook.douban.com\u002Fsubject\u002F1436745\u002F\" target=\"_blank\"\u003EDesign Patterns\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.liaoxuefeng.com\u002Fwiki\u002F1252599548343744\u002F1264742167474528\" target=\"_blank\"\u003E设计模式-廖雪峰\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fes6.ruanyifeng.com\u002F\" target=\"_blank\"\u003EES6入门教程-阮一峰\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",bodyBegin:7,frontmatter:"title: Design Patterns In Javascript\ndate: '2019-09-03'\nspoiler: 总结常用设计模式在 Javascript 中的实现",link:a,next:{title:"何为「Git Commit」最佳姿势？",date:"2020-05-15",spoiler:"让你的每一个「Git Commit」更有价值，而不是形式主义下的流水账",featured:true,link:"\u002Fpost\u002Fdevelop-good-git-commit-habits\u002F",min2read:"☕️☕️☕️☕️☕️ 26 min read",wordcount:"6k"},prev:{title:"树数据结构的原理及JS实现",date:"2019-06-29",spoiler:"JavaScript语言环境下的树学习",featured:false,link:"\u002Fpost\u002Fdata-structure-tree\u002F",min2read:"☕️☕️☕️ 17 min read",wordcount:"3.8k"}}}],fetch:[],mutations:void 0}}("\u002Fpost\u002Fdesign-patterns-in-javascript\u002F")));