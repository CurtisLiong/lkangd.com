__NUXT_JSONP__("/post/virtual-infinite-scroll", (function(a,b){return {data:[{post:{attributes:{title:"剖析无限滚动虚拟列表的实现原理",date:"2020-08-26",spoiler:"长列表渲染的终极优化手段",featured:true,link:a,min2read:"🍱🍱 28 min read",wordcount:"7k"},body:"\u003Cp\u003E\u003Cdiv class=\"cs-toc-dom\"\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#shimoshixuniliebiao\"\u003E什么是虚拟列表？\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#xiangguangainian\"\u003E相关概念\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#shixianluojibuzhou\"\u003E实现逻辑步骤\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#gudinggaodudexuniliebiao\"\u003E固定高度的虚拟列表\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#zhunbeigongzuogudinggaodu\"\u003E准备工作|固定高度\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jisuankegundonggaodu\"\u003E计算「可滚动高度」\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jisuanchushikeshiyuansu\"\u003E计算初始「可视元素」\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#gundonggengxinkeshiyuansugudinggaodu\"\u003E滚动更新「可视元素」|固定高度\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#dongtaigaodudexuniliebiao\"\u003E动态高度的虚拟列表\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#guanjiandianyiruhehuodeyuansudedongtaigaodu\"\u003E关键点一：如何获得元素的动态高度？\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#guanjiandianerruhemonikegundonggaodu\"\u003E关键点二：如何模拟「可滚动高度」？\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#guanjiandiansanruhejisuanmeiyigeyuansudescrollY\"\u003E关键点三：如何计算每一个元素的「scrollY」？\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zhunbeigongzuodongtaigaodu\"\u003E准备工作|动态高度\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jiantingyuansugaodubianhua\"\u003E监听元素高度变化\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#gundonggengxinkeshiyuansudongtaigaodu\"\u003E滚动更新「可视元素」|动态高度\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#xiuzhenggundongtiao\"\u003E修正滚动条\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zongjie\"\u003E总结\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003ETL;DR：\u003C\u002Fstrong\u003E「虚拟列表」的本质就是仅将\u003Cstrong\u003E需要显示在视窗中\u003C\u002Fstrong\u003E的列表节点挂载到 DOM，是一种优化长列表加载的技术手段。其中按照节点的高度是否固定又分为「固定高度的虚拟列表」和「动态高度的虚拟列表」。这是本文对两种虚拟列表场景实现的 \u003Ca href=\"https:\u002F\u002Flkangd.github.io\u002Finfinite-scroll-sample\u002F#\u002F\" target=\"_blank\"\u003Edemo\u003C\u002Fa\u003E(页面托管在 github pages 可能需要爬梯子) 和 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flkangd\u002Finfinite-scroll-sample\" target=\"_blank\"\u003E代码库\u003C\u002Fa\u003E(基于 Vue 2.x)。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E在进行前端业务开发时，很容易遇到需要加载巨大列表的场景。比如微博的信息流、微信的朋友圈和直播平台的聊天框等，这些列表通常具有两个显著的特点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E不能分页；\u003C\u002Fli\u003E\n\u003Cli\u003E只要用户愿意就可以无限地滚动下去。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在这种场景下，如果直接加载一个数量级很大的列表，会造成页面假死，使用传统的上拉分页加载模式或者 \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FAPI\u002FWindow\u002FrequestAnimationFrame\" target=\"_blank\"\u003Ewindow.requestAnimationFrame\u003C\u002Fa\u003E空闲加载模式可以在一定程度上缓解这种情况，但是在加载到一定量级的页面时，会因为页面同时存在大量的 DOM 元素而出现过渡占用内存、页面卡顿等性能问题，带来糟糕的用户体验。因此必须对这种业务场景做相应的加载优化，\u003Cstrong\u003E只加载需要显示的元素\u003C\u002Fstrong\u003E是这种情况的唯一解，「虚拟列表」的概念应运而生。\u003C\u002Fp\u003E\n\u003Ch2 id=\"shimoshixuniliebiao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshixuniliebiao')\"\u003E¶\u003C\u002Fa\u003E 什么是虚拟列表？\u003C\u002Fh2\u003E\n\u003Cp\u003E首先，来说说「虚拟列表」的定义，它的本质就是仅将\u003Cstrong\u003E需要显示在视窗中\u003C\u002Fstrong\u003E的列表节点挂载到 DOM，以达到「减少\u003Cstrong\u003E一次性加载节点数量\u003C\u002Fstrong\u003E」和「减少\u003Cstrong\u003E滚动容器内总挂载节点数量\u003C\u002Fstrong\u003E」的目的，也即：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E通过「\u003Cstrong\u003E单个元素高度\u003C\u002Fstrong\u003E」计算当前列表全部加载时的高度作为「\u003Cstrong\u003E滚动容器\u003C\u002Fstrong\u003E」的「\u003Cstrong\u003E可滚动高度\u003C\u002Fstrong\u003E」，按该「\u003Cstrong\u003E可滚动高度\u003C\u002Fstrong\u003E」撑开「\u003Cstrong\u003E滚动容器\u003C\u002Fstrong\u003E」。并根据「\u003Cstrong\u003E当前滚动高度\u003C\u002Fstrong\u003E」，在「\u003Cstrong\u003E可视区域\u003C\u002Fstrong\u003E」内按需加载列表元素。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"xiangguangainian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangguangainian')\"\u003E¶\u003C\u002Fa\u003E 相关概念\u003C\u002Fh3\u003E\n\u003Cp\u003E上面的描述提到了几个关键的概念，它们分别是：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E单个元素高度\u003C\u002Fstrong\u003E：列表内每个独立元素的高度，它可以是固定的或者是动态的。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E滚动容器\u003C\u002Fstrong\u003E：意指挂载列表元素的 DOM 对象，它可以是自定义的元素或者\u003Ccode\u003Ewindow\u003C\u002Fcode\u003E对象(默认)。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E可滚动高度\u003C\u002Fstrong\u003E：滚动容器可滚动的纵向高度。当滚动容器的高度（宽度），小于它的子元素所占的总高度（宽度）且该滚动容器的\u003Ccode\u003Eoverflow\u003C\u002Fcode\u003E不为\u003Ccode\u003Ehidden\u003C\u002Fcode\u003E时，此时滚动容器的\u003Ccode\u003EscrollHeight\u003C\u002Fcode\u003E为\u003Cstrong\u003E可滚动高度\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E可视区域\u003C\u002Fstrong\u003E：滚动容器的视觉可见区域。如果容器元素是\u003Ccode\u003Ewindow\u003C\u002Fcode\u003E对象，可视区域就是浏览器的视口大小（即视觉视口）；如果容器元素是某个 ul 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域，也即是该滚动容器的\u003Ccode\u003EoffsetHeight\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E当前滚动高度\u003C\u002Fstrong\u003E：与平常的滚动高度概念一致。虽然虚拟列表仅加载需要显示在可视区域内的元素，但是为了维持与常规列表一致的滚动体验，必须通过监听当前滚动高度来动态更新需要显示的元素。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考下图加深理解：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-0.8c610f9.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"shixianluojibuzhou\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shixianluojibuzhou')\"\u003E¶\u003C\u002Fa\u003E 实现逻辑步骤\u003C\u002Fh3\u003E\n\u003Cp\u003E因此，实现「虚拟列表」可以简单理解为就是在列表发生滚动时，改变「可视区域」内的渲染元素。大概的文字逻辑步骤如下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E根据单个元素高度计算出滚动容器的可滚动高度，并撑开滚动容器；\u003C\u002Fli\u003E\n\u003Cli\u003E根据可视区域计算总挂载元素数量；\u003C\u002Fli\u003E\n\u003Cli\u003E根据可视区域和总挂载元素数量计算头挂载元素（初始为 0）和尾挂载元素；\u003C\u002Fli\u003E\n\u003Cli\u003E当发生滚动时，根据滚动差值和滚动方向，重新计算头挂载元素和尾挂载元素。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E根据这些步骤，下面开始通过实际代码对「虚拟列表」进行实现。\u003C\u002Fp\u003E\n\u003Ch2 id=\"gudinggaodudexuniliebiao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gudinggaodudexuniliebiao')\"\u003E¶\u003C\u002Fa\u003E 固定高度的虚拟列表\u003C\u002Fh2\u003E\n\u003Ch3 id=\"zhunbeigongzuogudinggaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhunbeigongzuogudinggaodu')\"\u003E¶\u003C\u002Fa\u003E 准备工作|固定高度\u003C\u002Fh3\u003E\n\u003Cp\u003E首先，创建列表元素组件，约定它的高度固定为\u003Ccode\u003E180px\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-html\"\u003E\u003Ccode class=\"language-html\"\u003E&lt;template&gt;\n  &lt;li class=&quot;item&quot; ref=&quot;item&quot;&gt;\n    &lt;div class=&quot;item__wrapper&quot;&gt;\n      &lt;div class=&quot;item__info&quot;&gt;\n        &lt;img :src=&quot;data.avatar&quot; class=&quot;item__avatar&quot; \u002F&gt;\n        &lt;p class=&quot;item__name&quot;&gt;{{ index }}. {{ data.name }}&lt;\u002Fp&gt;\n        &lt;p class=&quot;item__date&quot;&gt;{{ data.dob }}&lt;\u002Fp&gt;\n      &lt;\u002Fdiv&gt;\n      &lt;p class=&quot;item__text&quot;&gt;E-mail: {{ data.email }}&lt;\u002Fp&gt;\n      &lt;p class=&quot;item__text&quot;&gt;Phone: {{ data.phone }}&lt;\u002Fp&gt;\n      &lt;p class=&quot;item__text&quot;&gt;City: {{ data.address.city }}&lt;\u002Fp&gt;\n      &lt;p class=&quot;item__text&quot;&gt;Street: {{ data.address.street }}&lt;\u002Fp&gt;\n    &lt;\u002Fdiv&gt;\n  &lt;\u002Fli&gt;\n&lt;\u002Ftemplate&gt;\n&lt;script&gt;\n  export default {\n    name: 'item',\n    props: {\n      index: {\n        type: Number, \u002F\u002F 元素下标\n        default: 0,\n      },\n      data: {\n        type: Object,\n        default: () =&gt; ({}),\n      },\n    },\n  };\n&lt;\u002Fscript&gt;\n&lt;style scoped lang=&quot;scss&quot;&gt;\n  .item {\n    height: 180px;\n    \u002F* ... *\u002F\n  }\n&lt;\u002Fstyle&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E通过\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmarak\u002FFaker.js\u002F\" target=\"_blank\"\u003Efaker.js\u003C\u002Fa\u003E来生成一些随机数据，以满足分页加载的测试情况：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eimport faker from 'faker';\n\nexport function fetchData(count = 30) {\n  const result = [];\n  for (let i = 0; i &lt; count; i++) {\n    const item = faker.helpers.contextualCard();\n    item.paragraph = faker.lorem.paragraph();\n    result.push(item);\n  }\n  return result;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E最后，创建滚动容器组件，引入\u003Ccode\u003Eitem\u003C\u002Fcode\u003E组件和随机数据，渲染列表：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-html\"\u003E\u003Ccode class=\"language-html\"\u003E&lt;template&gt;\n  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot;&gt;\n    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in listData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; \u002F&gt;\n  &lt;\u002Ful&gt;\n&lt;\u002Ftemplate&gt;\n&lt;script&gt;\n  import Item from '.\u002Fcomponents\u002Fitem';\n  import { fetchData } from '.\u002Fhelpers';\n\n  const FIXED_HEIGHT = 180;\n\n  export default {\n    name: 'height-fixed',\n    data() {\n      return {\n        listData: [],\n      };\n    },\n    mounted() {\n      this.fetchData();\n    },\n    methods: {\n      fetchData() {\n        this.listData.push(...this.setItemIndex(fetchData()));\n      },\n      \u002F\u002F 给每个列表元素设置固定的下标\n      setItemIndex(list) {\n        let latestIndex = this.listData.length;\n        for (let i = 0; i &lt; list.length; i++) {\n          const item = list[i];\n          item.index = latestIndex + i;\n          Object.freeze(item);\n        }\n        return list;\n      },\n    },\n    components: { Item },\n  };\n&lt;\u002Fscript&gt;\n&lt;style scoped lang=&quot;scss&quot;&gt;\n  .height-fixed {\n    width: 100%;\n    height: 100%;\n    overflow-x: hidden;\n    overflow-y: scroll;\n    \u002F* ... *\u002F\n  }\n&lt;\u002Fstyle&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E通过路由挂载后，完成一个常规列表的渲染，如下图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-1.92a1651.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"jisuankegundonggaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jisuankegundonggaodu')\"\u003E¶\u003C\u002Fa\u003E 计算「可滚动高度」\u003C\u002Fh3\u003E\n\u003Cp\u003E因为元素高度是固定，所以在拿到列表数据时就可以通过 \u003Cstrong\u003E列表长度\u003C\u002Fstrong\u003E * \u003Cstrong\u003E元素高度\u003C\u002Fstrong\u003E 获得「可滚动高度」，然后使用此高度撑开滚动容器。通过上文图一可以得知，可滚动高度由「可视区域」+「已浏览区域」+「待浏览区域」组成，关于如何撑开「已浏览区域」和「待浏览区域」，有两种常规的做法：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E直接使用 padding 撑开列表高度；\u003C\u002Fli\u003E\n\u003Cli\u003E在列表可视区域外部放置哨兵元素撑开高度。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E为了更好地理解后文「动态高度的虚拟列表」的内容，这里选用第二种方法。\u003C\u002Fp\u003E\n\u003Cp\u003E新增\u003Ccode\u003EscrollRunwayEnd\u003C\u002Fcode\u003E属性，在列表获取后计算总高度：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"6,12\" class=\"language-js\"\u003E\u003Ccode data-line=\"6,12\" class=\"language-js\"\u003Eexport default {\n  \u002F\u002F ...\n  data() {\n    return {\n      \u002F\u002F ...\n      scrollRunwayEnd: 0,\n    };\n  },\n  methods: {\n    fetchData() {\n      this.listData.push(...this.setItemIndex(fetchData()));\n      this.scrollRunwayEnd = this.listData.length * FIXED_HEIGHT;\n    },\n  },\n  \u002F\u002F ...\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在模板内增加\u003Ccode\u003Escroll-runway\u003C\u002Fcode\u003E元素，根据\u003Ccode\u003EscrollRunwayEnd\u003C\u002Fcode\u003E，使用\u003Ccode\u003Etransform: translateY\u003C\u002Fcode\u003E的方式撑开「滚动容器」高度：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"3\" class=\"language-html\"\u003E\u003Ccode data-line=\"3\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot; @scroll=&quot;handleScroll&quot;&gt;\n    &lt;li class=&quot;height-fixed__scroll-runway&quot; :style=&quot;`transform: translate(0, ${scrollRunwayEnd}px)`&quot;&gt;&lt;\u002Fli&gt;\n    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in listData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; \u002F&gt;\n  &lt;\u002Ful&gt;\n&lt;\u002Ftemplate&gt;\n&lt;!-- ... --&gt;\n&lt;style scoped lang=&quot;scss&quot;&gt;\n  .height-fixed {\n    \u002F* ... *\u002F\n    &amp;__scroll-runway {\n      position: absolute;\n      width: 1px;\n      height: 1px;\n      transition: transform 0.2s;\n    }\n  }\n&lt;\u002Fstyle&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"jisuanchushikeshiyuansu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jisuanchushikeshiyuansu')\"\u003E¶\u003C\u002Fa\u003E 计算初始「可视元素」\u003C\u002Fh3\u003E\n\u003Cp\u003E「可视元素」使用\u003Ccode\u003EvisibleData\u003C\u002Fcode\u003E表示，\u003Ccode\u003EvisibleData\u003C\u002Fcode\u003E可使用「头挂载元素」和「尾挂载元素」分别代表的元素下标在原始的\u003Ccode\u003ElistData\u003C\u002Fcode\u003E进行动态截取。\u003C\u002Fp\u003E\n\u003Cp\u003E根据固定的元素高度和「滚动容器」的高度，可以轻松得出「可视元素」的个数为 \u003Cstrong\u003E滚动容器高度\u003C\u002Fstrong\u003E \u002F \u003Cstrong\u003E单个元素高度\u003C\u002Fstrong\u003E，使用\u003Ccode\u003EVISIBLE_COUNT\u003C\u002Fcode\u003E表示。同时，为了在快速滚动的情况下也能获得较为良好的数据现实体验，可以适当设置「缓冲区元素」，使用\u003Ccode\u003EBUFFER_SIZE\u003C\u002Fcode\u003E表示。\u003C\u002Fp\u003E\n\u003Cp\u003E新增\u003Ccode\u003EvisibleData\u003C\u002Fcode\u003E数组，用于「可视元素」的装载。页面初次挂载时，「头挂载元素」\u003Ccode\u003EfirstAttachedItem\u003C\u002Fcode\u003E必定为 0，再根据\u003Ccode\u003EVISIBLE_COUNT\u003C\u002Fcode\u003E和\u003Ccode\u003EBUFFER_SIZE\u003C\u002Fcode\u003E可得「尾挂载元素」\u003Ccode\u003ElastAttachedItem\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F ...\nconst BUFFER_SIZE = 3; \u002F\u002F 「缓冲区元素」个数\nlet VISIBLE_COUNT = 0;\n\nexport default {\n  name: 'height-fixed',\n  data() {\n    return {\n      \u002F\u002F ...\n      visibleData: [],\n      firstAttachedItem: 0, \u002F\u002F 「头挂载元素」\n      lastAttachedItem: 0, \u002F\u002F 「尾挂载元素」\n    };\n  },\n  mounted() {\n    VISIBLE_COUNT = Math.ceil(this.$refs.scroller.offsetHeight \u002F FIXED_HEIGHT);\n    this.lastAttachedItem = VISIBLE_COUNT + BUFFER_SIZE;\n    this.visibleData = this.listData.slice(this.firstAttachedItem, this.lastAttachedItem);\n  },\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E将\u003Ccode\u003ElistData\u003C\u002Fcode\u003E更改为\u003Ccode\u003EvisibleData\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"4\" class=\"language-html\"\u003E\u003Ccode data-line=\"4\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot;&gt;\n    &lt;li class=&quot;height-fixed__scroll-runway&quot; :style=&quot;`transform: translate(0, ${scrollRunwayEnd}px)`&quot;&gt;&lt;\u002Fli&gt;\n    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in visibleData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; \u002F&gt;\n  &lt;\u002Ful&gt;\n&lt;\u002Ftemplate&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E在获得了\u003Ccode\u003EvisibleData\u003C\u002Fcode\u003E后，下一步需要改变列表元素的显示方式。对每个列表元素使用绝对定位，使其脱离文档流，然后使用\u003Ccode\u003Etransform: translateY\u003C\u002Fcode\u003E的方式来对元素进行定位。\u003C\u002Fp\u003E\n\u003Cp\u003E将\u003Ccode\u003EsetItemIndex\u003C\u002Fcode\u003E方法更改为\u003Ccode\u003EcalItemScrollY\u003C\u002Fcode\u003E，并根据下标，赋值给每个元素固定的\u003Ccode\u003EscrollY\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"15\" class=\"language-js\"\u003E\u003Ccode data-line=\"15\" class=\"language-js\"\u003E\u002F\u002F setItemIndex(list) {\n\u002F\u002F   let latestIndex = this.listData.length;\n\u002F\u002F   for (let i = 0; i &lt; list.length; i++) {\n\u002F\u002F     const item = list[i];\n\u002F\u002F     item.index = latestIndex + i;\n\u002F\u002F     Object.freeze(item);\n\u002F\u002F   }\n\u002F\u002F   return list;\n\u002F\u002F }\ncalItemScrollY(list) {\n  let latestIndex = this.listData.length;\n  for (let i = 0; i &lt; list.length; i++) {\n    const item = list[i];\n    item.index = latestIndex + i;\n    item.scrollY = this.scrollRunwayEnd + i * FIXED_HEIGHT;\n    Object.freeze(item);\n  }\n  return list;\n},\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre  data-line=\"9,17\" class=\"language-html\"\u003E\u003Ccode data-line=\"9,17\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;!-- ... --&gt;\n  &lt;item\n    class=&quot;height-fixed__item&quot;\n    v-for=&quot;item in visibleData&quot;\n    :data=&quot;item&quot;\n    :index=&quot;item.index&quot;\n    :key=&quot;item.username + item.phone&quot;\n    :style=&quot;`transform: translate(0, ${item.scrollY}px)`&quot;\n  \u002F&gt;\n  &lt;!-- ... --&gt;\n&lt;\u002Ftemplate&gt;\n&lt;!-- ... --&gt;\n&lt;style scoped lang=&quot;scss&quot;&gt;\n  .height-fixed {\n    \u002F* ... *\u002F\n    &amp;__item {\n      position: absolute;\n      contain: layout;\n      will-change: transform;\n    }\n  }\n&lt;\u002Fstyle&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"gundonggengxinkeshiyuansugudinggaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gundonggengxinkeshiyuansugudinggaodu')\"\u003E¶\u003C\u002Fa\u003E 滚动更新「可视元素」|固定高度\u003C\u002Fh3\u003E\n\u003Cp\u003E在处理滚动逻辑之前，先引入一个概念：\u003Cstrong\u003E「锚点元素」\u003C\u002Fstrong\u003E，即处于「滚动容器」的「可视区域」内的\u003Cstrong\u003E第一个元素\u003C\u002Fstrong\u003E。我们需要在滚动时候，根据每一次滚动事件的滚动差值和方向来更新「锚点元素」，计算出「锚点元素」后，就可以根据新的「锚点元素」下标和缓冲区值\u003Ccode\u003EBUFFER_SIZE\u003C\u002Fcode\u003E、\u003Ccode\u003EVISIBLE_COUNT\u003C\u002Fcode\u003E来计算「头挂载元素」和「尾挂载元素」。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E「锚点元素」= 「当前滚动高度」\u002F FIXED_HEIGHT \u002F\u002F 当偏移量绝对值大于 FIXED_HEIGHT 时需要重新计算；\n「头挂载元素」=「锚点元素」- BUFFER_SIZE \u002F\u002F 不能小于 0，即第一个元素；\n「尾挂载元素」= 「头挂载元素」+ VISIBLE_COUNT + BUFFER_SIZE \u002F\u002F 不能大于列表长度，即最后一个元素；\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E「锚点元素」大部分情况下处于被\u003Cstrong\u003E部分遮盖\u003C\u002Fstrong\u003E的状态，被遮盖的部分为它的偏移量\u003Ccode\u003Eoffset\u003C\u002Fcode\u003E，其中包含指向具体元素的下标\u003Ccode\u003Eindex\u003C\u002Fcode\u003E，如下图所示：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-3.9db10a7.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E了解了「锚点元素」概念之后，接下来就可以处理「滚动容器」的滚动行为了，首先监听滚动事件：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"2\" class=\"language-html\"\u003E\u003Ccode data-line=\"2\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;ul ref=&quot;scroller&quot; class=&quot;height-fixed&quot; @scroll=&quot;handleScroll&quot;&gt;\n    &lt;!-- ... --&gt;\n  &lt;\u002Ful&gt;\n&lt;\u002Ftemplate&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E根据滚动方向和偏移量，按顺序更新「锚点元素」→「头挂载元素」→「尾挂载元素」→「可视元素」：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"52\" class=\"language-js\"\u003E\u003Ccode data-line=\"52\" class=\"language-js\"\u003E\u002F\u002F ...\nexport default {\n  \u002F\u002F ...\n  data() {\n    return {\n      \u002F\u002F ...\n      anchorItem: { index: 0, offset: 0 }, \u002F\u002F 「锚点元素」初始值\n      lastScrollTop: 0, \u002F\u002F 记录上次滚动事件时「滚动容器」的「滚动高度」\n    };\n  },\n  methods: {\n    \u002F\u002F 「锚点元素」更新方法\n    updateAnchorItem() {\n      const index = Math.floor(this.$refs.scroller.scrollTop \u002F FIXED_HEIGHT);\n      const offset = this.$refs.scroller.scrollTop - index * FIXED_HEIGHT;\n      this.anchorItem = { index, offset };\n    },\n    handleScroll() {\n      \u002F\u002F 滚动差值\n      const delta = this.$refs.scroller.scrollTop - this.lastScrollTop;\n      this.lastScrollTop = this.$refs.scroller.scrollTop;\n\n      \u002F\u002F 更新「锚点元素」偏移量\n      this.anchorItem.offset += delta;\n      const isPositive = delta &gt;= 0;\n      \u002F\u002F 判断滚动方向\n      if (isPositive) {\n        \u002F\u002F 1.当「锚点元素」偏移量大于等于固定高度时，说明视图滚动条向下，并超过一个元素，需要更新「锚点元素」\n        if (this.anchorItem.offset &gt;= FIXED_HEIGHT) {\n          this.updateAnchorItem();\n        }\n        \u002F\u002F 2.计算「头挂载元素」\n        if (this.anchorItem.index - this.firstAttachedItem &gt;= BUFFER_SIZE) {\n          this.firstAttachedItem = Math.min(this.listData.length - VISIBLE_COUNT, this.anchorItem.index - BUFFER_SIZE);\n        }\n      } else {\n        if (this.$refs.scroller.scrollTop &lt;= 0) {\n          \u002F\u002F 特殊情况：处理滚动到顶部，更新「锚点元素」为初始值\n          this.anchorItem = { index: 0, offset: 0 };\n        } else if (this.anchorItem.offset &lt; 0) {\n          \u002F\u002F 1.当「锚点元素」偏移量小于零时，说明视图滚动条向上，并超过一个元素，需要更新「锚点元素」\n          this.updateAnchorItem();\n        }\n        \u002F\u002F 2.计算「头挂载元素」\n        if (this.anchorItem.index - this.firstAttachedItem &lt; BUFFER_SIZE) {\n          this.firstAttachedItem = Math.max(0, this.anchorItem.index - BUFFER_SIZE);\n        }\n      }\n      \u002F\u002F 3.更新「尾挂载元素」\n      this.lastAttachedItem = Math.min(this.firstAttachedItem + VISIBLE_COUNT + BUFFER_SIZE * 2, this.listData.length);\n      \u002F\u002F 4.更新「可视元素」\n      this.visibleData = this.listData.slice(this.firstAttachedItem, this.lastAttachedItem);\n    },\n  },\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E至此，一个简单的「固定高度虚拟滚动」就实现了，打开开发者工具，可以观察到就算滚动条一直向下，列表元素的个数是恒定的：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-8.a90bd13.gif\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E你可以点击\u003Ca href=\"https:\u002F\u002Flkangd.github.io\u002Finfinite-scroll-sample\u002F#\u002Fheight-fixed\" target=\"_blank\"\u003E此处\u003C\u002Fa\u003E进行体验。\u003C\u002Fp\u003E\n\u003Ch2 id=\"dongtaigaodudexuniliebiao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dongtaigaodudexuniliebiao')\"\u003E¶\u003C\u002Fa\u003E 动态高度的虚拟列表\u003C\u002Fh2\u003E\n\u003Cp\u003E因为不再具有固定的元素高度，所以「可滚动高度」和「可视元素」很难像实现固定高度的虚拟列表那样，可以在获取数据后进行一次性计算就完事。下面来说说动态高度虚拟列表的关键难点：\u003C\u002Fp\u003E\n\u003Ch3 id=\"guanjiandianyiruhehuodeyuansudedongtaigaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandianyiruhehuodeyuansudedongtaigaodu')\"\u003E¶\u003C\u002Fa\u003E 关键点一：如何获得元素的动态高度？\u003C\u002Fh3\u003E\n\u003Cp\u003E按常规情况，一个列表元素高度为动态的情况大致分为三种：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E列表元素内初始渲染时高度就不确定。比如\u003Cstrong\u003E不定行数\u003C\u002Fstrong\u003E的多行文本、列表元素内包含\u003Cstrong\u003E不定长度\u003C\u002Fstrong\u003E的内嵌列表等；\u003C\u002Fli\u003E\n\u003Cli\u003E列表元素内初始渲染后因用户操作而高度发生变化。比如展开一个\u003Cstrong\u003E收缩项目\u003C\u002Fstrong\u003E、\u003Cstrong\u003E删除或增加\u003C\u002Fstrong\u003E子元素等；\u003C\u002Fli\u003E\n\u003Cli\u003E列表元素内包含异步渲染元素。比如未缓存过的\u003Cstrong\u003E图片\u003C\u002Fstrong\u003E、\u003Cstrong\u003E异步组件\u003C\u002Fstrong\u003E等。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E由于这些复杂的情况可能同时存在一个列表元素内，所以只能够实时监听每一个\u003Cstrong\u003E处于可视区域\u003C\u002Fstrong\u003E内的元素的高度。现阶段 ECMA DOM 规范下，有两个 API 可以达到这个目的：\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FAPI\u002FMutationObserver\" target=\"_blank\"\u003EMutationObserver\u003C\u002Fa\u003E和 \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FAPI\u002FResizeObserver\" target=\"_blank\"\u003EResizeObserver\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E这两个 API 都存在一定的兼容性问题，\u003Ca href=\"https:\u002F\u002Fcaniuse.com\u002F#feat=resizeobserver\" target=\"_blank\"\u003Ecaniuse#ResizeObserver\u003C\u002Fa\u003E | \u003Ca href=\"https:\u002F\u002Fcaniuse.com\u002F#search=MutationObserver\" target=\"_blank\"\u003Ecaniuse#MutationObserver\u003C\u002Fa\u003E，可以使用对应的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E进行解决，因为\u003Ccode\u003EResizeObserver\u003C\u002Fcode\u003E可以更直观地达到监听元素高度变动的目的，所以这里选择使用\u003Ccode\u003EResizeObserver\u003C\u002Fcode\u003E。\u003Ccode\u003EResizeObserver\u003C\u002Fcode\u003E的 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fque-etc\u002Fresize-observer-polyfill\" target=\"_blank\"\u003Epolyfill\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Ch3 id=\"guanjiandianerruhemonikegundonggaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandianerruhemonikegundonggaodu')\"\u003E¶\u003C\u002Fa\u003E 关键点二：如何模拟「可滚动高度」？\u003C\u002Fh3\u003E\n\u003Cp\u003E因为列表元素的高度不再是固定的，所以「可滚动高度」不能再通过「列表元素个数」*「固定元素高度」简单逻辑关系来获得。此时，只能基于业务的实际情况，给每个列表元素定一个「估算高度」：\u003Ccode\u003EESTIMATED_HEIGHT\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E同时，还需要新增一个\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E数组，根据上一关键点提到的元素高度变化事件，以每一个列表元素对应的下标记录最后一次变化的高度。如果元素未渲染或者被略过渲染时，用\u003Ccode\u003EESTIMATED_HEIGHT\u003C\u002Fcode\u003E进行暂时代替。\u003C\u002Fp\u003E\n\u003Cp\u003E由此可得知，「可滚动高度」\u003Ccode\u003EscrollRunwayEnd\u003C\u002Fcode\u003E只能是「动态」且「大致准确」的。在 vue 里，可以用一个「计算属性」进行实时估值：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E  \u002F\u002F ...\n  data() {\n    return {\n      \u002F\u002F ...\n      \u002F\u002F scrollRunwayEnd: 0,\n    };\n  },\n  computed: {\n    scrollRunwayEnd() {\n      \u002F\u002F 根据当前已渲染的元素高度，求得当前所有元素总高度\n      const maxScrollY = this.cachedHeight.reduce((sum, h) =&gt; (sum += h || ESTIMATED_HEIGHT), 0);\n      \u002F\u002F 根据当前所有元素总高度，求得元素平均高度\n      const currentAverageH = maxScrollY \u002F this.cachedHeight.length;\n      \u002F\u002F 返回估算高度\n      return maxScrollY + (this.listData.length - this.cachedHeight.length) * currentAverageH;\n    },\n  },\n  \u002F\u002F ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"guanjiandiansanruhejisuanmeiyigeyuansudescrollY\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandiansanruhejisuanmeiyigeyuansudescrollY')\"\u003E¶\u003C\u002Fa\u003E 关键点三：如何计算每一个元素的「scrollY」？\u003C\u002Fh3\u003E\n\u003Cp\u003E这一步是最难的，因为除了第一个元素外的每一个元素的「scrollY」可能都会因为下面几种情况而失效：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cstrong\u003E当前元素的上一个元素高度发生了变化。\u003C\u002Fstrong\u003E 这种情况意味着从\u003Cstrong\u003E当前元素\u003C\u002Fstrong\u003E开始，每一个后续元素都需要按\u003Cstrong\u003E上一个元素\u003C\u002Fstrong\u003E的高度差值进行「scrollY」计算。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E用户快速拖动滚动条至底部或顶部。\u003C\u002Fstrong\u003E 由于略过了中间元素的渲染，\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E会缺少略过元素的真实高度，所以只能用上文的\u003Ccode\u003EESTIMATED_HEIGHT\u003C\u002Fcode\u003E进行代替。这种情况下用户再缓慢滚动到顶部时，略过元素的初次渲染会更新\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E中对应的记录。此时更新的高度肯定是大于或者小于\u003Ccode\u003EESTIMATED_HEIGHT\u003C\u002Fcode\u003E的，所以当用户持续滚动缓慢滚动到\u003Ccode\u003EscrollTop\u003C\u002Fcode\u003E为 0 时，可能会出现 \u003Cstrong\u003E\u003Cem\u003E上部滚动区域\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E「不足」或者「多余」的情况。因此，必须在\u003Cstrong\u003E保证当前页面滚动情况不变\u003C\u002Fstrong\u003E的前提下，提前对这两种情况进行实时修正，也即修正\u003Ccode\u003EscrollTop\u003C\u002Fcode\u003E的同时重新计算「锚点元素」。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E屏幕宽度发生改变。\u003C\u002Fstrong\u003E 手机屏幕横竖方向改变和手动改变浏览器窗口大小都可能导致「滚动容器」的宽度发生变化，「滚动容器」的宽度决定了列表元素的高度，这种情况下每一个元素的「scrollY」都将失效，需要重新计算。同时，为了更好地的用户体验，我们应该在宽度发生变化时，保持「锚定元素」的\u003Ccode\u003Eoffset\u003C\u002Fcode\u003E不变，举一个 twitter 例子：\u003Cbr\u003E\n\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-4.194b7ea.gif\" alt=\"\"\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E因此，这里我们不再将「scrollY」直接赋予每一个列表元素，而是新增一个\u003Ccode\u003EcachedScrollY\u003C\u002Fcode\u003E数组用于存储所有列表元素的临时「scrollY」。在每一次滚动事件发生时，根据滚动差值是否超过「锚点元素」对应的\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E去判断是否需要更新「锚点元素」。如果「锚点元素」发生改变，以「锚点元素」为基点，用每一个「可视元素」对应的\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E叠加「锚点元素」的「scrollY」去计算自身的「scrollY」，然后更新每个列表元素对应\u003Ccode\u003EcachedScrollY\u003C\u002Fcode\u003E，最后渲染到「可视区域」。\u003C\u002Fp\u003E\n\u003Ch3 id=\"zhunbeigongzuodongtaigaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhunbeigongzuodongtaigaodu')\"\u003E¶\u003C\u002Fa\u003E 准备工作|动态高度\u003C\u002Fh3\u003E\n\u003Cp\u003E修改随机数据函数，给每个元素增加\u003Cstrong\u003E随机图片\u003C\u002Fstrong\u003E和该图片的\u003Cstrong\u003E随机宽度\u003C\u002Fstrong\u003E：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"7,8\" class=\"language-js\"\u003E\u003Ccode data-line=\"7,8\" class=\"language-js\"\u003Eexport function fetchData(count = 30) {\n  const result = [];\n  for (let i = 0; i &lt; count; i++) {\n    const item = faker.helpers.contextualCard();\n    item.paragraph = faker.lorem.paragraph();\n    item.img = {\n      src: `\u002Fimages\u002F${faker.random.number({ min: 1, max: 20 })}.jpeg`, \u002F\u002F 从给定的 20 张图片内随机\n      width: `${faker.random.number({ min: 100, max: 700 })}px`, \u002F\u002F 从 100px - 700px 范围内随机\n    };\n    result.push(item);\n  }\n  return result;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E修改\u003Ccode\u003Eitem\u003C\u002Fcode\u003E组件，注意加载的两张图片：一张为正常加载的图片，一张为\u003Cstrong\u003E人工延时\u003C\u002Fstrong\u003E加载的图片：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"8-14\" class=\"language-html\"\u003E\u003Ccode data-line=\"8-14\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;li class=&quot;item&quot; ref=&quot;item&quot;&gt;\n    &lt;div class=&quot;item__wrapper&quot; :class=&quot;{ 'is-fixed': fixedHeight }&quot;&gt;\n      &lt;!-- ... --&gt;\n      &lt;template v-if=&quot;fixedHeight&quot;&gt;\n        &lt;!-- ... --&gt;\n      &lt;\u002Ftemplate&gt;\n      &lt;template v-else&gt;\n        &lt;p class=&quot;item__paragraph&quot;&gt;{{ data.paragraph }}&lt;\u002Fp&gt;\n        &lt;!-- 模拟延时加载图片 --&gt;\n        &lt;img class=&quot;item__img&quot; :src=&quot;defferImgSrc&quot; :style=&quot;{width: data.img.width}&quot; \u002F&gt;\n        &lt;!-- 正常加载图片 --&gt;\n        &lt;img class=&quot;item__img&quot; :src=&quot;data.img.src&quot; :style=&quot;{width: data.img.width}&quot; \u002F&gt;\n      &lt;\u002Ftemplate&gt;\n    &lt;\u002Fdiv&gt;\n  &lt;\u002Fli&gt;\n&lt;\u002Ftemplate&gt;\n&lt;script&gt;\n  \u002F\u002F ...\n  export default {\n    \u002F\u002F ...\n    props: {\n      \u002F\u002F ...\n      fixedHeight: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    data() {\n      return {\n        defferImgSrc: '',\n      };\n    },\n    created() {\n      \u002F\u002F 模拟图片加载时间\n      if (this.data.img.isDeffer) {\n        this.defferImgSrc = this.data.img.src;\n      } else {\n        setTimeout(() =&gt; {\n          this.defferImgSrc = this.data.img.src;\n          this.data.img.isDeffer = true;\n        }, faker.random.number({ min: 300, max: 5000 }));\n      }\n    },\n  };\n&lt;\u002Fscript&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E最后，在\u003Ccode\u003Emounted\u003C\u002Fcode\u003E钩子内使用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fque-etc\u002Fresize-observer-polyfill\" target=\"_blank\"\u003Eresize-observer-polyfill\u003C\u002Fa\u003E 监听元素高度变化：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"10\" class=\"language-js\"\u003E\u003Ccode data-line=\"10\" class=\"language-js\"\u003Eimport ResizeObserver from 'resize-observer-polyfill';\n\nexport default {\n  \u002F\u002F ...\n  mounted() {\n    if (this.fixedHeight) return;\n\n    const ro = new ResizeObserver((entries, observer) =&gt; {\n      \u002F\u002F 高度发生变化时，将 'size-change' 事件 emit 到父组件\n      this.$emit('size-change', this.index);\n    });\n    ro.observe(this.$refs.item);\n    this.$once('hook:beforeDestroy', ro.disconnect.bind(ro));\n  },\n  \u002F\u002F ...\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E通过路由挂载后，完成一个动态高度元素列表的渲染，如下图：\u003Cbr\u003E\n\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-2.42bae0b.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"jiantingyuansugaodubianhua\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiantingyuansugaodubianhua')\"\u003E¶\u003C\u002Fa\u003E 监听元素高度变化\u003C\u002Fh3\u003E\n\u003Cp\u003E在每一次「可视元素」的高度发生变化时，以「锚点元素」为基点，计算出「锚点元素」的\u003Ccode\u003EscrollY\u003C\u002Fcode\u003E，然后按「锚点元素」之前和之后的元素进行区别计算，得出所有「可视元素」的最新\u003Ccode\u003EscrollY\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003E注意：列表元素的初次渲染和后续的高度变化都会触发\u003Ccode\u003EResizeObserver\u003C\u002Fcode\u003E事件\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"13\" class=\"language-html\"\u003E\u003Ccode data-line=\"13\" class=\"language-html\"\u003E&lt;template&gt;\n  &lt;ul ref=&quot;scroller&quot; class=&quot;height-dynamic&quot; @scroll=&quot;handleScroll&quot;&gt;\n    &lt;!-- ... --&gt;\n    &lt;item\n      class=&quot;height-dynamic__item&quot;\n      v-for=&quot;item in visibleData&quot;\n      ref=&quot;items&quot;\n      :data=&quot;item&quot;\n      :fixed-height=&quot;false&quot;\n      :key=&quot;item.username + item.phone&quot;\n      :index=&quot;item.index&quot;\n      :style=&quot;`transform: translate(0, ${cachedScrollY[item.index]}px)`&quot;\n      @size-change=&quot;handleSizeChange&quot;\n    \u002F&gt;\n  &lt;\u002Ful&gt;\n&lt;\u002Ftemplate&gt;\n&lt;script&gt;\n  export default {\n    \u002F\u002F ...\n    methods: {\n      handleSizeChange(index) {\n        this.calItemScrollY();\n      },\n      \u002F\u002F 计算每一个「可视元素」的 scrollY\n      async calItemScrollY() {\n        await this.$nextTick();\n        \u002F\u002F 修正 vue diff 算法导致「可视元素」顺序不正确的问题\n        this.$refs.items.sort((a, b) =&gt; a.index - b.index);\n\n        \u002F\u002F 获取「锚点元素」在「可视元素」中的序号\n        const anchorDomIndex = this.$refs.items.findIndex(item =&gt; item.index === this.anchorItem.index);\n        const anchorDom = this.$refs.items[anchorDomIndex];\n        const anchorDomHeight = anchorDom.$el.getBoundingClientRect().height;\n\n        \u002F\u002F 通过「滚动容器」的「当前滚动高度」和「锚点元素」的 offset 算出其 scrollY\n        this.$set(this.cachedScrollY, this.anchorItem.index, this.$refs.scroller.scrollTop - this.anchorItem.offset);\n        this.$set(this.cachedHeight, this.anchorItem.index, anchorDomHeight);\n\n        \u002F\u002F 计算 anchorItem 后面的列表元素 scrollY\n        for (let i = anchorDomIndex + 1; i &lt; this.$refs.items.length; i++) {\n          const item = this.$refs.items[i];\n          const { height } = item.$el.getBoundingClientRect();\n          this.$set(this.cachedHeight, item.index, height);\n          \u002F\u002F 当前元素的 scrollY 是上一个元素的 scrollY + 上一个元素的高度\n          const scrollY = this.cachedScrollY[item.index - 1] + this.cachedHeight[item.index - 1];\n          this.$set(this.cachedScrollY, item.index, scrollY);\n        }\n        \u002F\u002F 计算 anchorItem 前面的列表元素 scrollY\n        for (let i = anchorDomIndex - 1; i &gt;= 0; i--) {\n          const item = this.$refs.items[i];\n          const { height } = item.$el.getBoundingClientRect();\n          this.$set(this.cachedHeight, item.index, height);\n          \u002F\u002F 当前元素的 scrollY 是下一个元素的 scrollY - 当前元素的高度\n          const scrollY = this.cachedScrollY[item.index + 1] - this.cachedHeight[item.index];\n          this.$set(this.cachedScrollY, item.index, scrollY);\n        }\n      },\n      \u002F\u002F ...\n    },\n    \u002F\u002F ...\n  };\n&lt;\u002Fscript&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"gundonggengxinkeshiyuansudongtaigaodu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gundonggengxinkeshiyuansudongtaigaodu')\"\u003E¶\u003C\u002Fa\u003E 滚动更新「可视元素」|动态高度\u003C\u002Fh3\u003E\n\u003Cp\u003E「可滚动高度」的计算已经在上面提过，而初始「可视元素」和固定高度的虚拟列表的计算是类似的，所以这里跳过这两点，只描述如何处理滚动更新「可视元素」。\u003C\u002Fp\u003E\n\u003Cp\u003E根据滚动方向和偏移量，按顺序更新「锚点元素」→「头挂载元素」→「尾挂载元素」→「可视元素」：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F ...\nexport default {\n  \u002F\u002F ...\n  methods: {\n    \u002F\u002F ...\n    handleScroll() {\n      const delta = this.$refs.scroller.scrollTop - this.lastScrollTop;\n      this.lastScrollTop = this.$refs.scroller.scrollTop;\n      \u002F\u002F 1.更新「锚点元素」\n      this.updateAnchorItem(delta);\n      \u002F\u002F 更新「头挂载元素」→「尾挂载元素」→「可视元素」\n      this.updateVisibleData();\n    },\n    async updateAnchorItem(delta) {\n      const lastIndex = this.anchorItem.index;\n      const lastOffset = this.anchorItem.offset;\n      delta += lastOffset;\n\n      let index = lastIndex;\n      const isPositive = delta &gt;= 0;\n      \u002F\u002F 判断滚动方向\n      if (isPositive) {\n        \u002F\u002F 用 delta 一直减去从「锚点元素」开始向下方向的「可视元素」高度，每减一次 index 前进一位\n        while (index &lt; this.listData.length &amp;&amp; delta &gt; (this.cachedHeight[index] || ESTIMATED_HEIGHT)) {\n          \u002F\u002F 当 this.cachedHeight[index] 不存在时，说明可能被快速拖动滚动条而略过渲染，此时需要填充估计高度\n          if (!this.cachedHeight[index]) {\n            this.$set(this.cachedHeight, index, ESTIMATED_HEIGHT);\n          }\n          delta -= this.cachedHeight[index];\n          index++;\n        }\n        if (index &gt;= this.listData.length) {\n          this.anchorItem = { index: this.listData.length - 1, offset: 0 };\n        } else {\n          this.anchorItem = { index, offset: delta };\n        }\n      } else {\n        \u002F\u002F 用 delta 一直叠加从「锚点元素」开始向上方向的「可视元素」高度，每加一次 index 后退一位\n        while (delta &lt; 0) {\n          \u002F\u002F 当 this.cachedHeight[index] 不存在时，说明可能被快速拖动滚动条而略过渲染，此时需要填充估计高度\n          if (!this.cachedHeight[index - 1]) {\n            this.$set(this.cachedHeight, index - 1, ESTIMATED_HEIGHT);\n          }\n          delta += this.cachedHeight[index - 1];\n          index--;\n        }\n        if (index &lt; 0) {\n          this.anchorItem = { index: 0, offset: 0 };\n        } else {\n          this.anchorItem = { index, offset: delta };\n        }\n      }\n    },\n    updateVisibleData() {\n      \u002F\u002F 2.更新「头挂载元素」，注意不能小于 0\n      const start = (this.firstAttachedItem = Math.max(0, this.anchorItem.index - BUFFER_SIZE));\n      \u002F\u002F 3.更新「尾挂载元素」\n      this.lastAttachedItem = this.firstAttachedItem + VISIBLE_COUNT + BUFFER_SIZE * 2;\n      const end = Math.min(this.lastAttachedItem, this.listData.length);\n      \u002F\u002F 4.更新「可视元素」\n      this.visibleData = this.listData.slice(start, end);\n    },\n    \u002F\u002F ...\n  },\n  \u002F\u002F ...\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"xiuzhenggundongtiao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiuzhenggundongtiao')\"\u003E¶\u003C\u002Fa\u003E 修正滚动条\u003C\u002Fh3\u003E\n\u003Cp\u003E到这一步，这个「动态高度虚拟列表」已经大致可用了，但是还有一个问题，就是当用户快速拖动滚动条，因为「滚动差值」很大，所以会略过中间元素的渲染，此时这些略过的元素在\u003Ccode\u003EcachedHeight\u003C\u002Fcode\u003E中用\u003Ccode\u003EESTIMATED_HEIGHT\u003C\u002Fcode\u003E进行存储，因此会出现两种情况：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cstrong\u003E估算的「可滚动高度」小于实际的「可滚动高度」\u003C\u002Fstrong\u003E。比如略过了中间 20 个元素，这些略过元素的估算高度总值为 ESTIMATED_HEIGHT(180) * 20 = 3600，而假设实际元素真正渲染时的平均高度为 300，即略过元素的实际高度总值为 300 * 20 = 6000。可以得知差值为 3600 - 6000 = -2400，滚动到顶部时，无法滚动到第一个元素。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E估算的「可滚动高度」大于实际的「可滚动高度」\u003C\u002Fstrong\u003E。比如略过了中间 20 个元素，这些略过元素的估算高度总值为 ESTIMATED_HEIGHT(180) * 20 = 3600，而假设实际元素真正渲染时的平均高度为 100，即略过元素的实际高度总值为 100 * 20 = 2000。可以得知差值为 3600 - 2000 = 1600，滚动到顶部时会有空白部分。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E考虑在这种情况下，可能会有往回滚动的场景，所以必须在发现「可滚动高度」过小或过大的时候，必须进行及时修正。修改原来的\u003Ccode\u003EhandleScroll\u003C\u002Fcode\u003E、\u003Ccode\u003EupdateAnchorItem\u003C\u002Fcode\u003E和\u003Ccode\u003EcalItemScrollY\u003C\u002Fcode\u003E方法，添加相关逻辑。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eexport default {\n  data() {\n    return {\n      \u002F\u002F ...\n      revising: false,\n    };\n  },\n  \u002F\u002F ...\n  methods: {\n    \u002F\u002F ...\n    handleScroll() {\n      if (this.revising) return; \u002F\u002F 修正滚动条时，屏蔽滚动逻辑\n      \u002F\u002F ...\n    },\n    async updateAnchorItem(delta) {\n      \u002F\u002F ...\n      \u002F\u002F 修正拖动过快导致的滚动到顶端滚动条不足的偏差\n      if (this.cachedScrollY[this.firstAttachedItem] &lt;= -1) {\n        console.log('revising insufficient');\n        this.revising = true;\n        \u002F\u002F 需要的修正的滚动高度为「锚点元素」之前的元素总高度 + 「锚点元素」的 offset\n        const actualScrollTop =\n          this.cachedHeight.slice(0, Math.max(0, this.anchorItem.index)).reduce((sum, h) =&gt; (sum += h), 0) + this.anchorItem.offset;\n        this.$refs.scroller.scrollTop = actualScrollTop;\n        this.lastScrollTop = this.$refs.scroller.scrollTop;\n        if (this.$refs.scroller.scrollTop === 0) {\n          this.anchorItem = { index: 0, offset: 0 };\n        }\n        \u002F\u002F 更改了 lastScrollTop 后，需要重新计算「可视元素」的 scrollY\n        this.calItemScrollY();\n        this.revising = false;\n      }\n    },\n    \u002F\u002F 计算每一个「可视元素」的 scrollY\n    async calItemScrollY() {\n      \u002F\u002F ...\n      \u002F\u002F 修正拖动过快导致的滚动到顶端有空余的偏差\n      if (this.cachedScrollY[0] &gt; 0) {\n        console.log('revising redundant');\n        this.revising = true;\n        \u002F\u002F 第一个列表元素的 cachedScrollY 即为多出的量\n        const delta = this.cachedScrollY[0];\n        const last = Math.min(this.lastAttachedItem, this.listData.length);\n        for (let i = 0; i &lt; last; i++) {\n          this.$set(this.cachedScrollY, i, this.cachedScrollY[i] - delta);\n        }\n        const scrollTop = this.cachedScrollY[this.anchorItem.index - 1]\n          ? this.cachedScrollY[this.anchorItem.index - 1] + this.anchorItem.offset\n          : this.anchorItem.offset;\n        this.$refs.scroller.scrollTop = scrollTop;\n        this.lastScrollTop = this.$refs.scroller.scrollTop;\n        this.revising = false;\n      }\n    },\n    \u002F\u002F ...\n  },\n  \u002F\u002F ...\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E打完收工，「动态高度虚拟列表」实现完成，打开开发者工具，可以观察到就算滚动条一直向下，列表元素的个数都是恒定的，而且无论是快速拖动滚动条还是实时改变窗口宽度，整个列表都能正确地渲染：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-9.8431154.gif\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E你可以点击\u003Ca href=\"https:\u002F\u002Flkangd.github.io\u002Finfinite-scroll-sample\u002F#\u002Fheight-dynamic\" target=\"_blank\"\u003E此处\u003C\u002Fa\u003E进行体验。\u003C\u002Fp\u003E\n\u003Ch2 id=\"zongjie\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zongjie')\"\u003E¶\u003C\u002Fa\u003E 总结\u003C\u002Fh2\u003E\n\u003Cp\u003E本文介绍了前端业务开发中长列表的常规优化手段「虚拟列表」的定义和它在 Vue 环境中的实现，就「固定高度虚拟列表」和「动态高度虚拟列表」两个场景下以一个简单的 demo 详细讲述了虚拟列表的实现思路。\u003C\u002Fp\u003E\n\u003Cp\u003E阅读完本文后可以发现，以本文的思路实现「虚拟列表」的关键在于「锚点元素」的计算和更新，理解了这一点之后就可以发现后续的实现都是按部就班的。\u003C\u002Fp\u003E\n\u003Cp\u003E文字表达可能会有疏漏，建议通过下载本文的\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flkangd\u002Finfinite-scroll-sample\" target=\"_blank\"\u003E代码库\u003C\u002Fa\u003E（基于 Vue 2.x）运行调试，加深理解。\u003C\u002Fp\u003E\n\u003Cp\u003E如果有不正确或难以理解的地方，欢迎通过邮件和留言进行指正讨论。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E重要提示：\u003C\u002Fstrong\u003E 本文所有代码及示例项目只用于探讨虚拟列表的实现原理，请勿直接使用于生产。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch4 id=\"cankao\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cankao')\"\u003E¶\u003C\u002Fa\u003E 参考\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Fupdates\u002F2016\u002F07\u002Finfinite-scroller#scroll_anchoring\" target=\"_blank\"\u003EComplexities of an Infinite Scroller\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fitsze.ro\u002Fblog\u002F2017\u002F04\u002F09\u002Finfinite-list-and-react.html\" target=\"_blank\"\u003EInfinite List and React\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdwqs\u002Fblog\u002Fissues\u002F70\" target=\"_blank\"\u003E浅说虚拟列表的实现原理\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",bodyBegin:8,frontmatter:"title: 剖析无限滚动虚拟列表的实现原理\ndate: '2020-08-26'\nspoiler: 长列表渲染的终极优化手段\nfeatured: true",link:a,next:{title:"SCSS 环境下的 BEM 优雅实践",date:"2020-04-12",spoiler:"如何优雅地编写易维护和具语义化的样式代码？",link:"\u002Fpost\u002Fwrite-bem-with-scss\u002F",min2read:b,wordcount:"3k"},prev:{title:"控制前端业务重复请求的一个新思路",date:"2020-09-13",spoiler:"少一个请求，少一分负担",link:"\u002Fpost\u002Fprevent-duplicate-requests\u002F",min2read:b,wordcount:"3.3k"}}}],fetch:[],mutations:void 0}}("\u002Fpost\u002Fvirtual-infinite-scroll\u002F","☕️☕️☕️ 13 min read")));