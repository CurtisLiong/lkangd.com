__NUXT_JSONP__("/post/js-solid-principle", (function(a,b){return {data:[{post:{attributes:{title:"代码整洁之道：JS 中的 S.O.L.I.D 原则",date:"2019-11-11",spoiler:"【译】Clean Code concepts adapted for JavaScript：S.O.L.I.D",link:a,min2read:"☕️☕️ 11 min read",wordcount:"2.5k"},body:"\u003Cp\u003E\u003Cdiv class=\"cs-toc-dom\"\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#danyizhizeyuanzeSingleResponsibilityPrincipleSRP\"\u003E单一职责原则 | Single Responsibility Principle (SRP)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#kaifangfengbiyuanzeOpenClosedPrincipleOCP\"\u003E开放封闭原则 | Open\u002FClosed Principle (OCP)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#lishitihuanyuanzeLiskovSubstitutionPrincipleLSP\"\u003E里氏替换原则 | Liskov Substitution Principle (LSP)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jiekoufenliyuanzeInterfaceSegregationPrincipleISP\"\u003E接口分离原则 | Interface Segregation Principle (ISP)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#yilaifanzhuanyuanzeDependencyInversionPrincipleDIP\"\u003E依赖翻转原则 | Dependency Inversion Principle (DIP)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fbook.douban.com\u002Fsubject\u002F4199741\u002F\" target=\"_blank\"\u003E《代码整洁之道》\u003C\u002Fa\u003E是一本致力于教人写出简洁、易维护且高质量代码的书籍，该书给出了一系列行之有效的整洁代码操作实践，阅读过后令人受益匪浅。Github 上的\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fryanmcdermott\u002Fclean-code-javascript\" target=\"_blank\"\u003Eclean-code-javascript\u003C\u002Fa\u003E是一个用 JavaScript 去诠释「Clean Code」理念的项目，该项目以 Bad \u002F Good 为正、反两面的范例，并辅以一些叙述和注释作为说明，以增强阅读者对「Clean Code」理念的理解。下文主要翻译其中提出的最常用的 S.O.L.I.D 原则。\u003C\u002Fp\u003E\n\u003Ch2 id=\"danyizhizeyuanzeSingleResponsibilityPrincipleSRP\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'danyizhizeyuanzeSingleResponsibilityPrincipleSRP')\"\u003E¶\u003C\u002Fa\u003E 单一职责原则 | Single Responsibility Principle (SRP)\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EAs stated in Clean Code, &quot;There should never be more than one reason for a class to change&quot;. It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important. It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E就如《代码整洁之道》中所提到的，“引起一个类发生变化的原因不应该多于一个”。的确，在一个类中塞入很多的功能很诱人，就像你只能携带一个旅行箱赶航班一样。但是问题在于，这些臃肿的类不再是概念上内聚的，在未来可能会因为很多理由而需要去修改它。尽量减少修改一个类的次数是非常重要的，因为如果一个类包含了太多功能，当你去修改这个类的某一部分时，将会很难理解这些新的修改如何影响代码库中其他的依赖模块。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E译者按：这里的类替换成函数理解也是一样的\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch4 id=\"Bad\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad')\"\u003E¶\u003C\u002Fa\u003E Bad:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass UserSettings {\n  constructor(user) {\n    this.user = user;\n  }\n\n  changeSettings(settings) {\n    if (this.verifyCredentials()) {\n      \u002F\u002F ...\n    }\n  }\n\n  verifyCredentials() {\n    \u002F\u002F ...\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4 id=\"Good\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good')\"\u003E¶\u003C\u002Fa\u003E Good:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass UserAuth {\n  constructor(user) {\n    this.user = user;\n  }\n\n  verifyCredentials() {\n    \u002F\u002F ...\n  }\n}\n\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n    this.auth = new UserAuth(user);\n  }\n\n  changeSettings(settings) {\n    if (this.auth.verifyCredentials()) {\n      \u002F\u002F ...\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"kaifangfengbiyuanzeOpenClosedPrincipleOCP\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'kaifangfengbiyuanzeOpenClosedPrincipleOCP')\"\u003E¶\u003C\u002Fa\u003E 开放封闭原则 | Open\u002FClosed Principle (OCP)\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EAs stated by Bertrand Meyer, &quot;software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.&quot; What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EBertrand Meyer 也曾经说过，“软件实体（类、模块、函数等）应该对可扩展性进行开放，而对可修改性进行封闭。”那是什么意思呢？这个原则基本上是说你应该允许用户在\u003Cstrong\u003E不更改现有代码\u003C\u002Fstrong\u003E的情况下添加新的功能。\u003C\u002Fp\u003E\n\u003Ch4 id=\"Bad-2\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-2')\"\u003E¶\u003C\u002Fa\u003E Bad:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    if (this.adapter.name === 'ajaxAdapter') {\n      return makeAjaxCall(url).then(response =&gt; {\n        \u002F\u002F 处理响应结果并返回\n      });\n    } else if (this.adapter.name === 'nodeAdapter') {\n      return makeHttpCall(url).then(response =&gt; {\n        \u002F\u002F 处理响应结果并返回\n      });\n    }\n  }\n}\n\nfunction makeAjaxCall(url) {\n  \u002F\u002F 请求并返回 promise\n}\n\nfunction makeHttpCall(url) {\n  \u002F\u002F 请求并返回 promise\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4 id=\"Good-2\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-2')\"\u003E¶\u003C\u002Fa\u003E Good:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n\n  request(url) {\n    \u002F\u002F 请求并返回 promise\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n\n  request(url) {\n    \u002F\u002F 请求并返回 promise\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    return this.adapter.request(url).then(response =&gt; {\n      \u002F\u002F 处理响应结果并返回\n    });\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"lishitihuanyuanzeLiskovSubstitutionPrincipleLSP\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'lishitihuanyuanzeLiskovSubstitutionPrincipleLSP')\"\u003E¶\u003C\u002Fa\u003E 里氏替换原则 | Liskov Substitution Principle (LSP)\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EThis is a scary term for a very simple concept. It's formally defined as &quot;If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).&quot; That's an even scarier definition.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这个术语（里氏替换）听起来很“可怕”，但是其实概念很简单。它的正式定义是：“如果 S 是 T 的子类型，那么类型 T 应该可以被类型 S 的对象所替换（例如，类型 S 的对象可以替换为类型 T 的对象）”，且不会改变该程序原来的任何预期（正确性、执行的任务等）。...这听起来令人更加“害怕”。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EThe best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the &quot;is-a&quot; relationship via inheritance, you quickly get into trouble.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E对这个原则最好的解释是，如果你有一个父类和一个子类，这对父子类可以互相替换使用而不会得到不正确的结果。这听起来可能还是比较令人难以理解，所以我们来看一个经典的\u003Ccode\u003ESquare-Rectangle\u003C\u002Fcode\u003E例子。从算术语言的角度而言，一个\u003Cstrong\u003E正方形\u003C\u002Fstrong\u003E同时也是一个\u003Cstrong\u003E矩形\u003C\u002Fstrong\u003E，但如果你通过继承使用“is-a”关系为它建模，你很快就会遇到麻烦。\u003C\u002Fp\u003E\n\u003Ch4 id=\"Bad-3\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-3')\"\u003E¶\u003C\u002Fa\u003E Bad:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Rectangle {\n  constructor() {\n    this.width = 0;\n    this.height = 0;\n  }\n\n  setColor(color) {\n    \u002F\u002F ...\n  }\n\n  render(area) {\n    \u002F\u002F ...\n  }\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width) {\n    this.width = width;\n    this.height = width;\n  }\n\n  setHeight(height) {\n    this.width = height;\n    this.height = height;\n  }\n}\n\nfunction renderLargeRectangles(rectangles) {\n  rectangles.forEach(rectangle =&gt; {\n    rectangle.setWidth(4);\n    rectangle.setHeight(5);\n    const area = rectangle.getArea(); \u002F\u002F BAD: 预期的正方形面积应该为 20，但是却返回了 25\n    rectangle.render(area);\n  });\n}\n\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\nrenderLargeRectangles(rectangles);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4 id=\"Good-3\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-3')\"\u003E¶\u003C\u002Fa\u003E Good:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass Shape {\n  setColor(color) {\n    \u002F\u002F ...\n  }\n\n  render(area) {\n    \u002F\u002F ...\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length * this.length;\n  }\n}\n\nfunction renderLargeShapes(shapes) {\n  shapes.forEach(shape =&gt; {\n    const area = shape.getArea();\n    shape.render(area);\n  });\n}\n\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\nrenderLargeShapes(shapes);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"jiekoufenliyuanzeInterfaceSegregationPrincipleISP\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiekoufenliyuanzeInterfaceSegregationPrincipleISP')\"\u003E¶\u003C\u002Fa\u003E 接口分离原则 | Interface Segregation Principle (ISP)\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EJavaScript doesn't have interfaces so this principle doesn't apply as strictly as others. However, it's important and relevant even with JavaScript's lack of type system.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EJavaScript 语言里没有“接口”类型的概念，所以这个原则不像其它原则那样严格适用。然而，即使 JavaScript 缺乏类型系统，遵循接口分离原则还是很重要的。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EISP states that &quot;Clients should not be forced to depend upon interfaces that they do not use.&quot; Interfaces are implicit contracts in JavaScript because of duck typing.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EISP 声明“客户端不应该被迫依赖于它们不使用的接口”。而且 JavaScript 具有“鸭子类型”的特性，因此接口在 JavaScript 中属于一种隐性约定。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EA good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a &quot;fat interface&quot;.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E在 JavaScript 中验证这一原则的一个很好的例子就是那些需要大量配置对象的类。不要求客户端配置大量选项是有益的，因为大多数时候它们不需要所有的设置项。让设置项保持\u003Cstrong\u003E可选\u003C\u002Fstrong\u003E可以有助防止“臃肿接口”的出现。\u003C\u002Fp\u003E\n\u003Ch4 id=\"Bad-4\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-4')\"\u003E¶\u003C\u002Fa\u003E Bad:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.settings.animationModule.setup();\n  }\n\n  traverse() {\n    \u002F\u002F ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  animationModule() {}, \u002F\u002F 大多数情况下，我们在遍历的时候并不需要动画\n  \u002F\u002F ...\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4 id=\"Good-4\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-4')\"\u003E¶\u003C\u002Fa\u003E Good:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.options = settings.options;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.setupOptions();\n  }\n\n  setupOptions() {\n    if (this.options.animationModule) {\n      \u002F\u002F ...\n    }\n  }\n\n  traverse() {\n    \u002F\u002F ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  options: {\n    animationModule() {},\n  },\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"yilaifanzhuanyuanzeDependencyInversionPrincipleDIP\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yilaifanzhuanyuanzeDependencyInversionPrincipleDIP')\"\u003E¶\u003C\u002Fa\u003E 依赖翻转原则 | Dependency Inversion Principle (DIP)\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EThis principle states two essential things:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EHigh-level modules should not depend on low-level modules. Both should depend on abstractions.\u003C\u002Fli\u003E\n\u003Cli\u003EAbstractions should not depend upon details. Details should depend on abstractions.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这一原则阐述了两件重要的事情：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E高级模块不应该依赖于低级模块。两者都应该依赖于抽象。\u003C\u002Fli\u003E\n\u003Cli\u003E抽象不应该依赖于具体实现。具体实现应该依赖于抽象。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EThis can be hard to understand at first, but if you've worked with AngularJS, you've seen an implementation of this principle in the form of Dependency Injection (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E最开始可能难以理解，不过如果你曾经使用过 AngularJS，你就已经见识过这一原则的其中一种实现方式，也即“依赖注入”（DI）。虽然它们不是完全相同的概念，但 DIP 阻止了高级模块了解其低级模块的具体实现和设置。这可以通过“依赖注入”（DI）来达成目的。这样做带来的一个显著的好处就是可以减少模块之间的耦合。耦合是一种非常糟糕的开发模式，因为它会使你的代码难以维护。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EAs stated previously, JavaScript doesn't have interfaces so the abstractions that are depended upon are implicit contracts. That is to say, the methods and properties that an object\u002Fclass exposes to another object\u002Fclass. In the example below, the implicit contract is that any Request module for an \u003Ccode\u003EInventoryTracker\u003C\u002Fcode\u003E will have a \u003Ccode\u003ErequestItems\u003C\u002Fcode\u003E method.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E就像上文所说，JavaScript 语言没有“接口”这一概念，所以抽象只能依赖于隐性约定。也就是说，一个对象或类暴露给另一个对象或类的方法和属性。在下面的示例中的隐性约定是，\u003Ccode\u003EInventoryTracker\u003C\u002Fcode\u003E依赖的任一 Request 模块都将有一个\u003Ccode\u003ErequestItems\u003C\u002Fcode\u003E方法。\u003C\u002Fp\u003E\n\u003Ch4 id=\"Bad-5\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-5')\"\u003E¶\u003C\u002Fa\u003E Bad:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass InventoryRequester {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    \u002F\u002F ...\n  }\n}\n\nclass InventoryTracker {\n  constructor(items) {\n    this.items = items;\n\n    \u002F\u002F BAD: 这里产生了一个指定请求类型的依赖\n    \u002F\u002F 正确的做法应该是让 requestItems 去依赖请求方法：`request`\n    this.requester = new InventoryRequester();\n  }\n\n  requestItems() {\n    this.items.forEach(item =&gt; {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas']);\ninventoryTracker.requestItems();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4 id=\"Good-5\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-5')\"\u003E¶\u003C\u002Fa\u003E Good:\u003C\u002Fh4\u003E\n\u003Cpre  class=\"language-js\"\u003E\u003Ccode class=\"language-js\"\u003Eclass InventoryTracker {\n  constructor(items, requester) {\n    this.items = items;\n    this.requester = requester;\n  }\n\n  requestItems() {\n    this.items.forEach(item =&gt; {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nclass InventoryRequesterV1 {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    \u002F\u002F ...\n  }\n}\n\nclass InventoryRequesterV2 {\n  constructor() {\n    this.REQ_METHODS = ['WS'];\n  }\n\n  requestItem(item) {\n    \u002F\u002F ...\n  }\n}\n\n\u002F\u002F 通过在外部完成依赖构建，并注入它们\n\u002F\u002F 我们可以很容易地将请求模块替换为使用 WebSockets 的新请求模块。\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());\ninventoryTracker.requestItems();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fryanmcdermott\u002Fclean-code-javascript#solid\" target=\"_blank\"\u003E原文地址\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",bodyBegin:7,frontmatter:"title: 代码整洁之道：JS 中的 S.O.L.I.D 原则\ndate: '2019-11-11'\nspoiler: 【译】Clean Code concepts adapted for JavaScript：S.O.L.I.D",link:a,next:{title:"Markdown基本语法与扩展语法",date:"2019-07-07",spoiler:"博客文章的编写利器",link:"\u002Fpost\u002Fmarkdown-grammar-sammple\u002F",min2read:b,wordcount:"4.3k"},prev:{title:"何为「Git Commit」最佳姿势？",date:"2020-05-15",spoiler:"让你的每一个「Git Commit」更有价值，而不是形式主义下的流水账",featured:true,link:"\u002Fpost\u002Fdevelop-good-git-commit-habits\u002F",min2read:b,wordcount:"6k"}}}],fetch:[],mutations:void 0}}("\u002Fpost\u002Fjs-solid-principle\u002F","☕️☕️☕️☕️☕️ 26 min read")));