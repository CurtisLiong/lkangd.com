__NUXT_JSONP__("/post/write-bem-with-scss", (function(a){return {data:[{post:{attributes:{title:"SCSS 环境下的 BEM 优雅实践",date:"2020-04-12",spoiler:"如何优雅地编写易维护和具语义化的样式代码？",link:a,min2read:"☕️☕️☕️ 13 min read",wordcount:"3k"},body:"\u003Cp\u003E\u003Cdiv class=\"cs-toc-dom\"\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#shimoshiBEM\"\u003E什么是 BEM？\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#BEMdedingyi\"\u003EBEM 的定义\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#daimashixian\"\u003E代码实现\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#BEMdeyoudian\"\u003EBEM 的优点\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#BEMdequedian\"\u003EBEM 的缺点\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#shimoshiSCSS\"\u003E什么是 SCSS？\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#SCSSdeanzhuangshiyong\"\u003ESCSS 的安装使用\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#SCSSxiadeBEMbianxie\"\u003ESCSS 下的 BEM 编写\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#zuhezengqiang\"\u003E组合增强\u003C\u002Fa\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"#zengqiangyuyihua\"\u003E增强语义化\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#wanzhengdaimashixian\"\u003E完整代码实现\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#shiyongSnippet\"\u003E使用 Snippet\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"#jieyu\"\u003E结语\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"shimoshiBEM\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshiBEM')\"\u003E¶\u003C\u002Fa\u003E 什么是 BEM？\u003C\u002Fh2\u003E\n\u003Cp\u003E「\u003Ca href=\"https:\u002F\u002Fen.bem.info\u002Fmethodology\u002F\" target=\"_blank\"\u003EBEM\u003C\u002Fa\u003E」是一种关于如何编写高可维护性的「CSS」代码的方法论，它提出的概念是将用户界面划分为独立的块，使复杂界面开发变得更加快速和简单。这种方法论背后的想法和现代前端开发的「组件化」理念是高度一致的，如最新的「web components」规范，流行的前端开源框架「Angular」、「React」和「Vue」等。\u003C\u002Fp\u003E\n\u003Ch3 id=\"BEMdedingyi\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdedingyi')\"\u003E¶\u003C\u002Fa\u003E BEM 的定义\u003C\u002Fh3\u003E\n\u003Cp\u003E「BEM」这个词分别由\u003Ccode\u003EBlock\u003C\u002Fcode\u003E、\u003Ccode\u003EElement\u003C\u002Fcode\u003E和\u003Ccode\u003EModifier\u003C\u002Fcode\u003E组成，也即是 \u003Cstrong\u003E\u003Cem\u003E块\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E、\u003Cstrong\u003E\u003Cem\u003E元素\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E 和 \u003Cstrong\u003E\u003Cem\u003E修饰器\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E，如下图所示：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-bem-structure.d8797ba.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E绿色标记的是「Block」，代表有意义的独立实体。蓝色标记的是「Element」，代表属于块的元素部分。红色标记的是「Modifier」，代表用来修改块或元素的标志。\u003C\u002Fp\u003E\n\u003Ch3 id=\"daimashixian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian')\"\u003E¶\u003C\u002Fa\u003E 代码实现\u003C\u002Fh3\u003E\n\u003Cp\u003E上图的「Alert」提示框用代码来实现是这样的：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-html\"\u003E\u003Ccode class=\"language-html\"\u003E&lt;div class=&quot;alert alert--size-medium&quot;&gt;\n  &lt;h1 class=&quot;alert__title&quot;&gt;Alert title&lt;\u002Fh1&gt;\n  &lt;p class=&quot;alert__content&quot;&gt;Here is some alert message.&lt;\u002Fp&gt;\n  &lt;div class=&quot;alert__btn-wrapper&quot;&gt;\n    &lt;button class=&quot;alert__btn alert__btn--highlight&quot;&gt;Cancel&lt;\u002Fbutton&gt;\n    &lt;button class=&quot;alert__btn&quot;&gt;Confirm&lt;\u002Fbutton&gt;\n  &lt;\u002Fdiv&gt;\n&lt;\u002Fdiv&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003ENote\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E:留意这里的 HTML 结构，元素是可以包含元素的，同理「块」也是可以包含「块」的，我们使用「BEM」处理的不是嵌套关系。\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E.alert {\n  \u002F* some code here *\u002F\n}\n.alert--size-medium {\n  \u002F* some code here *\u002F\n}\n.alert__title {\n  \u002F* some code here *\u002F\n}\n.alert__content {\n  \u002F* some code here *\u002F\n}\n.alert__btn-wrapper {\n  \u002F* some code here *\u002F\n}\n.alert__btn {\n  \u002F* some code here *\u002F\n}\n.alert__btn--highlight {\n  \u002F* some code here *\u002F\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"BEMdeyoudian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdeyoudian')\"\u003E¶\u003C\u002Fa\u003E BEM 的优点\u003C\u002Fh3\u003E\n\u003Cp\u003E使用了「BEM」之后，可以看到几个明显的好处：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E模块化：\u003C\u002Fstrong\u003E\u003Cbr\u003E\n块的样式从不依赖于页面上的其他元素，所以永远不会遇到级联问题。而且当遇到需要将模块从已完成的项目转移到新的项目中的时候，「BEM」的结构代码很容易迁移。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E复用性：\u003C\u002Fstrong\u003E\u003Cbr\u003E\n以不同的方式组合独立的块，并根据情况重用它们，可以减少需要维护的 CSS 代码数量。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E结构化：\u003C\u002Fstrong\u003E\u003Cbr\u003E\n「BEM」给 CSS 代码提供了一个坚实的结构，保持简单和容易理解。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Flkangd.com\" target=\"_blank\"\u003E本博客\u003C\u002Fa\u003E的样式就是应用了「BEM」的理念去编写的，而且为了增强独立性，还在 Class 名称前面加了「cs-」的命名空间。\u003C\u002Fp\u003E\n\u003Ch3 id=\"BEMdequedian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdequedian')\"\u003E¶\u003C\u002Fa\u003E BEM 的缺点\u003C\u002Fh3\u003E\n\u003Cp\u003E可以看到使用了「BEM」来编写 CSS 之后，每个 Class 的名字变得很长，所以才会有人吐槽这就像是老太太的裹脚布——又长又臭。这是个容易解决的小问题，现代前端开发已经普遍使用\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FGlossary\u002FCSS_preprocessor\" target=\"_blank\"\u003E「CSS 预处理器」\u003C\u002Fa\u003E来帮助编码工作者更好地书写 CSS，利用这些预处理器的「嵌套」、「父类引用」、「模块」等规则，可以让「BEM」编写量变低，编写速度更快。下面来介绍当前最流行的一种预处理器 ——「SCSS」\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"shimoshiSCSS\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshiSCSS')\"\u003E¶\u003C\u002Fa\u003E 什么是 SCSS？\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fsass-lang.com\u002F\" target=\"_blank\"\u003ESCSS\u003C\u002Fa\u003E 是一个「CSS 预处理器」， 它提供了很多「嵌套」、「父类引用」、「模块」方便快捷的规则来帮助你更加快速地编写 CSS，在你代码正式落地到业务之前转换为真正的 CSS。SCSS 的语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。\u003C\u002Fp\u003E\n\u003Ch3 id=\"SCSSdeanzhuangshiyong\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SCSSdeanzhuangshiyong')\"\u003E¶\u003C\u002Fa\u003E SCSS 的安装使用\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E独立使用\u003C\u002Fstrong\u003E\u003Cbr\u003E\n安装命令：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Enpm install -g sass\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E创建后缀为 index.scss 的文件，编写样式：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E.block {\n  \u002F* some code here *\u002F\n  &amp;--modifier {\n    \u002F* some code here *\u002F\n  }\n  &amp;__element {\n    \u002F* some code here *\u002F\n    &amp;--modifier {\n      \u002F* some code here *\u002F\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E运行转换命令：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Esass source\u002Fstylesheets\u002Findex.scss build\u002Fstylesheets\u002Findex.css\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E转换结果，index.css:\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E.block {\n  \u002F* some code here *\u002F\n}\n.block--modifier {\n  \u002F* some code here *\u002F\n}\n.block__element {\n  \u002F* some code here *\u002F\n}\n.block__element--modifier {\n  \u002F* some code here *\u002F\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003ETip\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E: 你可以到\u003Ca href=\"https:\u002F\u002Fwww.sassmeister.com\u002F\" target=\"_blank\"\u003Esassmeister\u003C\u002Fa\u003E查看 SCSS 实时编译为 CSS 的代码。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E配合打包工具使用\u003C\u002Fstrong\u003E\u003Cbr\u003E\n这里只介绍配合 webpack 使用，安装 sass 和相关 loader 到项目内：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Enpm install css-loader style-loader node-sass sass-loader -D\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E改写 webpack 配置，注意 loader 的顺序，执行打包命令之后就会对使用到的 scss 文件进行转换，转换结果跟上面一样：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"7\" class=\"language-javascript\"\u003E\u003Ccode data-line=\"7\" class=\"language-javascript\"\u003Emodule.exports = {\n  \u002F\u002F 其它配置省略\n  module: {\n    rules: [\n      {\n        test: \u002F\\.scss\u002F,\n        use: ['style-loader', 'css-loader', 'sass-loader'],\n      },\n    ],\n  },\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"SCSSxiadeBEMbianxie\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SCSSxiadeBEMbianxie')\"\u003E¶\u003C\u002Fa\u003E SCSS 下的 BEM 编写\u003C\u002Fh3\u003E\n\u003Cp\u003E使用 SCSS 对上面的「Alert」组件的 CSS 部分进行重写：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E.alert {\n  \u002F* some code here *\u002F\n  &amp;--size-medium {\n    \u002F* some code here *\u002F\n  }\n  &amp;__title {\n    \u002F* some code here *\u002F\n  }\n  &amp;__content {\n    \u002F* some code here *\u002F\n  }\n  &amp;__btn-wrapper {\n    \u002F* some code here *\u002F\n  }\n  &amp;__btn {\n    \u002F* some code here *\u002F\n    &amp;--highlight {\n      \u002F* some code here *\u002F\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E可以看到利用 SCSS 的嵌套和父类名称引用，不再需要重复编写前面相同的部分，节省了大量的编写工作。\u003C\u002Fp\u003E\n\u003Cp\u003E看到这里你可能会疑惑，这跟使用其它 CSS 预处理器没有区别啊，而且看起来还是很长。虽然使用了块、元素和修饰符之间的连接符，能一眼分辨出当前 Class 的种类，但是当需要大量重复编写的话，会让人很也不爽。下面进入正题，看看如何使用 SCSS 的优势来解决这两个问题。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"zuhezengqiang\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zuhezengqiang')\"\u003E¶\u003C\u002Fa\u003E 组合增强\u003C\u002Fh2\u003E\n\u003Cp\u003ESass 在版本 3.3 更新了一个新的@（At-Rules）规则：\u003Ca href=\"https:\u002F\u002Fsass.bootcss.com\u002Fdocumentation\u002Fat-rules\u002Fat-root\" target=\"_blank\"\u003E\u003Ccode\u003E@at-root\u003C\u002Fcode\u003E\u003C\u002Fa\u003E。它的作用是将嵌套内的 CSS 嵌套作用域移至当前 SCSS 文件的根作用域，可以说这个规则真的是为「BEM」而生的，它可以让「BEM」编写起来更语义化、更快捷优雅。\u003C\u002Fp\u003E\n\u003Ch3 id=\"zengqiangyuyihua\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zengqiangyuyihua')\"\u003E¶\u003C\u002Fa\u003E 增强语义化\u003C\u002Fh3\u003E\n\u003Cp\u003E这一步需要借助 SCSS 的\u003Ca href=\"https:\u002F\u002Fsass-lang.com\u002Fdocumentation\u002Fat-rules\u002Fmixin\" target=\"_blank\"\u003E\u003Ccode\u003Emixins\u003C\u002Fcode\u003E\u003C\u002Fa\u003E来给「BEM」三个部分定一个语义化的 mixin，以求一眼就可以看出 class 的种类，而且不用编写连接符，第一个简单版本是这样的：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"11,13\" class=\"language-css\"\u003E\u003Ccode data-line=\"11,13\" class=\"language-css\"\u003E\u002F* 先定义三种 class 的 mixin *\u002F\n$element-separator: '__';\n$modifier-separator: '--';\n\n@mixin block($block) {\n  .#{$block} {\n    @content;\n  }\n}\n@mixin element($element) {\n  \u002F* 这里使用@at-root 将 mixin 的内容体提升至根作用域，使生成的 element 代码其不再嵌套在 block 内 *\u002F\n  @at-root {\n    \u002F* 这里符号 &amp; 拿到父选择器的部分 *\u002F\n    #{&amp; + $element-separator + $element} {\n      @content;\n    }\n  }\n}\n@mixin modifier($modifier) {\n  @at-root {\n    #{&amp; + $modifier-separator + $modifier} {\n      @content;\n    }\n  }\n}\n\n\u002F* 然后这样使用 *\u002F\n@include block(alert) {\n  \u002F* some code here *\u002F\n  @include modifier(size-medium) {\n    \u002F* some code here *\u002F\n  }\n  @include element(title) {\n    \u002F* some code here *\u002F\n  }\n  @include element(content) {\n    \u002F* some code here *\u002F\n  }\n  @include element(btn-wrapper) {\n    \u002F* some code here *\u002F\n  }\n  @include element(btn) {\n    \u002F* some code here *\u002F\n    @include modifier(highlight) {\n      \u002F* some code here *\u002F\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E第一个简单粗暴直接拼接的版本会带来一个问题，就是当 block--modifier 内嵌 block__element 或者 block__element 嵌套 block__element 的时候，得到的代码不会是真正想要的：\u003C\u002Fp\u003E\n\u003Cpre  data-line=\"24,28\" class=\"language-css\"\u003E\u003Ccode data-line=\"24,28\" class=\"language-css\"\u003E\u002F* 比如当设置中型（size-medium） alert 时，title 需要改变 *\u002F\n@include block(alert) {\n  \u002F* some code here *\u002F\n  @include modifier(size-medium) {\n    \u002F* some code here *\u002F\n    @include element(title) {\n      \u002F* some code here *\u002F\n    }\n  }\n  @include element(btn-wrapper) {\n    \u002F* some code here *\u002F\n    @include element(btn) {\n      \u002F* some code here *\u002F\n    }\n  }\n}\n\u002F* 生成的CSS *\u002F\n.alert {\n  \u002F* some code here *\u002F\n}\n.alert--size-medium {\n  \u002F* some code here *\u002F\n}\n\u002F* 这里的期望其实是 .alert--size-medium .alert__title *\u002F\n.alert--size-medium__title {\n  \u002F* some code here *\u002F\n}\n\u002F* 这里的期望其实是 .alert__btn-wrapper .alert__title *\u002F\n.alert__btn-wrapper__btn {\n  \u002F* some code here *\u002F\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E所以这里需要处理的问题有两个：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E判断\u003Ccode\u003EElement\u003C\u002Fcode\u003E的父选择器是不是包含连接符号，也就是“--”或者“__”；\u003C\u002Fli\u003E\n\u003Cli\u003E如果遇到父选择器包含连接符号“--”或者“__”的情况，需要取到父选择器中的「block」部分，也就是「.alert--size-medium」中「.alert」；\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E首先解决第一个问题，实现起来也很简单，用 SCSS 自带的字符串函数\u003Ca href=\"https:\u002F\u002Fsass-lang.com\u002Fdocumentation\u002Fmodules\u002Fstring#index\" target=\"_blank\"\u003Estr-index\u003C\u002Fa\u003E来判断，然后加个流程控制就可以了：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E\u002F* 封装一下判断函数 *\u002F\n@function containsSeparator($selector) {\n  $selector: selectorToString($selector);\n\n  @if str-index($selector, $modifier-separator) or str-index($selector, $element-separator) {\n    @return true;\n  } @else {\n    @return false;\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E然后是第二问题，可以使用 SCSS \u003Ca href=\"https:\u002F\u002Fsass-lang.com\u002Fdocumentation\u002Fvariables#scope\" target=\"_blank\"\u003E全局变量\u003C\u002Fa\u003E来记录 block 的选择器，而不再用使用原来的“&amp;”符号作为「block」的部分：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E\u002F* 先改写block mixin，使其每次被调用时，记录当前的选择器 *\u002F\n@mixin block($block) {\n  $B: $block !global;\n  .#{$block} {\n    @content;\n  }\n}\n\u002F* 然后结合上一步的流程控制，改写 element mixin *\u002F\n@mixin element($element) {\n  $E: $element !global;\n  @if containsSeparator(&amp;) {\n    @at-root {\n      \u002F* 注意这里需要在前面添加“&amp; ”，维持嵌套规则 *\u002F\n      &amp; #{'.' + $B + $element-separator + $element} {\n        @content;\n      }\n    }\n  } @else {\n    @at-root {\n      \u002F* 原来的逻辑不变，这里符号 &amp; 拿到父选择器的部分 *\u002F\n      #{&amp; + $element-separator + $element} {\n        @content;\n      }\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E然后就可以完美地解决两个问题了，无论你嵌套多少层，SCSS 都能输出正确的 CSS。\u003C\u002Fp\u003E\n\u003Ch3 id=\"wanzhengdaimashixian\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'wanzhengdaimashixian')\"\u003E¶\u003C\u002Fa\u003E 完整代码实现\u003C\u002Fh3\u003E\n\u003Cp\u003E其实这里可以再优化一下，将三种类型的 mixin 使用首字母缩写的方式来命名，也即是\u003Ccode\u003Eb\u003C\u002Fcode\u003E，\u003Ccode\u003Ee\u003C\u002Fcode\u003E，\u003Ccode\u003Em\u003C\u002Fcode\u003E。上面还提到需要加命名空间的情况，可以使用\u003Ccode\u003EB\u003C\u002Fcode\u003E来进行区别，完整实现代码如下：\u003C\u002Fp\u003E\n\u003Cpre  class=\"language-css\"\u003E\u003Ccode class=\"language-css\"\u003E$name-space: 'cs-'; \u002F* 根据需要自定义命名空间，比如本博客的“cs-” *\u002F\n$element-separator: '__';\n$modifier-separator: '--';\n\n@function containsSeparator($selector) {\n  $selector: selectorToString($selector);\n\n  @if str-index($selector, $modifier-separator) or str-index($selector, $element-separator) {\n    @return true;\n  } @else {\n    @return false;\n  }\n}\n\n@mixin B($block) {\n  $B: #{$name-space + $block} !global;\n  .#{$B} {\n    @content;\n  }\n}\n\n@mixin b($block) {\n  $B: $block !global;\n  .#{$block} {\n    @content;\n  }\n}\n\n@mixin e($element) {\n  $E: $element !global;\n  @if containsSeparator(&amp;) {\n    @at-root {\n      &amp; #{'.' + $B + $element-separator + $element} {\n        @content;\n      }\n    }\n  } @else {\n    @at-root {\n      #{&amp; + $element-separator + $element} {\n        @content;\n      }\n    }\n  }\n}\n@mixin m($modifier) {\n  @at-root {\n    #{&amp; + $modifier-separator + $modifier} {\n      @content;\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"shiyongSnippet\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shiyongSnippet')\"\u003E¶\u003C\u002Fa\u003E 使用 Snippet\u003C\u002Fh3\u003E\n\u003Cp\u003E最后，需要设置代码编辑器来帮助编写海量的 \u003Ccode\u003E@include [mixin_name] {}\u003C\u002Fcode\u003E 关键字，因为我使用的是 VSCode，所以这里只说 VSCode 的设置方法，其它代码编辑器应该也是类似的。设置步骤如下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E打开 VSCode 首选项，然后选择「用户代码片段」\u003Cbr\u003E\n\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-vscode-snippet.06a5398.png\" alt=\"\"\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E在弹出的输入框内输入「scss.json」\u003Cbr\u003E\n\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-vscode-snippet-2.5e76a69.png\" alt=\"\"\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E输入形如下面的内容\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre  class=\"language-json\"\u003E\u003Ccode class=\"language-json\"\u003E{\n  \u002F\u002F Place your snippets for scss here. Each snippet is defined under a snippet name and has a prefix, body and\n  \u002F\u002F description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\n  \u002F\u002F $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the\n  \u002F\u002F same ids are connected.\n  \u002F\u002F Example:\n  \u002F\u002F &quot;Print to console&quot;: {\n  \u002F\u002F \t&quot;prefix&quot;: &quot;log&quot;,\n  \u002F\u002F \t&quot;body&quot;: [\n  \u002F\u002F \t\t&quot;console.log('$1');&quot;,\n  \u002F\u002F \t\t&quot;$2&quot;\n  \u002F\u002F \t],\n  \u002F\u002F \t&quot;description&quot;: &quot;Log output to console&quot;\n  \u002F\u002F }\n  &quot;Scss BEM B&quot;: {\n    &quot;prefix&quot;: &quot;iB&quot;,\n    &quot;body&quot;: [&quot;@include B($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM b&quot;: {\n    &quot;prefix&quot;: &quot;ib&quot;,\n    &quot;body&quot;: [&quot;@include b($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM e&quot;: {\n    &quot;prefix&quot;: &quot;ie&quot;,\n    &quot;body&quot;: [&quot;@include e($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM m&quot;: {\n    &quot;prefix&quot;: &quot;im&quot;,\n    &quot;body&quot;: [&quot;@include m($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM pseudo&quot;: {\n    &quot;prefix&quot;: &quot;ip&quot;,\n    &quot;body&quot;: [&quot;@include pseudo($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM when&quot;: {\n    &quot;prefix&quot;: &quot;iw&quot;,\n    &quot;body&quot;: [&quot;@include when($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM share rule&quot;: {\n    &quot;prefix&quot;: &quot;isr&quot;,\n    &quot;body&quot;: [&quot;@include share-rule($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]\n  },\n  &quot;Scss BEM extend rule&quot;: {\n    &quot;prefix&quot;: &quot;ier&quot;,\n    &quot;body&quot;: [&quot;@include extend-rule($1);&quot;]\n  },\n  &quot;Scss utils ellipsis&quot;: {\n    &quot;prefix&quot;: &quot;ime&quot;,\n    &quot;body&quot;: [&quot;@include utils-ellipsis;&quot;]\n  },\n  &quot;Scss utils transitions&quot;: {\n    &quot;prefix&quot;: &quot;imt&quot;,\n    &quot;body&quot;: [&quot;@include utils-transitions($1, $2, $3);&quot;]\n  },\n  &quot;Scss utils extend-click&quot;: {\n    &quot;prefix&quot;: &quot;imec&quot;,\n    &quot;body&quot;: [&quot;@include utils-extend-click;&quot;]\n  },\n  &quot;Scss utils bt-1px&quot;: {\n    &quot;prefix&quot;: &quot;imbt1&quot;,\n    &quot;body&quot;: [&quot;@include utils-bt-1px($1);&quot;]\n  },\n  &quot;Scss utils b1px&quot;: {\n    &quot;prefix&quot;: &quot;imb1&quot;,\n    &quot;body&quot;: [&quot;@include utils-b-1px($1);&quot;]\n  },\n  &quot;Scss utils bb-1px&quot;: {\n    &quot;prefix&quot;: &quot;imbb1&quot;,\n    &quot;body&quot;: [&quot;@include utils-bb-1px($1);&quot;]\n  },\n  &quot;Scss utils hide-scrollbar&quot;: {\n    &quot;prefix&quot;: &quot;imhs&quot;,\n    &quot;body&quot;: [&quot;@include utils-hide-scrollbar;&quot;]\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E上面是我根据个人习惯自定义的 mixin 快捷 prefix，比如键入“ib”回车就编辑器就会自动带出\u003Ccode\u003E@include b($1){$2}\u003C\u002Fcode\u003E，并将光标定位到$1的位置，这个时候输入完 block 的名称后按「tab」键光标就会定位到$2 的位置，使用起来非常方便，就像下图这样子：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"_nuxt\u002Fimg\u002Fpic-vscode-scss-bem.3dd70c6.gif\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"jieyu\"\u003E\u003Ca class=\"cs-header-anchor\" href=\"\" onclick=\"!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyu')\"\u003E¶\u003C\u002Fa\u003E 结语\u003C\u002Fh2\u003E\n\u003Cp\u003E社区里关于「如何编写高可维护的 CSS 代码」的讨论话题中，「BEM」一直占有一席之地，其结构化的 CSS 和 UI 的优势，使很多多人协作的前端项目受益。在 Github 的热门库\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkamranahmedse\u002Fdeveloper-roadmap#frontend-roadmap\" target=\"_blank\"\u003EFront-end roadmap\u003C\u002Fa\u003E中也是被广大开发者优先推荐的。\u003C\u002Fp\u003E\n\u003Cp\u003E本文提到的「BEM」结合「SCSS」进行高效率编写代码的方式其实最早由\u003Ca href=\"https:\u002F\u002Ftwitter.com\u002Fmarcmintel\" target=\"_blank\"\u003EMarc Mintel\u003C\u002Fa\u003E在 medium \u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@marcmintel\u002Fpushing-bem-to-the-next-level-with-sass-3-4-5239d2371321\" target=\"_blank\"\u003E提出\u003C\u002Fa\u003E，而且在热门的开源 UI 库\u003Ca href=\"https:\u002F\u002Felement.eleme.io\u002F\" target=\"_blank\"\u003Eelement.js\u003C\u002Fa\u003E中\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FElemeFE\u002Felement\u002Fblob\u002Fdev\u002Fpackages\u002Ftheme-chalk\u002Fsrc\u002Fmixins\u002Fmixins.scss\" target=\"_blank\"\u003E大量使用\u003C\u002Fa\u003E，其实现更为完善，可以前往继续学习。\u003C\u002Fp\u003E\n",bodyBegin:7,frontmatter:"title: SCSS 环境下的 BEM 优雅实践\ndate: '2020-04-12'\nspoiler: 如何优雅地编写易维护和具语义化的样式代码？",link:a,prev:{title:"剖析无限滚动虚拟列表的实现原理",date:"2020-08-26",spoiler:"长列表渲染的终极优化手段",featured:true,link:"\u002Fpost\u002Fvirtual-infinite-scroll\u002F",min2read:"🍱🍱 28 min read",wordcount:"7k"}}}],fetch:[],mutations:void 0}}("\u002Fpost\u002Fwrite-bem-with-scss\u002F")));