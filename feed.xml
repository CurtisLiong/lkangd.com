<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Curtis' Spot</title>
        <link>https://lkangd.com/feed.xml</link>
        <description>Front-end Engineer. Blogging about life, tech &amp; everything I love.</description>
        <lastBuildDate>Tue, 15 Sep 2020 14:31:13 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <copyright>All rights reserved 2020, Curtis Liong</copyright>
        <category>Curtis' Spot</category>
        <item>
            <title><![CDATA[我常用的 macOS 应用]]></title>
            <link>/post/mac-efficiency-app/</link>
            <guid>/post/mac-efficiency-app/</guid>
            <description><![CDATA[好的工具可以节省寿命]]></description>
            <content:encoded><![CDATA[<p>俗话说「工欲善其事，必先利其器」，熟练使用一些可以提升效率的工具不单止可以增加自身幸福感，还是节省寿命的最好的方式之一。</p>
<p>从 Windows 阵营转到 Mac 平台已经有 6 个年头了，近期经常会有换了 Mac 的小伙伴找我推荐好用的 app，所以特意整理了一下我在开发和日常使用频率都很高的工具和 app，跟大家分享的同时也作一个记录备份，方便日后不时之需。</p>
<h4 id="Chromeliulanqi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Chromeliulanqi')">¶</a> <a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank">Chrome 浏览器</a></h4>
<p>主力浏览器，应对开发和日常使用都绰绰有余。</p>
<h4 id="ShadowsocksXNG"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ShadowsocksXNG')">¶</a> <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank">ShadowsocksX-NG</a></h4>
<p>科学上网必备，开启并配置好远端代理服务器后，本地会启动一个相应的代理服务器 <code>127.0.0.0:1087</code>，配合 <a href="https://www.proxifier.com/">proxifier</a> 使用，可自定义使用场景，指定 app 走代理流量。</p>
<h4 id="TrojanQt5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'TrojanQt5')">¶</a> <a href="https://github.com/Trojan-Qt5/Trojan-Qt5" target="_blank">Trojan-Qt5</a></h4>
<p>(2020/07/08 更新)比上面提到的 ShadowsocksX-NG 更强大更稳定的梯子工具，跨平台，支持多种协议(Socks5/Http/SS/SSR/Vmess/Trojan(go)/Snell)，目前已发布了 28 个版本，并持续迭代中。</p>
<h4 id="VisualStudioCode"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VisualStudioCode')">¶</a> <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a></h4>
<p>可以说是前端开发必备的「代码编辑器」了，提供了种类丰富且强大的插件，大大提升了开发效率。「<a href="/post/vscode-efficiency-extensions">这些</a>」是我常用并推荐的 VSCode 插件。</p>
<h4 id="iTerm2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'iTerm2')">¶</a> <a href="https://iterm2.com/" target="_blank">iTerm 2</a></h4>
<p>秒杀自带的终端工具，为什么要用它? 看「<a href="https://iterm2.com/features.html">这里</a>」了解更多。</p>
<h4 id="ohmyzsh"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ohmyzsh')">¶</a> <a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank">oh-my-zsh</a></h4>
<p>「Oh My Zsh 是一个令人愉快的、开源的、社区驱动的 Zsh 配置管理框架。它配置了成吨的有用的函数、帮助信息、主题，还有一些令你尖叫的东西。」</p>
<p>通过强大插件工具 <em>git，bundler，dotenv，osx，rake，rbenv，ruby，z</em> 等，你会发现原来在命令行环境下工作可以这么愉快。</p>
<h4 id="LastPass"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'LastPass')">¶</a> <a href="https://www.lastpass.com/zh" target="_blank">LastPass</a></h4>
<p>密码生成工具，有独立的 mac app，iOS app 和 chrome 插件，可自动生成，填入，多端同步账户和定期提醒更改密码等，你只需要记住一个密码，剩下的交给 LastPass。</p>
<h4 id="yinxiangbiji"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yinxiangbiji')">¶</a> <a href="https://staging.yinxiang.com/" target="_blank">印象笔记</a></h4>
<p>用了快十年的笔记应用，免费版只能同时同步两个设备，不过一般够用了。</p>
<h4 id="Spark"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Spark')">¶</a> <a href="https://sparkmailapp.com/zh" target="_blank">Spark</a></h4>
<p>Spark 是「基于苹果生态」很好用的一个邮件 app，支持移动端和 mac 端，具有人性化的操作手势和方便的多账户配置.</p>
<h4 id="Lunar"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Lunar')">¶</a> <a href="https://lunar.fyi/" target="_blank">Lunar</a></h4>
<p>如果你是一个多屏幕工作者且处在光源变化较频繁的区域，那你肯定需要 Lunar，可让外接屏幕同步自带屏幕的光源自适应，让你不用再手动去调节外界显示屏的亮度。</p>
<h4 id="OmniDiskSweeper"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'OmniDiskSweeper')">¶</a> <a href="https://www.omnigroup.com/more" target="_blank">OmniDiskSweeper</a></h4>
<p>帮你找回被偷偷吃掉的磁盘空间，统计每个文件夹和文件的磁盘占用空间。</p>
<h4 id="Balsamiq"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Balsamiq')">¶</a> <a href="https://balsamiq.com/">Balsamiq</a></h4>
<p>快速原型工具，我更喜欢用来画一些示例图，这个博客所有的示例图片都是通过这个软件制作的。</p>
<hr>
<p>以下为付费的 app，如果有能力，请支持正版 😁。</p>
<h4 id="Alfred4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Alfred4')">¶</a> <a href="https://www.alfredapp.com/" target="_blank">Alfred 4</a></h4>
<p>作为 Mac 上最强大的效率工具，Alfred 早已不仅仅是最开始的快速启动与搜索工具，它的 workflow 扩展功能，让它成为了一个拥有无限自动化潜力的「工具台」软件，你可以用它来实现你的一切有关自动化的想法。</p>
<h4 id="Things3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Things3')">¶</a> <a href="https://culturedcode.com/things/" target="_blank">Things 3</a></h4>
<p>用过最好用的 <code>GTD</code> app，支持 Mac，iOS，iPad 和 iWatch</p>
<h4 id="Paste"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Paste')">¶</a> <a href="https://pasteapp.io/" target="_blank">Paste</a></h4>
<p>粘贴板工具，可搜索粘贴记录(默认最近 300 条)，支持 mac 和 iOS 端同步。</p>
<h4 id="Moom"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Moom')">¶</a> <a href="https://manytricks.com/moom/" target="_blank">Moom</a></h4>
<p>多窗口管理工具，可自定义并记住窗口布局，支持一键还原窗口布局。</p>
<h4 id="Swish"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Swish')">¶</a> <a href="https://highlyopinionated.co/swish/" target="_blank">Swish</a></h4>
<p>同样是一个窗口管理工具，亮点是操作方式为手势控制，通过两指在触控板的手势操作，可快速设置窗口常用尺寸和定位到屏幕指定位置，并可下滑「最小化」和上滑「最大化」窗口。</p>
<h4 id="MarginNote3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'MarginNote3')">¶</a> <a href="https://www.marginnote.com/chinese/home" target="_blank">MarginNote 3</a></h4>
<p>笔记应用，可根据 pdf 文档内的笔记自动生成脑图。</p>
<h4 id="Mindnode"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Mindnode')">¶</a> <a href="https://mindnode.com/" target="_blank">Mindnode</a></h4>
<p>脑图工具，相较于 <code>xmind</code> 我更喜欢 <code>Mindnode</code>，它具有很快的启动和编辑速度、丰富的模版和好看的颜色搭配。</p>
<h4 id="Bartender3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bartender3')">¶</a> <a href="https://www.macbartender.com/" target="_blank">Bartender 3</a></h4>
<p>在 Menubar 自定义显示需要显示的 icon，一键切换显示和隐藏的 icon。</p>
<hr>
<p>当我发现新的好玩、有用的 app 的时候，就会更新这个列表。</p>
<p>以上，当然你有好的工具也可以跟我分享。Have fun，「+1s」。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[FUN: GitHub Profile README!]]></title>
            <link>/post/readme-for-github-profile/</link>
            <guid>/post/readme-for-github-profile/</guid>
            <description><![CDATA[给你的 Github Profile 页加个好看的个人简介]]></description>
            <content:encoded><![CDATA[<p>最近 github 网站频频改版，前两天在<a href="https://lkangd.com/" target="_blank">本博客</a>托管的 <a href="https://github.com/lkangd/lkangd" target="_blank">仓库</a>右侧发现了一个有趣的提示：</p>
<p><img src="_nuxt/img/pic-github-tip.8dde3ec.png" alt=""><br>
点击<code>Share to Profile</code>，然后发现这个项目根目录的 <a href="http://README.md">README.md</a> 的内容出现在了 github 的个人资料页处。</p>
<p>google 了一下，发现是 github 最近上线的新功能，当用户创建同名仓库的时候，可以使用同名仓库内的 <a href="http://README.md">README.md</a> 作为 Profile 页的说明。</p>
<p>操作步骤如下：</p>
<ol>
<li>创建同名仓库：<br>
在创建 repo 的页面输入跟你当前用户名一样的仓库名，会弹出一个提示框：<br>
<img src="_nuxt/img/pic-github-tip2.2603d81.jpg" alt=""></li>
</ol>
<blockquote>
<p>You found a secret! <strong>lkangd/lkangd</strong> is a ✨special ✨ repository that you can use to add a <a href="http://README.md">README.md</a> to your GitHub profile. Make sure it’s public and initialize it with a README to get started.</p>
</blockquote>
<p>绿框内的文字提示，跟当前用户的用户名同名的仓库，项目根目录内的 <a href="http://README.md">README.md</a> 可以作为 GitHub Profile 的个性说明。需要注意的是这个仓库必须是<code>Public</code>的。</p>
<ol start="2">
<li>编辑 <a href="http://README.md">README.md</a>:<br>
比如我的 <a href="http://README.md">README.md</a> 内容：</li>
</ol>
<pre  class="language-md"><code class="language-md">### Hi, I'm Curtis 👉🧑‍💻

I was born in 1992 and started programming 4 years ago. I used to be an operation and maintenance engineer, but now I focus on JavaScript and wanna create something cool.

🤔I am now looking for a job, if you are interested in me, please

### Contact me:

- 💬WeChat: lkangd
- ✉️E-mail: lkangd@gmail.com
- ✍️Blog: https://lkangd.com
</code></pre><ol start="3">
<li>推送 <a href="http://README.md">README.md</a> 到 github：<br>
把刚刚编辑完成的 <a href="http://README.md">README.md</a>，commit，然后 git push 到 github，就可以看到效果啦，如下：<br>
<img src="_nuxt/img/pic-github-profile.ed02482.png" alt=""></li>
</ol>
<hr>
<h3 id="GithubshangyixieyouqudeREADMEs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'GithubshangyixieyouqudeREADMEs')">¶</a> Github 上一些有趣的 READMEs</h3>
<p>既然是用 md 去写 Profile 页，当然就不仅限于用文字或链接进行表达，它可以是：</p>
<ul>
<li>代码块：<br>
<img src="_nuxt/img/pic-github-example1.60fd735.png" alt=""></li>
<li>图文并茂：<br>
<img src="_nuxt/img/pic-github-example2.c9b48a2.png" alt=""></li>
<li>死宅动漫动图：<br>
<img src="_nuxt/img/pic-github-example3.1755b73.png" alt=""></li>
<li>甚至可以通过 pull request 来玩游戏：<br>
<img src="_nuxt/img/pic-github-example4.76fe740.png" alt=""></li>
</ul>
<p>有人专门创建了一个仓库去收集这些有趣的 READMEs，有兴趣可以去看看 <a href="https://github.com/abhisheknaiidu/awesome-github-profile-readme" target="_blank">看看</a></p>
<p>发挥你的想象力去创造一个个性的 Profile 页吧，Have fun 😬。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我常用的 vscode 扩展]]></title>
            <link>/post/vscode-efficiency-extensions/</link>
            <guid>/post/vscode-efficiency-extensions/</guid>
            <description><![CDATA[编辑器 + 插件 = IDE ？]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#fuzhubianma">辅助编码</a></li><li><a href="#geshihua">格式化</a></li><li><a href="#Gitxiangguan">Git 相关</a></li><li><a href="#xiaoshuai">效率</a></li><li><a href="#Vuexiangguan">Vue 相关</a></li><li><a href="#jiemianmeihua">界面美化</a></li></ul></div></p>
<p>早些年初次接触编程的时候学习的是 C，用的当然只能是 visual studio 2007 之类的老古董，界面古老，操作也不友好。当时大家都是这么用的，也没在意。</p>
<p>后来不经意间接触到了 SublimeText，当时就被它的包管理系统和丰富的主题样式所吸引，立马爱上了这个「性感」的编辑器。但是无奈于国内的「复杂」的网络环境，每次下个插件总要耗费很长时间，并且存在下载失败的可能，且 SublimeText 是闭源的，需要很高的授权费（相对学生党来说），所以一直想找一款好用趁手的编辑器来作为替代品。</p>
<p>就这样时间走到了 2015 底，微软宣布开源 VSCode，其开箱即用、丝般顺滑的运行速度、强大的插件系统、丰富的主题和跨三大系统（支持 Windows，Mac 和 Linux）运行的能力迅速吸引了一大批用户，尤其是<a href="https://atom.io/" target="_blank">Atom</a>的用户开始大量倒戈。我就是在那个时候开始接触和使用 VSCode 的。时至今天，VSCode 仍然保持每月一大更的速度，为用户提供了一个有保证和持续趋近完美的代码编辑器。</p>
<p>很多人会说 VSCode 只是个代码编辑器而已，用起来没有 Webstorm 这样的 IDE 顺手。从用户的角度来说，确实会有这样的感觉。但是，VSCode 具有强大的插件系统生态，并且在国内也布设了服务器，所以通过插件来增强 VScode 是一件很容易的事情。而且，当所有插件都不能满足你的时候，你甚至可以开发属于自己的插件，VSCode 提供了完备的插件开发示例和文档。</p>
<p>作为一个 js 开发者，下面介绍一下我开发时常用到的一些 VSCode 插件，可以给刚开始使用 VSCode 的朋友提供一个小小的参考。</p>
<hr>
<h2 id="fuzhubianma"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'fuzhubianma')">¶</a> 辅助编码</h2>
<h4 id="AutoRenameTag"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AutoRenameTag')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank">Auto Rename Tag</a></h4>
<p>提供像 Visual Studio 一样的 HTML/XML 标签重命名功能。</p>
<h4 id="AutoFileName"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AutoFileName')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=JerryHong.autofilename" target="_blank">AutoFileName</a></h4>
<p>引入类库或本地文件时，时自动补全文件名。</p>
<h4 id="CodeSpellChecker"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CodeSpellChecker')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank">Code Spell Checker</a></h4>
<p>错误拼写的变量名有时候会让你很尴尬，这个基本的拼写检查器，可以很好地使用 camelCase 代码。它的目标是帮助捕获常见的拼写错误，同时保持低误报率。</p>
<h4 id="CodeMetrics"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CodeMetrics')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics" target="_blank">CodeMetrics</a></h4>
<p>分析定义的每个函数的逻辑复杂度，提醒你适度分离函数逻辑，编写和重构代码的利器。</p>
<h4 id="ESLint"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ESLint')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank">ESLint</a></h4>
<p>提供 ESlint 错误提示和一键(可修复状态下)修复错误的功能。</p>
<h4 id="filesize"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'filesize')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize" target="_blank">filesize</a></h4>
<p>在编辑器的状态栏中显示当前编辑文件的大小。点击状态栏组件，它会显示更多关于文件的信息。</p>
<h4 id="ImportCost"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ImportCost')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost" target="_blank">Import Cost</a></h4>
<p>显示引入的每个类库的文件大小。</p>
<h4 id="JavaScriptBooster"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'JavaScriptBooster')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=sburg.vscode-javascript-booster" target="_blank">JavaScript Booster</a></h4>
<p>提供了类似传统 IDE 一键重构代码块的功能。</p>
<h4 id="JSRefactor"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'JSRefactor')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=cmstead.jsrefactor" target="_blank">JS Refactor</a></h4>
<p>同上类似。</p>
<h4 id="IntelliSenseforCSSclassnamesinHTML"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'IntelliSenseforCSSclassnamesinHTML')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion" target="_blank">IntelliSense for CSS class names in HTML</a></h4>
<p>它根据在工作区中找到的定义或通过 link 元素引用的外部文件为 HTML 类属性提供 CSS 类名自动补全的功能。</p>
<h4 id="npmIntellisense"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'npmIntellisense')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense" target="_blank">npm Intellisense</a></h4>
<p>引入 npm 包依赖时，自动补全 npm 包名。</p>
<h4 id="PathIntellisense"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'PathIntellisense')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank">Path Intellisense</a></h4>
<p>根据当前项目文件的上下文提供路径名自动补全的功能。</p>
<h4 id="VisualStudioIntelliCode"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VisualStudioIntelliCode')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode" target="_blank">Visual Studio IntelliCode</a></h4>
<p>号称可以使用云 AI 的方式来帮助你提高编写代码的效率，目前支持 Python、Typescript/JavaScript 和 Java。</p>
<hr>
<h2 id="geshihua"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'geshihua')">¶</a> 格式化</h2>
<h4 id="BracketPairColorizer2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BracketPairColorizer2')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2" target="_blank">Bracket Pair Colorizer 2</a></h4>
<p>用颜色来匹配括号。你可以定义各种括号匹配使用的颜色，帮助你快速锁定当前关注的代码块。</p>
<h4 id="DotENV"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'DotENV')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv" target="_blank">DotENV</a></h4>
<p>提供项目中 .env 环境变量文件的高亮显示支持。</p>
<h4 id="indentrainbow"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'indentrainbow')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow" target="_blank">indent-rainbow</a></h4>
<p>使文本前面的缩进着色，每步可交替使用四种不同的颜色。对 Python 语言尤其有用。</p>
<h4 id="PrettierCodeformatter"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'PrettierCodeformatter')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank">Prettier - Code formatter</a></h4>
<p>人人都在用的前端代码格式化工具，根据最先找到的自定义 prettier 格式化文件来格式化代码，支持 JavaScript、TypeScript、Flow、JSX、JSONCSS、SCSS、Less、HTML、Vue、Angular、GraphQL、Markdown、YAML 等等，前端「所有」的文件格式化需求，一个工具搞定。</p>
<h4 id="TrailingSpaces"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'TrailingSpaces')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces" target="_blank">Trailing Spaces</a></h4>
<p>运行 VSCode 格式化命令时，自动删除行后的多余空格。</p>
<hr>
<h2 id="Gitxiangguan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Gitxiangguan')">¶</a> Git 相关</h2>
<h4 id="GitLensGitsupercharged"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'GitLensGitsupercharged')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank">GitLens — Git supercharged</a></h4>
<p>VSCode 最强大的 git 插件，没有之一。通过 Git 责备注释和代码镜头，它可以帮助你直观地看到代码的作者身份，无缝地导航和探索 Git 存储库，通过强大的比较命令获得有价值的见解，等等。</p>
<h4 id="GitHistory"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'GitHistory')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" target="_blank">Git History</a></h4>
<p>提供一个界面交互式的 git log 回溯界面，作为对 GitLens 的补充。</p>
<hr>
<h2 id="xiaoshuai"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiaoshuai')">¶</a> 效率</h2>
<h4 id="Bookmarks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bookmarks')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks" target="_blank">Bookmarks</a></h4>
<p>它可以给代码行或块打上书签标记，并在书签之间快速跳转，可分组和自定义书签名。对于日志文件分析和代码库分析非常有用。</p>
<h4 id="DebuggerforChrome"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'DebuggerforChrome')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank">Debugger for Chrome</a></h4>
<p>提供 VSCode 在 Chrome 打断点 debug 的模式，支持 Chrome DevTools 协议。</p>
<h4 id="DocumentThis"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'DocumentThis')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=joelday.docthis" target="_blank">Document This</a></h4>
<p>可以自动为 TypeScript 和 JavaScript 文件生成详细的 JSDoc 注释。</p>
<h4 id="Imagepreview"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Imagepreview')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview" target="_blank">Image preview</a></h4>
<p>在边栏和你鼠标悬停在的图片路径上显示图片的预览图。</p>
<h4 id="npm"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'npm')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=eg2.vscode-npm-script" target="_blank">npm</a></h4>
<p>一键运行 package.json 中定义 npm 脚本和根据 package.json 中定义的依赖项验证模块是否安装和安装正确。</p>
<h4 id="ProjectManager"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ProjectManager')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager" target="_blank">Project Manager</a></h4>
<p>项目收藏管理，可快速切换和打开之前收藏过的项目。</p>
<h4 id="RESTClient"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'RESTClient')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank">REST Client</a></h4>
<p>允许你直接在 VSCode 中发送 HTTP 请求并查看响应。</p>
<h4 id="SVGViewer"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SVGViewer')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer" target="_blank">SVG Viewer</a></h4>
<p>在 VSCode 中直接预览 SVG 图片文件。</p>
<h4 id="TranslatorHelper"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'TranslatorHelper')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=XiaodiYan.translator-helper" target="_blank">Translator Helper</a></h4>
<p>通过调用谷歌翻译的接口，直接在 VSCode 内将英文翻译成中文。</p>
<h4 id="VersionLens"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VersionLens')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens" target="_blank">Version Lens</a></h4>
<p>提供查看当前 package.json 的依赖的版本建议的功能。</p>
<h4 id="vscoderandom"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'vscoderandom')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=jrebocho.vscode-random" target="_blank">vscode-random</a></h4>
<p>快速生成一段可指定格式(电子邮件、城市、整数等等)的随机文本。</p>
<hr>
<h2 id="Vuexiangguan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Vuexiangguan')">¶</a> Vue 相关</h2>
<h4 id="Vetur"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Vetur')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank">Vetur</a></h4>
<p>基于 vue-language-server 实现的 vue 工具，包含代码高亮、代码片段、Emmet 补全、错误提示、自动补全和 debug 的功能， vue 开发者必备。</p>
<h4 id="VuePeek"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VuePeek')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=dariofuzinato.vue-peek" target="_blank">Vue Peek</a></h4>
<p>vue 组件定义快速跳转。</p>
<h4 id="Vue2Snippets"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Vue2Snippets')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets" target="_blank">Vue 2 Snippets</a></h4>
<p>vue 代码片段。</p>
<h4 id="VueVSCodeSnippets"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VueVSCodeSnippets')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=sdras.vue-vscode-snippets" target="_blank">Vue VSCode Snippets</a></h4>
<p>vue 代码片段。</p>
<h4 id="VueHelper"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'VueHelper')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=oysun.vuehelper" target="_blank">VueHelper</a></h4>
<p>vue 代码片段。</p>
<hr>
<h2 id="jiemianmeihua"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiemianmeihua')">¶</a> 界面美化</h2>
<h4 id="BeautifulUI"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BeautifulUI')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=swashata.beautiful-ui" target="_blank">Beautiful UI</a></h4>
<p>从 Sublime 主题「DA CS」移植过来的主题套件，包含 32 个不同的黑暗/白天主题。</p>
<h4 id="GitHubTheme"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'GitHubTheme')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.github-vscode-theme" target="_blank">GitHub Theme</a></h4>
<p>Github 风格的 VSCode 主题。</p>
<h4 id="MaterialIconTheme"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'MaterialIconTheme')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme" target="_blank">Material Icon Theme</a></h4>
<p>一套 Material 风格的 icon。</p>
<h4 id="CustomCSSandJSLoader"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CustomCSSandJSLoader')">¶</a> <a href="https://marketplace.visualstudio.com/items?itemName=be5invis.vscode-custom-css" target="_blank">Custom CSS and JS Loader</a></h4>
<p>千人千面，众口难调。当所有的主题都让你感觉差一点，但你又不想大费周章地自己开发一个主题的时候，那么你需要这个插件。它通过覆盖 VSCode 自带 CSS 样式的方式来让你自定义样式。我习惯通过这个插件来让所有字体都不超过 12px，这样感觉更美观，同时可以让我在 13 寸的屏幕同时里面看到更多的内容。</p>
<hr>
<p>当我发现新的好玩、有用的 VSCode 扩展的时候，就会更新这个列表。</p>
<p>以上，当然你有好的 VSCode 扩展也可以跟我分享。😁 Happy Hacking.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[树数据结构的原理及JS实现]]></title>
            <link>/post/data-structure-tree/</link>
            <guid>/post/data-structure-tree/</guid>
            <description><![CDATA[JavaScript语言环境下的树学习]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#shimoshishu">什么是树？</a><ul><li><a href="#dingyi">定义</a></li><li><a href="#jiedianfenlei">结点分类</a></li><li><a href="#jiedianguanxi">结点关系</a></li><li><a href="#cengyushendu">层与深度</a></li></ul></li><li><a href="#cunchujiegou">存储结构</a><ul><li><a href="#fumubiaoshifa">父母表示法</a></li><li><a href="#haizibiaoshifa">孩子表示法</a></li><li><a href="#haizixiongdibiaoshifa">孩子兄弟表示法</a></li></ul></li><li><a href="#changyongshujiegouerchashu">常用树结构：二叉树</a><ul><li><a href="#erchashudingyi">二叉树定义</a></li><li><a href="#erchashucunchujiegou">二叉树存储结构</a></li><li><a href="#erchashubianli">二叉树遍历</a></li></ul></li></ul></div></p>
<h2 id="shimoshishu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshishu')">¶</a> 什么是树？</h2>
<h3 id="dingyi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dingyi')">¶</a> 定义</h3>
<p>树（Tree）是 n（n &gt;= 0）个结点的有限集合。n = 0 时称为空树。在任意一棵非空树中：</p>
<ul>
<li><strong>有且仅有一个</strong>特定的称为根（Root）的结点；</li>
<li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集合 T1、T2、...、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；</li>
<li>所有子树的集合称为<strong>森林（Forest）</strong>；</li>
<li>树中结点的各子树如果从左至右是有次序且不能互换的，称为有序树，否则称为无序树；<br>
<img src="_nuxt/img/pic-1.73192a2.png" alt=""></li>
</ul>
<h3 id="jiedianfenlei"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiedianfenlei')">¶</a> 结点分类</h3>
<p>树的结点包含一个数据元素和若干指向其子树的分支。<br>
结点拥有的子树称为结点的<code>度（Degree）</code>。度为 0 的结点称为<strong>叶结点（Leaf）</strong>；度不为 0 的结点称为<strong>分支结点</strong>。除根结点外，分支结点也称为内部结点。树的度是<strong>树内各结点的度最大值</strong>。<br>
<img src="_nuxt/img/pic-2.7454d80.png" alt=""></p>
<h3 id="jiedianguanxi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiedianguanxi')">¶</a> 结点关系</h3>
<p>结点的下一层分支称为改结点的<strong>子结点（Child）</strong>，结点的上一层分支称为该结点的<strong>父结点（Parent）</strong>。同一个父结点的结点之间称为<strong>兄弟结点（Sibling）</strong>。结点上层所有的结点称为该结点的<strong>祖先结点</strong>，反之，结点下层所有的结点称为该节点的<strong>子孙结点</strong>。<br>
<img src="_nuxt/img/pic-3.8f23481.png" alt=""></p>
<h3 id="cengyushendu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cengyushendu')">¶</a> 层与深度</h3>
<p>结点的 <strong>层次（level）</strong> 从根开始定义，根为第一层，根的子结点为第二层，依次类推。父结点在同一层的同层结点互为堂兄弟结点，如  G、H、I 与 J 互为堂兄弟结点。</p>
<p>树中结点最大层次称为树的 <strong>深度（Depth）</strong> ，当前树的深度为 5 。<br>
<img src="_nuxt/img/pic-4.52e8be9.png" alt=""></p>
<hr>
<h2 id="cunchujiegou"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cunchujiegou')">¶</a> 存储结构</h2>
<p>子结点个数无限制的有根树有 3 种常用的关系表示法进行数据存储，</p>
<ul>
<li><strong>父母表示法</strong></li>
<li><strong>孩子表示法</strong></li>
<li><strong>左孩子右兄弟表示法（left-child, right-sibling representation）</strong></li>
</ul>
<h3 id="fumubiaoshifa"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'fumubiaoshifa')">¶</a> 父母表示法</h3>
<p>父母表示法的一般做法是使用线性的存储结构，将每个结点<strong>按结点所在层次</strong>从左往右依次记录在该线性存储结构内（数组），在存储每个结点时，使用一个变量存储其父结点所在的下标。父结点的下标为 <strong>-1</strong>，当需要遍历一棵树时，遍历到下标为 <strong>-1</strong> 时就可知道整棵树已经完成遍历。</p>
<p>要点：</p>
<ul>
<li>使用数组依次存储所有结点；</li>
<li>每个结点内记录父结点的数组下标；<br>
<img src="_nuxt/img/pic-5.f341874.png" alt=""></li>
</ul>
<p>当业务场景需要频繁查找某结点的父结点时，这种表示法最合适，所需的时间复杂度为<strong>O(1)</strong>。</p>
<h4 id="daimashixian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian')">¶</a> 代码实现</h4>
<pre  class="language-javascript"><code class="language-javascript">class TreeNode {
  constructor(data, parentSub) {
    this.data = data;
    this.parent = parentSub;
  }
}

class Tree {
  constructor() {
    this.data = [];
  }
  // 返回树的深度
  treeDepth() {
    if (this.data.filter(Boolean).length === 0) return 0;

    let lastChild = Math.max.apply(
      null,
      this.data.map(node =&gt; node &amp;&amp; node.parent),
    );
    lastChild = this.data[lastChild];
    let depth = 1;
    while (~lastChild.parent) {
      lastChild = this.data[lastChild.parent];
      depth++;
    }
    return depth + 1;
  }
  // 插入结点
  insertChild(node) {
    if (this.data[0] &amp;&amp; !this.data[node.parent]) {
      return false;
    }
    for (let i = 0; i &lt; this.data.length; i++) {
      if (this.data[i] === null) {
        this.data[i] = node;
        return true;
      }
    }
    this.data.push(node);
    return true;
  }
  // 删除结点及其子树
  deleteChild(node) {
    const nodeSub = this.data.indexOf(node);
    if (nodeSub !== -1) {
      this.data[nodeSub] = null;
      const needDels = [nodeSub];
      for (let i = 0, n; i &lt; this.data.length; i++) {
        n = this.data[i];
        if (n &amp;&amp; needDels.indexOf(n.parent) !== -1) {
          this.data[i] = null;
          needDels.push(i);
        }
      }
      return true;
    }
    return false;
  }
}

// 初始化树，结点
const tree = new Tree();
const A = new TreeNode('A', -1);
const B = new TreeNode('B', 0);
const C = new TreeNode('C', 0);
const D = new TreeNode('D', 1);
const E = new TreeNode('E', 2);
const F = new TreeNode('F', 2);
const G = new TreeNode('G', 3);
const H = new TreeNode('H', 3);
const I = new TreeNode('I', 3);
const J = new TreeNode('J', 4);
const K = new TreeNode('K', 9);
const L = new TreeNode('L', 9);
const M = new TreeNode('M', 9);

// 插入结点
tree.insertChild(A);
tree.insertChild(B);
tree.insertChild(C);
tree.insertChild(D);
tree.insertChild(E);
tree.insertChild(F);
tree.insertChild(G);
tree.insertChild(H);
tree.insertChild(I);
tree.insertChild(J);
tree.insertChild(K);
tree.insertChild(L);

// 测试
tree.deleteChild(M); // false 结点不存在树内
tree.deleteChild(D); // true
tree.treeDepth(); // 5
tree.deleteChild(J); // true
tree.treeDepth(); // 3
tree.insertChild(J);
tree.treeDepth(); // 4
</code></pre><h3 id="haizibiaoshifa"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'haizibiaoshifa')">¶</a> 孩子表示法</h3>
<p>孩子表示法跟父母表示法做法类似，也是使用线性的存储结构，将每个结点<strong>按结点所在层次</strong>从左往右依次记录在该线性存储结构内（数组），但是在存储每个结点时，将该结点的孩子结点排列成一个线性表（链表）。所以对于有 n 个结点的数来说，就会有 n 个单链表。</p>
<p>要点：</p>
<ul>
<li>使用数组依次存储所有结点；</li>
<li>每个结点维护一个指向该结点所有孩子的链表；<br>
<img src="_nuxt/img/pic-6.159363c.png" alt=""></li>
</ul>
<h4 id="daimashixian-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-2')">¶</a> 代码实现</h4>
<pre  class="language-javascript"><code class="language-javascript">class TreeNode {
  constructor(data, next = null) {
    this.data = data;
    this.next = next;
  }
  setNext(next = null) {
    this.next = next;
  }
}

class TreeNodeChain {
  constructor(treeNodeSub, next = null) {
    this.treeNodeSub = treeNodeSub;
    this.next = next;
  }
  setNext(next = null) {
    this.next = next;
  }
  setSub(treeNodeSub) {
    this.treeNodeSub = treeNodeSub;
  }
}

class Tree {
  constructor() {
    this.data = [];
  }
  treeDepth() {
    if (this.data.filter(Boolean).length === 0) return 0;

    let result = 0;
    const root = this.data[0];
    const getDepth = (node, _depth = 1) =&gt; {
      if (node.next) {
        let nextChild = node.next;
        getDepth(this.data[nextChild.treeNodeSub], _depth + 1);
        while (nextChild &amp;&amp; nextChild.next) {
          getDepth(this.data[nextChild.next.treeNodeSub], _depth + 1);
          nextChild = nextChild.next;
        }
      }
      result = Math.max(result, _depth);
    };
    getDepth(root);
    return result;
  }
  insertChild(node) {
    for (let i = 0; i &lt; this.data.length; i++) {
      if (this.data[i] === null) {
        this.data[i] = node;
        return i;
      }
    }
    this.data.push(node);
    return this.data.length - 1;
  }
  deleteChild(delNode) {
    const nodeSub = this.data.indexOf(delNode);
    if (nodeSub !== -1) {
      this.data[nodeSub] = null;
      // 删除孩子和结点所维持的链表
      while (delNode.next) {
        let prev = delNode;
        delNode = delNode.next;
        prev.setNext(null);
        this.data[delNode.treeNodeSub] = null;
      }

      // 更新父母链表关系
      for (let i = 0; i &lt; this.data.length; i++) {
        let node = this.data[i];
        while (node &amp;&amp; node.next) {
          if (node.next.treeNodeSub === nodeSub) {
            node.next = node.next.next;
            return true;
          } else {
            node = node.next;
          }
        }
      }
      return true;
    }
    return false;
  }
}

// 初始化树，结点
const tree = new Tree();
const A = new TreeNode('A');
const B = new TreeNode('B');
const C = new TreeNode('C');
const D = new TreeNode('D');
const E = new TreeNode('E');
const F = new TreeNode('F');
const G = new TreeNode('G');
const H = new TreeNode('H');
const I = new TreeNode('I');
const J = new TreeNode('J');
const K = new TreeNode('K');
const L = new TreeNode('L');
const M = new TreeNode('M');

// 插入结点
tree.insertChild(A);
tree.insertChild(B);
tree.insertChild(C);
tree.insertChild(D);
tree.insertChild(E);
tree.insertChild(F);
tree.insertChild(G);
tree.insertChild(H);
tree.insertChild(I);
tree.insertChild(J);
tree.insertChild(K);
tree.insertChild(L);

// 设置关系
const A1 = new TreeNodeChain(1);
const A2 = new TreeNodeChain(2);
A.setNext(A1);
A1.setNext(A2);

const B1 = new TreeNodeChain(3);
B.setNext(B1);

const C1 = new TreeNodeChain(4);
const C2 = new TreeNodeChain(5);
C.setNext(C1);
C1.setNext(C2);

const D1 = new TreeNodeChain(6);
const D2 = new TreeNodeChain(7);
const D3 = new TreeNodeChain(8);
D.setNext(D1);
D1.setNext(D2);
D2.setNext(D3);

const E1 = new TreeNodeChain(9);
E.setNext(E1);

const J1 = new TreeNodeChain(10);
const J2 = new TreeNodeChain(11);
J.setNext(J1);
J1.setNext(J2);

// 测试
tree.deleteChild(M); // false 结点不存在树内
tree.deleteChild(D); // true
D.next; // null
D1.next; // null
D2.next; // null
tree.treeDepth(); // 5
tree.deleteChild(J); // true
J.next; // null
J1.next; // null
J2.next; // null
tree.treeDepth(); // 3
tree.deleteChild(H); // false
tree.treeDepth(); // 3

const newIndex = tree.insertChild(J); // 3
E1.setSub(newIndex);
E.setNext(E1);
tree.treeDepth(); // 4
</code></pre><p>使用孩子表示法存储的树结构，正好和父母表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。但是因为每个结点都维持了一个链表，所以空间复杂度会大大增加。</p>
<p>从上面两种的实现原理和代码，不难发现可以结合“父母表示法”和“孩子表示法”来实现一种特殊的“父母孩子表示法”，适合同时需要频繁“父母”和“孩子”的场景，是一种常用的“空间”换“时间”的手段。</p>
<h3 id="haizixiongdibiaoshifa"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'haizixiongdibiaoshifa')">¶</a> 孩子兄弟表示法</h3>
<p>与上述两种表示法不同的是，这种表示法不再需要声明额外的空间进行所有结点的存储，而是直接使用链式存储结构来关进行结点关联，因为只有两个指针域指向，所有这种表示法其实是将一棵不限定子结点数量的有根树转换成了 <strong>“二叉树”</strong>。</p>
<p>要点：</p>
<ul>
<li>生成 node 存储结构，除数据域 “data” 外，该 node 拥有 “next” 和 “right” 两个特殊属性；</li>
<li>node.next 指向 node 最左边的第一个孩子；</li>
<li>node.right 指向 node 右边的第一个兄弟；<br>
<img src="_nuxt/img/pic-7.244cfb7.png" alt=""></li>
</ul>
<h4 id="daimashixian-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-3')">¶</a> 代码实现</h4>
<pre  class="language-javascript"><code class="language-javascript">class TreeNode {
  constructor(data, next = null, right = null) {
    this.data = data;
    this.next = next;
    this.right = right;
  }
  setNext(next = null) {
    this.next = next;
  }
  setRight(right = null) {
    this.right = right;
  }
}

function insertNode(parent, treeNode) {
  let prev = parent.next;
  parent.next = treeNode;
  treeNode.right = prev;
}
function deleteNode(root, target) {
  target.next = null;
  const update = node =&gt; {
    if (node.next === target) {
      if (target.right) {
        node.next = target.right;
      } else {
        node.next = null;
      }
    } else if (node.right === target) {
      node.right = null;
    }
    node.next &amp;&amp; update(node.next);
    node.right &amp;&amp; update(node.right);
  };
  update(root);
}
function treeDepth(root) {
  let result = 0;
  const getDepth = (node, _depth = 1) =&gt; {
    if (node.next) {
      let nextChild = node.next;
      getDepth(nextChild, _depth + 1);
      while (nextChild &amp;&amp; nextChild.right) {
        // 向右遍历层数不增加
        getDepth(nextChild.right, _depth);
        nextChild = nextChild.right;
      }
    }
    result = Math.max(result, _depth);
  };
  getDepth(root);
  return result;
}

// 初始化结点
const A = new TreeNode('A');
const B = new TreeNode('B');
const C = new TreeNode('C');
const D = new TreeNode('D');
const E = new TreeNode('E');
const F = new TreeNode('F');
const G = new TreeNode('G');
const H = new TreeNode('H');
const I = new TreeNode('I');
const J = new TreeNode('J');
const K = new TreeNode('K');
const L = new TreeNode('L');
const M = new TreeNode('M');

// 设置结点关系
A.setNext(B);
B.setNext(D);
B.setRight(C);
C.setNext(E);
D.setNext(G);
E.setNext(J);
E.setRight(F);
G.setRight(H);
H.setRight(I);
J.setNext(K);
K.setRight(L);

// 测试
deleteNode(A, C);
treeDepth(A); // 4
deleteNode(A, D);
treeDepth(A); // 2
C.setNext(E);
E.setNext(J);
E.setRight(F);
J.setNext(K);
K.setRight(L);
insertNode(A, C);
treeDepth(A); // 5
</code></pre><p>通过孩子兄弟表示法，普通树转化为了二叉树，所以孩子兄弟表示法又被称为 <strong>“二叉树表示法</strong>”或者 <strong>“二叉链表表示法”</strong>。</p>
<hr>
<h2 id="changyongshujiegouerchashu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'changyongshujiegouerchashu')">¶</a> 常用树结构：二叉树</h2>
<h3 id="erchashudingyi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'erchashudingyi')">¶</a> 二叉树定义</h3>
<p>二叉树（Binary Tree）是 n（n &gt;= 0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两课互不相交的、分别称为根结点的左子树和右子树的二叉树组成。在一棵二叉树中：</p>
<ul>
<li>每个结点最多有两棵子树，树中不存在度大于 2 的结点；</li>
<li>左子树和右子树是有顺序的，次序不能颠倒；</li>
<li>即使树中某个结点只有子结点，也必须区分该结点是左结点还是右结点；</li>
<li>有五种基本形态：空二叉树、只有根结点、根结点只有左子树、根结点只有右子树、根结点同时具有左子树和右子树；<br>
<img src="_nuxt/img/pic-8.9644366.png" alt=""></li>
</ul>
<h3 id="erchashucunchujiegou"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'erchashucunchujiegou')">¶</a> 二叉树存储结构</h3>
<p>二叉树常用的存储结构有两种，分别是线性的数组存储和链接存储，线性数组存储一般只适用于<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank">完全二叉树</a>，这里不作详细讨论，只着重讲解更普遍适用的链式存储结构。</p>
<h4 id="daimashixian-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-4')">¶</a> 代码实现</h4>
<pre  class="language-javascript"><code class="language-javascript">class TreeNode {
  constructor(data, leftChild = null, rightChild = null) {
    this.data = data;
    this.leftChild = leftChild;
    this.rightChild = rightChild;
  }
  setLeft(leftChild = null) {
    this.leftChild = leftChild;
  }
  setRight(rightChild = null) {
    this.rightChild = rightChild;
  }
}
// 前序生成二叉树
function createBiTree(datas) {
  const data = datas.shift();
  if (data) {
    const root = new TreeNode(data);
    const leftChild = createBiTree(datas);
    const rightChild = createBiTree(datas);
    root.setLeft(leftChild);
    root.setRight(rightChild);
    return root;
  } else {
    return null;
  }
}

// 生成树
const tree = createBiTree([
  'A',
  'B',
  'D',
  'H',
  null,
  null,
  'I',
  null,
  null,
  'E',
  'J',
  null,
  null,
  'K',
  null,
  null,
  'C',
  'F',
  'L',
  null,
  null,
  'M',
  null,
  null,
  'G',
  'N',
  null,
  null,
  'O',
  null,
  null,
]);
</code></pre><p>观察代码实现可以发现，因为二叉树的特殊性质，对于树的生成，不需要再一个一个手动生成和关联结点间的关系，而是将树结构按“前序”的方式排列装入数组，然后借助一个特殊的“前序”生成辅助函数来生成树。</p>
<p>下面来介绍二叉树的“前序”、“中序”、“后序”三种遍历方式的实现原理和实现方式。</p>
<h3 id="erchashubianli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'erchashubianli')">¶</a> 二叉树遍历</h3>
<p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种 <strong><code>次序</code></strong> 依次 <strong><code>访问</code></strong> 二叉树中的所有结点，使得每个结点都被访问一次，且仅被只访问一次。</p>
<h4 id="qianxubianli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'qianxubianli')">¶</a> 前序遍历</h4>
<p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如下图，遍历顺序为 A，B，D，H，I，E，J，K，C，F，L，M，G，N，O。<br>
<img src="_nuxt/img/pic-9.4b229ae.png" alt=""></p>
<h5 id="daimashixian-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-5')">¶</a> 代码实现</h5>
<pre  data-line="6,7,8" class="language-javascript"><code data-line="6,7,8" class="language-javascript">// 前序遍历
function preOrderTraverse(treeNode) {
  if (treeNode === null) {
    return;
  }
  console.log('treeNode.data :&gt;&gt; ', treeNode.data);
  preOrderTraverse(treeNode.leftChild);
  preOrderTraverse(treeNode.rightChild);
}

preOrderTraverse(tree);
// treeNode.data :&gt;&gt;  A
// treeNode.data :&gt;&gt;  B
// treeNode.data :&gt;&gt;  D
// treeNode.data :&gt;&gt;  H
// treeNode.data :&gt;&gt;  I
// treeNode.data :&gt;&gt;  E
// treeNode.data :&gt;&gt;  J
// treeNode.data :&gt;&gt;  K
// treeNode.data :&gt;&gt;  C
// treeNode.data :&gt;&gt;  F
// treeNode.data :&gt;&gt;  L
// treeNode.data :&gt;&gt;  M
// treeNode.data :&gt;&gt;  G
// treeNode.data :&gt;&gt;  N
// treeNode.data :&gt;&gt;  O
</code></pre><p>留意代码实现的高亮部分，这里使用 console 的方式来进行数据访问的操作，逻辑的顺序是：<strong>访问数据 =&gt; 递归左子树 =&gt; 递归右子树</strong>，数据访问操作放在两个递归操作的<strong>前面</strong>，根结点的访问在最前面。</p>
<h4 id="zhongxubianli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhongxubianli')">¶</a> 中序遍历</h4>
<p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后是中序遍历右子树，如下图，遍历顺序为 H，D，I，B，J，E，K，A，L，F，M，C，N，G，O。<br>
<img src="_nuxt/img/pic-10.95f9c22.png" alt=""></p>
<h5 id="daimashixian-6"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-6')">¶</a> 代码实现</h5>
<pre  data-line="6,7,8" class="language-javascript"><code data-line="6,7,8" class="language-javascript">// 中序遍历
function inOrderTraverse(treeNode) {
  if (treeNode === null) {
    return;
  }
  inOrderTraverse(treeNode.leftChild);
  console.log('treeNode.data :&gt;&gt; ', treeNode.data);
  inOrderTraverse(treeNode.rightChild);
}

inOrderTraverse(tree);
// treeNode.data :&gt;&gt;  H
// treeNode.data :&gt;&gt;  D
// treeNode.data :&gt;&gt;  I
// treeNode.data :&gt;&gt;  B
// treeNode.data :&gt;&gt;  J
// treeNode.data :&gt;&gt;  E
// treeNode.data :&gt;&gt;  K
// treeNode.data :&gt;&gt;  A
// treeNode.data :&gt;&gt;  L
// treeNode.data :&gt;&gt;  F
// treeNode.data :&gt;&gt;  M
// treeNode.data :&gt;&gt;  C
// treeNode.data :&gt;&gt;  N
// treeNode.data :&gt;&gt;  G
// treeNode.data :&gt;&gt;  O
</code></pre><p>留意代码实现的高亮部分，这里使用 console 的方式来进行数据访问的操作，逻辑的顺序是：<strong>递归左子树 =&gt; 访问数据 =&gt; 递归右子树</strong>，数据访问操作放在两个递归操作的<strong>中间</strong>，根结点的访问在正中间。</p>
<h4 id="houxubianli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'houxubianli')">¶</a> 后序遍历</h4>
<p>规则是若树为空，则空操作返回，否则从左到右先叶子结点的方式遍历访问左右子树，最后是访问根结点。如下图，遍历顺序是 H，I，D，J，K，E，B，L，M，F，N，O，G，C，A。<br>
<img src="_nuxt/img/pic-11.bfc24ba.png" alt=""></p>
<h5 id="daimashixian-7"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian-7')">¶</a> 代码实现</h5>
<pre  data-line="6,7,8" class="language-javascript"><code data-line="6,7,8" class="language-javascript">// 后序遍历
function postOrderTraverse(treeNode) {
  if (treeNode === null) {
    return;
  }
  postOrderTraverse(treeNode.leftChild);
  postOrderTraverse(treeNode.rightChild);
  console.log('treeNode.data :&gt;&gt; ', treeNode.data);
}

postOrderTraverse(tree);
// treeNode.data :&gt;&gt;  H
// treeNode.data :&gt;&gt;  I
// treeNode.data :&gt;&gt;  D
// treeNode.data :&gt;&gt;  J
// treeNode.data :&gt;&gt;  K
// treeNode.data :&gt;&gt;  E
// treeNode.data :&gt;&gt;  B
// treeNode.data :&gt;&gt;  L
// treeNode.data :&gt;&gt;  M
// treeNode.data :&gt;&gt;  F
// treeNode.data :&gt;&gt;  N
// treeNode.data :&gt;&gt;  O
// treeNode.data :&gt;&gt;  G
// treeNode.data :&gt;&gt;  C
// treeNode.data :&gt;&gt;  A
</code></pre><p>留意代码实现的高亮部分，这里使用 console 的方式来进行数据访问的操作，逻辑的顺序是：<strong>递归左子树 =&gt; 递归右子树 =&gt; 访问数据</strong>，数据访问操作放在两个递归操作的<strong>后面</strong>，根结点的访问在最后面。</p>
<h4 id="buchong"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'buchong')">¶</a> 补充</h4>
<p>前面说树的表示法时，提到“孩子兄弟表示法”又称为 <strong>“二叉树表示法</strong>”，再结合二叉树的定义，可以得知其实所有有根树都可以转换为一棵 <strong><em>根结点没有右子树</em></strong> 的二叉树，篇幅有限这里不再展开，推荐一篇文章：<a href="https://zhuanlan.zhihu.com/p/134251528" target="_blank">树和森林与二叉树的相互转换</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Design Patterns In Javascript]]></title>
            <link>/post/design-patterns-in-javascript/</link>
            <guid>/post/design-patterns-in-javascript/</guid>
            <description><![CDATA[总结常用设计模式在 Javascript 中的实现]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#danlimoshi">单例模式</a></li><li><a href="#celvemoshi">策略模式</a></li><li><a href="#dailimoshi">代理模式</a></li><li><a href="#diedaiqimoshi">迭代器模式</a></li><li><a href="#fabudingyuemoshi">发布订阅模式</a></li><li><a href="#minglingmoshi">命令模式</a></li><li><a href="#zuhemoshi">组合模式</a></li><li><a href="#mobanfangfamoshi">模板方法模式</a></li><li><a href="#xiangyuanmoshi">享元模式</a></li><li><a href="#zhizelianmoshi">职责链模式</a></li><li><a href="#zhongjiezhemoshi">中介者模式</a></li><li><a href="#zhuangshizhemoshi">装饰者模式</a></li><li><a href="#zhuangtaimoshi">状态模式</a></li><li><a href="#shipeiqimoshi">适配器模式</a></li><li><a href="#jieyan">结言</a></li></ul></div></p>
<blockquote>
<p>设计模式：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p>
</blockquote>
<p>设计模式这个术语是上个世纪 90 年代由 Erich Gamma、Richard Helm、Raplh Johnson 和 Jonhn Vlissides 四个人总结提炼出来的，并且写了一本叫 <a href="https://book.douban.com/subject/1052241/" target="_blank">《Design Patterns》</a> 的书。这四人也被称为四人帮（GoF）。</p>
<p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。</p>
<p>在 JavaScript 这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另一个类，并且可以将函数作为参数随意传递，所以在 JavaScript 里很多设计模式的实现与传统的静态类型语言不尽相同。</p>
<h2 id="danlimoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'danlimoshi')">¶</a> 单例模式</h2>
<blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p>单例模式（Singleton）的目的很简单，就是为了保证某个「类」在全局范围内有且仅有一个实例。在 JavaScript 开发中，单例模式用途也非常广泛，比如用户界面中的登录浮窗、全局的状态管理实例等。</p>
<p>单例模式在 JavaScript 中的实现方式很简单：</p>
<ol>
<li>通过静态属性<code>instance</code>变量持有唯一属性，保证全局唯一性；</li>
<li>通过静态方法<code>getInstance</code>返回这个唯一实例，使外部调用方法能获取到实例；</li>
<li>限制构造函数的返回结果，以保证使用<code>new SomeClass</code>方式时仍能返回唯一实例。</li>
</ol>
<pre  class="language-js"><code class="language-js">class Singleton {
  static instance = null; // 记录单实例
  // 返回已存在的实例，否则创建一个实例
  static getInstance(name) {
    return Singleton.instance || new Singleton(name);
  }
  constructor(name) {
    this.name = name;
    return Singleton.instance || (Singleton.instance = this);
  }
  showName() {
    return this.name;
  }
}

const s1 = Singleton.getInstance('s1');
const s2 = Singleton.getInstance('s2');

console.log(s1 === s2); // true
</code></pre><p>仔细观察上面的代码不难发现，单例限制部分其实与构造函数本身要实现的行为没有太大的关联，因此可以将单例限制的部分抽取出来作为公共的单例化函数。此函数接收一个构造函数，返回一个经过包装后的<strong>单例化构造函数</strong>，实现如下。</p>
<pre  class="language-js"><code class="language-js">function getSingleton(ctor) {
  return class Singleton extends ctor {
    static instance = null; // 记录单实例
    // 返回已存在的实例，否则创建一个实例
    static getInstance(...args) {
      return Singleton.instance || new Singleton(...args);
    }
    constructor(...args) {
      super(...args);
      return Singleton.instance || (Singleton.instance = this);
    }
  };
}

class SomeClass {
  constructor(name) {
    this.name = name;
  }
}

const SingleSomeClass = getSingleton(SomeClass);

const s1 = SingleSomeClass.getInstance('s1');
const s2 = SingleSomeClass.getInstance('s2');

console.log(s1 === s2); // true
</code></pre><p>也可以使用 JavaScript 闭包和高阶函数的特性来达到目的，注意使用此方式时，输入的构造函数只能为<strong>函数声明</strong>形式，因为<code>class</code>只能用<code>new SomeClass</code>的方式进行实例化。</p>
<pre  class="language-js"><code class="language-js">function getSingleton(ctor) {
  function Singleton(...args) {
    if (Singleton.instance) return Singleton.instance;
    ctor.apply(this, args); // 借用构造函数逻辑
    return (Singleton.instance = this);
  }
  Singleton.prototype = Object.create(ctor.prototype); // 维持原型链
  Singleton.instance = null;
  Singleton.getInstance = function(...args) {
    return Singleton.instance || new Singleton(...args);
  };
  return Singleton;
}
</code></pre><hr>
<h2 id="celvemoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'celvemoshi')">¶</a> 策略模式</h2>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。此模式使得算法和逻辑可独立于使用它的消费者而变化。</p>
</blockquote>
<p>策略模式在 JavaScript 应用非常广泛，最常见的就是表单校验，常见的数组的高阶函数 api <code>Array.prototype.sort</code>、<code>Array.prototype.map</code>等也是其中一种典型的体现。</p>
<pre  class="language-js"><code class="language-js">const arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10];

arr.sort((a, b) =&gt; a - b); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
arr.sort((a, b) =&gt; b - a); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</code></pre><p>通过不同的回调函数，将数组进行正向排序和反向排序，而两个回调函数就是独立的策略。</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ol>
<li>定义一组策略类，策略类封装了具体的算法，并负责具体的计算过程。</li>
<li>定义一个环境类 Context，Context 接受客户的请求，随后将请求委托给某一个策略类。</li>
</ol>
<p>策略模式在 JavaScript 中经常用于解决多重条件选择语句带来的强耦合问题。</p>
<pre  class="language-js"><code class="language-js">// 优化前
function func(condition) {
  if (condition === 'A') {
    // do some stuff ...
  } else if (condition === 'B') {
    // do some stuff ...
  } else if (condition === 'C') {
    // do some stuff ...
  } else if (condition === 'D') {
    // do some stuff ...
  }
}

// 优化后
const strategies = {
  A() {
    // do some stuff ...
  },
  B() {
    // do some stuff ...
  },
  C() {
    // do some stuff ...
  },
  D() {
    // do some stuff ...
  },
};

strategies[condition]();
</code></pre><h5 id="moshiyoudian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian')">¶</a> 模式优点：</h5>
<ul>
<li>利用组合、委托和多态等技术和思想，可有效避免多重条件选择语句。</li>
<li>提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得策略易于切换，易于理解，易于扩展。</li>
<li>算法可复用在其它地方，从而避免了许多重复的复制黏贴工作。</li>
<li>利用组合和委托来让 Context 拥有执行算法的能力，相对传统的继承来说更加轻便。</li>
</ul>
<h5 id="moshiquedian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian')">¶</a> 模式缺点：</h5>
<ul>
<li>会在程序中增加许多策略类或者策略对象，存在额外开销。</li>
<li>strategy 需要向消费者暴露所有实现，违反了最少知识原则。</li>
</ul>
<hr>
<h2 id="dailimoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dailimoshi')">¶</a> 代理模式</h2>
<blockquote>
<p>为一个对象提供一个代用品或占位符，以便控制对这个对象的访问。</p>
</blockquote>
<p>使用代理模式的主要目的是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求作出一些处理之后，再把请求转交给本体对象。</p>
<pre  class="language-text"><code class="language-text">客户 ====&gt; 本体 // 不使用代理模式
客户 ====&gt; 代理 ====&gt; 本体 // 使用代理模式
</code></pre><p>代理模式可以理解成，在目标对象之前架设一层「拦截」，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。因为代理对象对客户是透明的，所以代理对象必须实现与本体一致的接口。在最新的 ES6 语法中，已经实现了原生的<code>Proxy</code>，直接在“元编程”（meta programming）的层面对本体行为增加拦截。</p>
<pre  class="language-js"><code class="language-js">// 使用get拦截，实现数组读取负数的索引。
const arr = ['a', 'b', 'c'];

function createArray(arr) {
  const handler = {
    get(target, propKey, receiver) {
      const index = Number(propKey);
      if (index &lt; 0) {
        propKey = String(target.length + index);
      }
      return Reflect.get(target, propKey, receiver);
    },
  };

  return new Proxy(arr, handler);
}

let arrProxy = createArray(arr);
arrProxy[-1]; // c
arr[-1]; // undefined
</code></pre><hr>
<h2 id="diedaiqimoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'diedaiqimoshi')">¶</a> 迭代器模式</h2>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<p>迭代器可以分为外部迭代器和内部迭代器。</p>
<h5 id="neibudiedaiqi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'neibudiedaiqi')">¶</a> 内部迭代器</h5>
<p>内部迭代器的特点是外界跟迭代器的交互仅仅只是一次初始调用。</p>
<p>常见的数组的高阶函数 api <code>Array.prototype.forEach</code>、<code>Array.prototype.map</code>等就已经很好地实现了迭代器模式。</p>
<pre  class="language-js"><code class="language-js">const arr = [1, 2, 3];

arr.forEach((item, index) =&gt; {
  // do some stuff ...
});

// 手动实现内部迭代器
function each(arr, callback) {
  for (let i = 0; i &lt; arr.length; i++) {
    callback(arr[i], i, arr);
  }
}

each(arr, (item, index) =&gt; {
  // do some stuff ...
});
</code></pre><h5 id="waibudiedaiqi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'waibudiedaiqi')">¶</a> 外部迭代器</h5>
<p>外部迭代器的特点是必须显式地请求迭代下一个元素。它的迭代过程一般遵循下面四个步骤：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，迭代器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</li>
</ol>
<pre  class="language-js"><code class="language-js">const it = makeIterator(['hello', 'world', 'ending']);

it.next(); // { value: &quot;hello&quot;, done: false }
it.next(); // { value: &quot;world&quot;, done: false }
it.next(); // { value: &quot;ending&quot;, done: false }
it.next(); // { value: undefined, done: true }

function makeIterator(array) {
  let nextIndex = 0;
  return {
    next: function() {
      return nextIndex &lt; array.length ? { value: array[nextIndex++], done: false } : { value: undefined, done: true };
    },
  };
}
</code></pre><p>ES6 已经对外部迭代器进行了原生实现，它就是<code>Generator</code>。</p>
<pre  class="language-js"><code class="language-js">function* itGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

const it = itGenerator();
it.next(); // { value: 'hello', done: false }
it.next(); // { value: 'world', done: false }
it.next(); // { value: 'ending', done: true }
it.next(); // { value: undefined, done: true }

// 可以很方便地使用 for...of 进行迭代
for (let l of it) {
  console.log(l);
}
// hello world ending
</code></pre><hr>
<h2 id="fabudingyuemoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'fabudingyuemoshi')">¶</a> 发布订阅模式</h2>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。</p>
</blockquote>
<p>发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。又称为「观察者模式」。</p>
<p>它的特点是：</p>
<ul>
<li>可广泛应用于异步编程中，是一种替代传递回调函数的解决方案。</li>
<li>可取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。</li>
</ul>
<p>在 JavaScript 开发中，一般使用事件模型来替代传统的发布订阅模式。</p>
<pre  class="language-js"><code class="language-js">let i = 0;
document.body.addEventListener('click', () =&gt; {
  i++;
  console.log(`点击了 ${i} 次。`);
});

document.body.click(); // 点击了 1 次。
document.body.click(); // 点击了 2 次。
document.body.click(); // 点击了 3 次。
</code></pre><p>在 JavaScript 中实现一个自定义的发布订阅模式一般需要下面三个步骤：</p>
<ol>
<li>创建一个发布者；</li>
<li>在发布者内部创建一个缓存列表，用于存放回调函数以便通知订阅者；</li>
<li>在发布者内部创建一个遍历执行器函数，在发布消息（发生了指定的变化）时，依次触发缓存列表内订阅者的回调函数。</li>
</ol>
<pre  class="language-js"><code class="language-js">const event = {
  clientList: [], // 收集订阅回调
  // 订阅回调
  listen(key, fn) {
    if (!this.clientList[key]) {
      this.clientList[key] = [];
    }
  },
  // 取消订阅
  remove(key, fn) {
    const fns = this.clientList[key];
    if (!fns || fns.length === 0) {
      return false;
    }
    if (!fn) {
      fns &amp;&amp; (fns.length = 0);
      return;
    }
    const targetIndex = fns.findIndex(fnI =&gt; fnI === fn);
    ~targetIndex &amp;&amp; fns.splice(targetIndex, 1);
  },
  // 触发回调
  trigger(...args) {
    const key = args.shift();
    const fns = this.clientList[key];
    if (!fns || fns.length === 0) {
      return false;
    }
    fns.forEach(fn =&gt; fn.apply(null, args));
  },
};

// 动态安装发布订阅功能
const installEvent = function(obj) {
  for (let key in event) {
    obj[key] = event[key];
  }
};

// 使用
const source = {};
installEvent(source);

const typeACb = arg =&gt; console.log('typeA', arg);
const typeBCb = arg =&gt; console.log('typeB', arg);

source.listen('typeA', typeACb);
source.listen('typeB', typeBCb);

source.trigger('typeA', ' is trigger'); // typeA is trigger
source.trigger('typeB', ' is trigger'); // typeB is trigger
source.trigger('typeC', 'may cause error'); // false

source.remove('typeA', typeACb);
source.remove('typeB');
source.trigger('typeA', ' is trigger'); // false
source.trigger('typeB', ' is trigger'); // false
</code></pre><p>Nodes.js 中的 EventEmitter 就是一个经典的发布订阅模式的实现，它实质上是将发布订阅的逻辑抽离出来作为复用的通用函数，使发布者和订阅者呈松散耦合。</p>
<pre  class="language-js"><code class="language-js">class EventBus {
  constructor(evtMap = new Map()) {
    this.evtMap = evtMap;
  }
  // 添加订阅
  on(type, handler) {
    const handlers = this.evtMap.get(type);
    const added = handlers &amp;&amp; handlers.push(handler);
    !added &amp;&amp; this.evtMap.set(type, [handler]);
  }
  // 取消订阅
  off(type, handler) {
    const handlers = this.evtMap.get(type);
    if (!handlers) return false;
    if (!handler) {
      handlers.length = 0;
      return;
    }
    handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; 0, 1);
  }
  // 触发回调
  emit(type, evt) {
    (this.evtMap || []).forEach(handler =&gt; handler(evt));
  }
}

// 使用
const eventBus = EventBus();

eventBus.on('foo', e =&gt; console.log('foo', e)); // 订阅事件
eventBus.emit('foo', { a: 'b' }); // 触发事件
eventBus.evtMap.clear(); // 清除所有订阅

function onFoo() {}
eventBus.on('foo', onFoo); // 订阅
eventBus.off('foo', onFoo); // 取消订阅
</code></pre><h5 id="moshiyoudian-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian-2')">¶</a> 模式优点</h5>
<ul>
<li>时间上进行了解耦。</li>
<li>对象之间进行了解耦。</li>
</ul>
<h5 id="moshiquedian-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian-2')">¶</a> 模式缺点</h5>
<ul>
<li>需要额外消耗一定的时间和内存。</li>
<li>当订阅一个消息后，如果这个消息最后都未发生，这个订阅者却会一直存在于内存当中。</li>
</ul>
<hr>
<h2 id="minglingmoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'minglingmoshi')">¶</a> 命令模式</h2>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>从代码结构分析命令模式，其实它与策略模式很类似，都定义一系列的算法，把它们一个个封装起来，再根据实际的类型去调用它们。但是从行为分析会发现它们大大不同，命令模式会将所有发出的命令收集到一个命令队列，记录了这些命令的执行类型和顺序，必要时可对指定命令执行撤销操作或者对整个命令队列进行重放等。</p>
<p>下面是一个典型的编辑器例子：</p>
<pre  class="language-js"><code class="language-js">class TextEditor {
  constructor() {}
  copy() {
    console.log('editor copy!');
    // do some stuff...
  }
  paste() {
    console.log('editor paste!');
    // do some stuff...
  }
  delete() {
    console.log('editor delete!');
    // do some stuff...
  }
  insert() {
    console.log('editor insert!');
    // do some stuff...
  }
}

class CommandCollector {
  constructor(commandList = []) {
    this.commandList = commandList;
  }
  add(command) {
    this.commandList.push(command);
  }
  execute() {
    this.commandList.forEach(command =&gt; command.execute());
  }
}

function noop() {}

class Command {
  constructor(receiver = {}, commandType) {
    this.receiver = receiver;
    this.callback = receiver[commandType] || noop;
  }
  execute(...args) {
    this.callback(...args);
  }
}

const editor = new TextEditor();
const commandCollector = new CommandCollector();
const commands = ['copy', 'paste', 'delete', 'insert'];

commands.forEach(commandType =&gt; {
  const command = new Command(editor, commandType);
  command.execute(); // editor copy!
  // editor paste!
  // editor delete!
  // editor insert!
  commandCollector.add(command);
});

// 重播命令
commandCollector.execute(); // editor copy!
// editor paste!
// editor delete!
// editor insert!
</code></pre><hr>
<h2 id="zuhemoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zuhemoshi')">¶</a> 组合模式</h2>
<blockquote>
<p>将对象组合成树形结构以表示「部分-整体」的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>从上面的定义可以知道组合模式的两个特点：</p>
<ol>
<li><strong>表示树形结构</strong>。组合模式的「组合对象」由「叶对象」组成，形成一种特殊的树形结构，并提供了一种遍历树形结构的方案，通过调用组合对象的指定方法，递归调用下游「叶对象」同名方法。</li>
<li><strong>利用对象多态统一对待组合对象和单一对象</strong>。利用对象的多态表现，可以使客户端忽略组合对象和叶对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它是组合对象还是叶对象。</li>
</ol>
<pre  class="language-text"><code class="language-text">             ┌───────────┐
             │ Composite │ // 组合对象
             └───────────┘
                   ▲
      ┌────────────┼────────────┐
      │            │            │
┌───────────┐┌───────────┐┌───────────┐
│   leaf    ││   leaf    ││ Composite │
└───────────┘└───────────┘└───────────┘
                                ▲
                   ┌────────────┼────────────┐
                   │            │            │
             ┌───────────┐┌───────────┐┌───────────┐
             │   leaf    ││   leaf    ││   leaf    │ // 叶对象
             └───────────┘└───────────┘└───────────┘
</code></pre><p>关键的一点就是「组合对象」和「叶对象」具有统一的接口，并且「组合对象」由「叶对象」组成，下面是实现方式。</p>
<pre  class="language-js"><code class="language-js">class Composite {
  constructor(leavesMap = []) {
    if (new.target === Composite) {
      this.leavesMap = leavesMap;
    }
  }
  add(leaf) {
    this.leavesMap.push(leaf);
  }
  execute() {
    this.leavesMap.forEach(leaf =&gt; leaf.execute());
  }
}

function noop() {}

class Leaf extends Composite {
  constructor(callback = noop) {
    super();
    this.callback = callback;
  }
  add() {
    throw new Error('叶对象不能添加子结点'); // 统一接口，但需要限制叶结点不能调用 add 方法
  }
  execute() {
    this.callback();
  }
}

// 使用组合模式表示上图的树形结构
const com1 = new Composite();
const leaf1 = new Leaf(() =&gt; {
  console.log('leaf1 execute!');
});
const leaf2 = new Leaf(() =&gt; {
  console.log('leaf2 execute!');
});
const com2 = new Composite();
const leaf3 = new Leaf(() =&gt; {
  console.log('leaf3 execute!');
});
const leaf4 = new Leaf(() =&gt; {
  console.log('leaf4 execute!');
});
const leaf5 = new Leaf(() =&gt; {
  console.log('leaf5 execute!');
});

com1.add(leaf1);
com1.add(leaf2);
com1.add(com2);
com2.add(leaf3);
com2.add(leaf4);
com2.add(leaf5);

com1.execute(); // leaf1 execute!
// leaf2 execute!
// leaf3 execute!
// leaf4 execute!
// leaf5 execute!
</code></pre><hr>
<h2 id="mobanfangfamoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'mobanfangfamoshi')">¶</a> 模板方法模式</h2>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法模式的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，也即：<strong>父类定义骨架，子类实现某些细节</strong>。由此可知此模式主要由两部分结构构成：</p>
<ol>
<li><strong>抽象父类</strong>。通常在抽象父类中封装了子类的算法框架，包括实现了一些公共方法以及封装子类中所有方法的执行顺序。</li>
<li><strong>具体的实现子类</strong>。子类通过继承抽象父类的方式继承整个算法框架，并且可重写除公共方法以外的父类方法。</li>
</ol>
<p>传统 OOP 抽象类的主要作用是为它的子类定义公共接口，需要注意的是 JavaScript 不存在抽象类的概念（Typescript 实现了），所以没有办法从语言层面去强制子类重写一些细节方法。因此，必须使用在父类的细节方法定义里以抛出异常的方式去强制子类重写细节方法。</p>
<pre  class="language-js"><code class="language-js">class SuperClass {
  // 公共方法
  stepStart() {
    console.log('start');
  }
  // 细节方法
  stepSecond() {
    throw new Error('子类必须重写 stepSecond 方法');
  }
  // 细节方法
  stepThird() {
    throw new Error('子类必须重写 stepThird 方法');
  }
  // 公共方法
  stepEnd() {
    console.log('end');
  }
  // 定义算法
  run() {
    this.stepStart();
    this.stepSecond();
    this.stepThird();
    this.stepEnd();
  }
}

class SubClassA extends SuperClass {
  constructor() {
    super();
  }
  // 重写细节方法
  stepSecond() {
    console.log('subClassA step second');
  }
  // 重写细节方法
  stepThird() {
    console.log('subClassA step third');
  }
}

class SubClassB extends SuperClass {
  constructor() {
    super();
  }
  // 重写细节方法
  stepSecond() {
    console.log('subClassB step second');
  }
  // 重写细节方法
  stepThird() {
    console.log('subClassB step third');
  }
}

const subA = new SubClassA();
subA.run(); // start
// subClassA step second
// subClassA step third
// end

const subB = new SubClassB();
subB.run(); // start
// subClassA step second
// subClassA step third
// end
</code></pre><hr>
<h2 id="xiangyuanmoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangyuanmoshi')">¶</a> 享元模式</h2>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p>享元模式（Flyweight）是一种性能优化方案，当程序中需要用到大量相似的对象，而这些对象又可以区分出「内部状态」和「外部状态」的时候，就可以使用享元模式来共享单一实例。在实际使用具体对象的时候，通过将「外部状态」与单一实例进行实时组装，从而获得短暂可用的目标对象，在使用完目标对象后再还原成原来的单一实例（视实际情况）。</p>
<p>具体来说，判断一个业务场景时候适合使用享元模式来进行优化，一般需要满足以下几点：</p>
<ul>
<li>一个程序中使用了大量相似的对象。</li>
<li>由于使用了大量对象，造成很大的内存开销。</li>
<li>对象的大多数状态可以变为外部状态。</li>
<li>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。</li>
</ul>
<p>下面是一个文件上传功能的例子，这个文件上传功能具有多个上传类型，用户可以根据实际情况选择不同的上传类型。</p>
<pre  class="language-js"><code class="language-js">class Upload {
  constructor(uploadType) {
    this.uploadType = uploadType;
  }
  delFile(id) {
    uploadManager.setExternalState(id, this);
    if (this.fileSize &lt; 3000) {
      return this.dom.parentNode.removeChild(this.dom);
    }
    if (window.confirm(`Are sure to delete this file: ${this.dom}?`)) {
      return this.dom.parentNode.removeChild(this.dom);
    }
  }
}

const UploadFactory = {
  createdFlyweightObjs: {},
  create(uploadType) {
    if (this.createdFlyweightObjs[uploadType]) {
      return this.createdFlyweightObjs[uploadType];
    }
    return (this.createdFlyweightObjs[uploadType] = new Upload(uploadType));
  },
};

const UploadManager = {
  uploadDatabase: {},
  add(id, uploadType, filename, fileSize) {
    const flyweightObj = UploadFactory.create(uploadType);
    const dom = document.createElement('div');
    dom.innerHTML = `&lt;span&gt;File name: ${filename},File size: ${fileSize}&lt;/span&gt;
    &lt;button class=&quot;delFile&quot;&gt;Delete&lt;/button&gt;`;
    document.querySelector('.delFile').onclick = () =&gt; flyweightObj.delFile(id);
    document.body.appendChild(dom);
    uploadDatabase[id] = { filename, fileSize, dom };
    return flyweightObj;
  },
  setExternalState(id, flyweightObj) {
    const uploadData = this.database[id];
    for (let key in uploadData) {
      flyweightObj[key] = uploadData[key];
    }
  }
};

// 使用
let id = 0;
const startUpload = (uploadType, files) =&gt; {
  for(let i = 0, file; file = files[i++]) {
    uploadManager.add(++id, uploadType, file.filename, file.fileSize);
  }
}

startUpload('plugin', [{
  filename: '1.txt',
  fileSize: 1000,
},{
  filename: '2.txt',
  fileSize: 3000,
},{
  filename: '3.txt',
  fileSize: 5000,
}]);

startUpload('flash', [{
  filename: '4.txt',
  fileSize: 1000,
},{
  filename: '5.txt',
  fileSize: 3000,
},{
  filename: '6.txt',
  fileSize: 5000,
}]);
</code></pre><p>对于使用大量相似对象还有一种与享元模式类似的优化方案，它就是「对象池」。对象池维护了一个装载空闲对象的池子，如果需要对象的时候，不是直接创建新对象，而是先从对象池里获取，如果对象池里没有空闲对象，再去创建新对象，当创建的新对象完成了它的职责之后，再放入对象池等待被下次获取。这里需要注意的是，对象池没有分离内部状态和外部状态。</p>
<pre  class="language-js"><code class="language-js">function noop() {
  return {};
}

class ObjectPool {
  constructor(creator = noop, pool = []) {
    this.pool = pool;
    this.creator = creator;
  }
  getObject(...args) {
    return this.pool.shift() || this.creator(...args);
  }
  recoverObject(poolItem) {
    this.pool.push(poolItem);
  }
}

function createIframe() {
  const iframe = document.createElement('iframe');
  document.body.appendChild(iframe);

  iframe.onload = () =&gt; {
    iframe.onload = null;
    iframePool.recoverObject(iframe); // 加载完成后回收
  };

  return iframe;
}

const iframePool = new ObjectPool(createIframe);

const iframe1 = iframePool.getObject();
iframe1.src = 'https://lkangd.com/';

const iframe2 = iframePool.getObject();
iframe2.src = 'https://github.com/';

setTimeout(() =&gt; {
  const iframe3 = iframePool.getObject();
  iframe3.src = 'https://google.com/';
}, 3000);
</code></pre><hr>
<h2 id="zhizelianmoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhizelianmoshi')">¶</a> 职责链模式</h2>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象炼成一条链，并沿着这条链传递改请求，知道有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。</p>
<p>职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接受者之间的强联系。</p>
<pre  class="language-text"><code class="language-text">     ┌─────────┐
     │ Request │
     └─────────┘
          │
┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐ ─ ─ ─ ─┐
          ▼
│  ┌─────────────┐  │        │
   │ ProcessorA  │
│  └─────────────┘  │        │
          │
│         ▼         │        │
   ┌─────────────┐
│  │ ProcessorB  │  │   HandlerChain
   └─────────────┘
│         │         │        │
          ▼
│  ┌─────────────┐  │        │
   │ ProcessorC  │
│  └─────────────┘  │        │
          │
└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘ ─ ─ ─ ─┘
          │
          ▼
</code></pre><p>使用代码现实上图。</p>
<pre  class="language-js"><code class="language-js">class Request {
  constructor(amount = 0) {
    this.amount = amount;
  }
  getAmount() {
    return this.amount;
  }
}

class HandlerChain {
  constructor(handlers = []) {
    this.handlers = [];
  }
  addHandler(handler) {
    this.handlers.push(handler);
  }
  process(...args) {
    for (let i = 0, handler; (handler = this.handlers[i++]); ) {
      const result = handler.process(...args);
      if (result !== null) {
        return result;
      }
    }
    throw new Error(`Could not handle request: ${args}`);
  }
}

class ProcessorA {
  constructor() {}
  process(request) {
    if (request.getAmount() &gt; 1000) return null; // 设置职责门槛
    console.log('ProcessorA success!');
  }
}
class ProcessorB {
  constructor() {}
  process(request) {
    if (request.getAmount() &gt; 2000) return null; // 设置职责门槛
    console.log('ProcessorB success!');
  }
}
class ProcessorC {
  constructor() {}
  process(request) {
    if (request.getAmount() &gt; 3000) return null; // 设置职责门槛
    console.log('ProcessorC success!');
  }
}

// 使用
const chain = new HandlerChain();
// 设置职责链，注意顺序
chain.addHandler(new ProcessorA());
chain.addHandler(new ProcessorB());
chain.addHandler(new ProcessorC());

const req1 = new Request(999);
const req2 = new Request(1999);
const req3 = new Request(2999);
const req4 = new Request(3001); // 超出职责范围

chain.process(req1); // ProcessorA success!
chain.process(req2); // ProcessorB success!
chain.process(req3); // ProcessorC success!
chain.process(req4); // Uncaught Error: Could not handle request: [object Object]
</code></pre><hr>
<h2 id="zhongjiezhemoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhongjiezhemoshi')">¶</a> 中介者模式</h2>
<blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p>
</blockquote>
<p>中介者模式（Mediator）的作用是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是相互作用，所以当一个对象发生改变时，只需要通知中介者即可。</p>
<p>使用中介者之前对象间相互影响。</p>
<pre  class="language-text"><code class="language-text">┌─────────────────┐     ┌─────────────────┐
│        A        │&lt;───&gt;│        B        │
└─────────────────┘     └─────────────────┘
         ▲ ▲                     ▲
         │ └─────────────────────┤
         ▼                       │
┌─────────────────┐     ┌────────┴────────┐
│        C        │&lt;────│        D        │
└─────────────────┘     └─────────────────┘
</code></pre><p>使用中介者后对象只与中介者交互，从而解除了对象间的强耦合关系。</p>
<pre  class="language-text"><code class="language-text">            ┌─────────────────┐
     ┌─────&gt;│        A        │
     │      └─────────────────┘
     │      ┌─────────────────┐
     │ ┌───&gt;│        B        │
     ▼ ▼    └─────────────────┘
┌─────────┐
│  中介者  │
└─────────┘
     ▲ ▲    ┌─────────────────┐
     │ └───&gt;│        C        │
     │      └─────────────────┘
     │      ┌─────────────────┐
     └─────&gt;│        D        │
            └─────────────────┘
</code></pre><p>使用代码现实上图。</p>
<pre  class="language-js"><code class="language-js">// 使用中介者模式前
class Node {
  constructor(status = true, influenceNodes = []) {
    this.status = status;
    this.influenceNodes = influenceNodes;
  }
  addInfluence(node) {
    this.influenceNodes.push(node);
  }
  change(status) {
    const newStatus = status === undefined ? !this.status : status;
    this.status = newStatus;
    this.influenceNodes.forEach(node =&gt; (node.status = !newStatus));
  }
}

const A = new Node(false);
const B = new Node();
const C = new Node();
const D = new Node();

// A 影响 B, C
A.addInfluence(B);
A.addInfluence(C);
// B 影响 A
B.addInfluence(A);
// C 影响 A
C.addInfluence(A);
// D 影响 A, B, C
D.addInfluence(A);
D.addInfluence(B);
D.addInfluence(C);

A.change();
console.log(A.status, B.status, C.status, D.status); // true, false, false, true

D.change();
console.log(A.status, B.status, C.status, D.status); // true, true, true, false
</code></pre><pre  class="language-js"><code class="language-js">// 引入中介者
class Node {
  constructor(type, status = true) {
    this.status = status;
    this.type = type;
  }
  change(status) {
    const newStatus = status === undefined ? !this.status : status;
    this.status = newStatus;
  }
}

const A = new Node('A', false);
const B = new Node('B');
const C = new Node('C');
const D = new Node('D');

// 将对象间影响的逻辑封装到中介者
const mediator = function(node) {
  const newStatus = !node.status;
  switch (node.type) {
    case 'A': // A 影响 B, C
      B.change(newStatus);
      C.change(newStatus);
      break;
    case 'B': // B 影响 A
      A.change(newStatus);
      break;
    case 'C': // C 影响 A
      A.change(newStatus);
      break;
    case 'D': // D 影响 A, B, C
      A.change(newStatus);
      B.change(newStatus);
      C.change(newStatus);
      break;
    default:
      console.log('unsupported type!', node.type);
  }
};

A.change();
mediator(A);
console.log(A.status, B.status, C.status, D.status); // true, false, false, true

D.change();
mediator(D);
console.log(A.status, B.status, C.status, D.status); // true, true, true, false
</code></pre><hr>
<h2 id="zhuangshizhemoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhuangshizhemoshi')">¶</a> 装饰者模式</h2>
<blockquote>
<p>在不改变对象的基础上，动态地给对象添加一些额外的职责。就增加功能而言，相比生成子类更加灵活。</p>
</blockquote>
<p>装饰器（Decorator）模式的核心思想与流行的 AOP（面向切面）编程方法论是一致的，目的都是为了在不改变对象本身的前提上，在对象方法的出入口去改变方法的行为。</p>
<pre  class="language-js"><code class="language-js">// 入口切面
Function.prototype.before = function(beforeFn) {
  const originFn = this;
  return function(...args) {
    beforeFn.apply(this, args);
    return originFn.apply(this, args);
  };
};

// 出口切面
Function.prototype.after = function(afterFn) {
  const originFn = this;
  return function(...args) {
    const ret = originFn.apply(this, args);
    afterFn.call(this, ret);
    return ret;
  };
};

function execute(number) {
  console.log('execute!');
  return number * number;
}

execute(10); // execute! 100

function logBefore(number) {
  console.log('before fn log, number is:', number);
}
function logAfter(result) {
  console.log('after fn log, result is:', result);
}

execute.before(logBefore)(10); // before fn log, number is: 10
// execute!

execute.after(logAfter)(10); // execute!
// after fn log, result is: 100

execute.before(logBefore).after(logAfter)(10); // before fn log, number is: 10
// execute!
// after fn log, result is: 100
</code></pre><p>最新的 ES <a href="https://github.com/tc39/proposal-decorators" target="_blank">提案</a> 里已经实现了原生的装饰器语法，ES 的装饰器可以很便捷地修改类和类方法的行为。</p>
<pre  class="language-js"><code class="language-js">function log(target, name, descriptor) {
  const oldValue = descriptor.value;

  descriptor.value = function() {
    console.log(`Calling ${name} with`, arguments);
    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

const math = new Math();

math.add(2, 4); // Calling add with 2, 4
</code></pre><hr>
<h2 id="zhuangtaimoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhuangtaimoshi')">¶</a> 状态模式</h2>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式（State）经常用在带有状态的对象中，可以按两个部分来理解上面的定义：</p>
<ol>
<li>将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。</li>
<li>从客户的角度来看，使用对象时，在不同状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。</li>
</ol>
<p>传统的面向对象语言的状态模式实现会为每种状态定义一个状态子类，然后在 Context 中持有这些状态对象的引用，以便把当前状态切换为当前的状态对象。但在 JavaScript 这种“无类”语言中，没有规定让状态对象一定要从类中创建出来。另外一点，JavaScript 可以非常方便地使用委托技术，并不需要事先让一个对象只有另一个对象。下面是 JavaScript 对状态模式的实现。</p>
<pre  class="language-js"><code class="language-js">// 一个使用状态模式的开关灯程序
const delegate = function(client, delegation) {
  return {
    // 将客户的操作委托给 delegation 对象
    buttonWasPressed() {
      return delegation.buttonWasPressed.apply(client, arguments);
    },
  };
};

// 状态类封装
const FSM = {
  off: {
    buttonWasPressed() {
      console.log('关灯');
      this.button.innerHTML = '下一次按我就是开灯。';
      this.currentState = this.onState;
    },
  },
  on: {
    buttonWasPressed() {
      console.log('开灯');
      this.button.innerHTML = '下一次按我就是关灯。';
      this.currentState = this.offState;
    },
  },
};

class Light {
  constructor() {
    this.offState = delegate(this, FSM.off);
    this.onState = delegate(this, FSM.on);
    this.currentState = this.offState; // 设置初始状态为关闭状态
    this.button = null;
  }
  init() {
    const button = document.createElement('button');
    button.innerHTML = '已关灯';
    this.button = document.body.appendChild(button);
    this.button.onclick = function() {
      this.currentState.buttonWasPressed();
    }.bind(this);
  }
}

const light = new Light();
light.init();

light.button.click(); // 开灯
light.button.click(); // 关灯
</code></pre><h5 id="moshiyoudian-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiyoudian-3')">¶</a> 模式优点</h5>
<ul>
<li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。</li>
<li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过于多的条件分支。</li>
<li>用对象代替字符串记录当前状态，是的状态的切换更加一目了然。</li>
<li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而不受影响。</li>
</ul>
<h5 id="moshiquedian-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'moshiquedian-3')">¶</a> 模式缺点</h5>
<ul>
<li>定义了许多状态类，因此系统中会增加不少对象。</li>
<li>虽然避开了不受欢迎的条件分支，但也造成了逻辑松散的问题，无法在一个地方就看出这个状态机的逻辑。</li>
</ul>
<hr>
<h2 id="shipeiqimoshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shipeiqimoshi')">¶</a> 适配器模式</h2>
<blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器（Adapter）模式的别名是包装器（wrapper），是一个相对简单的模式，它作用是解决两个软件之间接口不兼容的问题，使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配器模式是一种“亡羊补牢”的模式，一般不会在程序设计之初就是用它。</p>
<pre  class="language-js"><code class="language-js">class NormalProcessor {
  constructor(action) {
    this.action = action;
  }
  show() {
    console.log('start doing ', this.action);
  }
}

const makeAction = processor =&gt; processor.show(); // 原有逻辑
const processors = [new NormalProcessor('stand'), new NormalProcessor('walk')];

processors.forEach(p =&gt; makeAction(p)); // stand walk

// 非兼容接口
class IncompatibleProcessor {
  constructor(action) {
    this.action = action;
  }
  display() {
    console.log('start doing ', this.action);
  }
}

const runProcessor = new IncompatibleProcessor('run');

processors.push(runProcessor);
processors.forEach(p =&gt; makeAction(p)); // stand walk Uncaught TypeError: processor.show is not a function

// 生成一个适配器对象
const makeAdapter = (originObj, originFnName, adapterFnName) =&gt; {
  return {
    [adapterFnName](...args) {
      return originObj[originFnName](...args);
    },
  };
};

const runProcessorAdapter = makeAdapter(runProcessor, 'display', 'show');
processors.splice(processors.length - 1, 1, runProcessorAdapter);
processors.forEach(p =&gt; makeAction(p)); // stand walk run
</code></pre><hr>
<h2 id="jieyan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyan')">¶</a> 结言</h2>
<p>所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部分封装起来，那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。这也是设计模式为什么描写的是可复用面向对象软件基础的原因。</p>
<p>学习设计模式时不应该根据模式的名字去臆测该模式的一切，而是要理解模式具体能解决的问题和改模式的适用场景，才能避免对模式的滥用和误用，让模式为开发赋能。</p>
<h4 id="cankao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cankao')">¶</a> 参考</h4>
<p><a href="https://book.douban.com/subject/26382780/" target="_blank">JavaScript 设计模式与开发实践</a><br>
<a href="https://book.douban.com/subject/1436745/" target="_blank">Design Patterns</a><br>
<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528" target="_blank">设计模式-廖雪峰</a><br>
<a href="https://es6.ruanyifeng.com/" target="_blank">ES6入门教程-阮一峰</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[何为「Git Commit」最佳姿势？]]></title>
            <link>/post/develop-good-git-commit-habits/</link>
            <guid>/post/develop-good-git-commit-habits/</guid>
            <description><![CDATA[让你的每一个「Git Commit」更有价值，而不是形式主义下的流水账]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#xiancongtijiaogeshirushou">先从提交格式入手</a><ul><li><a href="#Commitmessagedegeshi">Commit message 的格式</a></li><li><a href="#shiyongtijiaofuzhugongju">使用提交辅助工具</a></li><li><a href="#qiangzhixiaoyantijiaogeshi">强制校验提交格式</a></li></ul></li><li><a href="#guifanhebingtuisongliucheng">规范合并推送流程</a><ul><li><a href="#shiyongrebasehebing">使用 rebase 合并</a></li><li><a href="#yuanchengmasterfenzhiquanxiankongzhi">远程 master 分支权限控制</a></li><li><a href="#helifencha">合理分叉</a></li></ul></li><li><a href="#jieyan">结言</a></li></ul></div></p>
<p>大部分技术团队都会选择 git 来作为代码库的版本管理工具，但是由于规范的缺失和技术人员 git 技能不达标的原因，很容易写出很敷衍潦草的「commit」描述和随意地合并推送到远程分支，导致「git log」日志看起来乱糟糟的。在项目工程化的角度而言，一个规范清晰的的「git log」日志是很重要的，因为它反映了项目是如何紧跟业务进行一步步迭代下来的，就像是软件开发的航海日志、黑匣子，在遇到「风浪」时，能快速定位问题和进行版本回退。</p>
<p>首先来看一段 <a href="https://github.com/vuejs/vue" target="_blank">Vue</a> 的「git log」记录，它长这样：</p>
<pre  class="language-bash"><code class="language-bash">* 7721febc (tag: v2.6.0-beta.3) build: release 2.6.0-beta.3 - Evan You, 1 year, 5 months ago
* 9f3cbafa build: build 2.6.0-beta.3 - Evan You, 1 year, 5 months ago
* 2afa1d05 build: fix feature flags for esm builds - Evan You, 1 year, 5 months ago
* c9e3a5d1 feat: detect and warn invalid dynamic argument expressions - Evan You, 1 year, 5 months ago
* 624c7993 (tag: v2.6.0-beta.2) build: release 2.6.0-beta.2 - Evan You, 1 year, 5 months ago
* 90f47d1b build: build 2.6.0-beta.2 - Evan You, 1 year, 5 months ago
* dbc05825 feat: dynamic directive arguments for v-on, v-bind and custom directives (#9373) - Evan You, 1 year, 5 months ago
* f219beda perf: improve scoped slots change detection accuracy (#9371) - Evan You, 1 year, 5 months ago
| * 8b8921b2 (origin/dynamic-directive-arguments) feat: dynamic args for custom directives - Evan You, 1 year, 5 months ago
| * 2910d401 test: test cases for v-on/v-bind dynamic arguments - Evan You, 1 year, 5 months ago
| * 49c6f29f refactor: v-bind dynamic arguments use bind helper - Evan You, 1 year, 5 months ago
| * 5b5f6663 test: fix tests, resolve helper conflict - Evan You, 1 year, 5 months ago
| * 2ba897eb fix: fix middle modifier - Evan You, 1 year, 5 months ago
| * 5cb59b1f feat: handle dynamic argument for v-bind.sync - Evan You, 1 year, 5 months ago
| * c6f480ca feat: dynamic directive arguments for v-bind and v-on - Evan You, 1 year, 5 months ago
|/
| * d91a38ab (origin/slot-optimization) perf: improve scoped slots change detection accuracy - Evan You, 1 year, 5 months ago
|/
* 770c6ed6 refactor: extend dom-props update skip to more all keys except value - Evan You, 1 year, 5 months ago
* 18685614 fix: fix checkbox event edge case in Firefox - Evan You, 1 year, 5 months ago
* 8cb2069a test: fix tests in IE/Edge - Evan You, 1 year, 5 months ago
* 32072e8a refactor: simplify timestamp check - Evan You, 1 year, 5 months ago
* 60a277ca chore: update comment - Evan You, 1 year, 5 months ago
* ba0ebd47 fix: async edge case fix should apply to more browsers - Evan You, 1 year, 5 months ago
* ba9907c7 chore: update sponsor - Evan You, 1 year, 6 months ago
* 8d845724 feat: warning for ambiguous v-slot usage - Evan You, 1 year, 6 months ago
</code></pre><p>提交描述清晰，规范整洁。</p>
<p>但是我们看过的大多数「git log」日志却是下面这样的：</p>
<pre  class="language-bash"><code class="language-bash">| * | | | | | | e63cdb7f htmlPlugin baseConf 中引入 - lisi, 8 months ago
| * | | | | | |   d6481470 Merge remote-tracking branch 'origin/master' into build-merge - lisi, 8 months ago
| |\ \ \ \ \ \ \
| * | | | | | | | 551b601b 商品详情富文本图片懒加载 - lisi, 8 months ago
| * | | | | | | |   804b8589 Merge branch 'master' into build-merge - lisi, 8 months ago
| |\ \ \ \ \ \ \ \
| * | | | | | | | | dd7b66b9 cacheLoader - lisi, 8 months ago
| * | | | | | | | | 0e91b705 构建脚本 - lisi, 8 months ago
| * | | | | | | | | 552d8576 sass 深度选择器 /deep/ =&gt; &gt;&gt;&gt; - lisi, 8 months ago
| * | | | | | | | | f29a0dbb 改目录结构 - lisi, 8 months ago
* | | | | | | | | |   a930dda2 (tag: v20191119) Merge branch 'alipayFix' into 'master' - wangwu, 8 months ago
|\ \ \ \ \ \ \ \ \ \
| |_|_|/ / / / / / /
|/| | | | | | | / /
| | |_|_|_|_|_|/ /
| |/| | | | | | |
| * | | | | | | | 2d29a500 支付宝提示文案 - lisi, 8 months ago
| | |_|_|_|_|/ /
| |/| | | | | |
| * | | | | | | a6313a9e 混合支付 支付宝提示框 - lisi, 8 months ago
| | |_|_|_|/ /
| |/| | | | |
| * | | | | | 75b452e3 默认选中支付方式 - lisi, 8 months ago
| | |_|_|/ /
| |/| | | |
| * | | | | a1d3de5e payTypeShow 隐藏支付宝 - lisi, 8 months ago
| | |_|/ /
| |/| | |
| * | | | a0358dde 下线 支付宝支付 - lisi, 8 months ago
|/ / / /
* | | |   6be57861 Merge branch 'patch-1' into 'master' - zhangsan, 8 months ago
|\ \ \ \
| |_|/ /
|/| | |
| * | | 4e8f204b (origin/patch-1) 去营销 - zhangsan, 8 months ago
|/ / /
* | |   18ea26e4 Merge branch '20191114' into 'master' - zhangsan, 8 months ago
|\ \ \
| * | | d03b6d09 (origin/20191114) getKamiGoodsSpu - lisi, 8 months ago
</code></pre><p>多个提交出现了类似 “cacheLoader” 这样看起来莫名其妙的描述，过期的分支没有及时删除，多分支合并扰乱视线，整个记录看起来就像是一张「蜘蛛网」，如果要回溯一个业务功能的迭代过程，会让人很抓狂。</p>
<p>仔细观察 Vue 的「git log」日志，不难发现它的的优点主要有四个：</p>
<ul>
<li><strong>Commit 描述清晰，第一个单词说明此次提交的类别，后续描述第一个单词以 <strong><em>动词</em></strong>（一般现在时）开头；</strong></li>
<li><strong>整个记录随合并时间呈 <strong><em>单支线性</em></strong> 向上累加，没有出现过期的，扰乱视线的分叉；</strong></li>
<li>如果是 issue 相关，每个提交后面会紧跟 issue 的 hash tag（可选）；</li>
<li>当需要发布版本时，以版本号打上 tag 标记（可选）；</li>
<li>除了简短描述外，还有详细的描述（可选）；</li>
</ul>
<p>第三点到最后一点都是可选的，只要做到前面点就可以拥有一份整洁清晰的「git log」记录了，下面开始对实现这两点的方式进行探讨。</p>
<h2 id="xiancongtijiaogeshirushou"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiancongtijiaogeshirushou')">¶</a> 先从提交格式入手</h2>
<p>那么 vue 是怎么做到提交格式这么规范统一的呢？作为多人协作的开源库，靠约定和人为自觉肯定是不现实的。打开 vue 项目的 package.json 可以发现几个关键的地方，vue 使用了<a href="https://github.com/commitizen/cz-cli" target="_blank">「commitizen」</a>来代替「git commit」进行代码提交，使用<a href="https://github.com/commitizen/cz-conventional-changelog" traget="_blank">「cz-conventional-changelog」</a>来指定「commitizen」的 Adapter。最后，在 git 的<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank">「commit-msg」钩子</a>指定了一个「commit」描述验证脚本<a href="https://github.com/vuejs/vue/blob/dev/scripts/verify-commit-msg.js" target="_blank">verify-commit-msg.js</a>，当脚本返回的值以非零值退出，就会提交失败，以一种强制的方式进行把关。</p>
<pre  class="language-json"><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;commit&quot;: &quot;git-cz&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;commitizen&quot;: &quot;^2.9.6&quot;,
    &quot;conventional-changelog&quot;: &quot;^1.1.3&quot;,
    &quot;cz-conventional-changelog&quot;: &quot;^2.0.0&quot;
  },
  &quot;gitHooks&quot;: {
    &quot;commit-msg&quot;: &quot;node scripts/verify-commit-msg.js&quot;
  },
  &quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;
    }
  }
}
</code></pre><h3 id="Commitmessagedegeshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Commitmessagedegeshi')">¶</a> Commit message 的格式</h3>
<p>首先来说说格式的规范，目前社区有很多「Commit message」的写法规范，从 vue 的 package.json 使用的<a href="https://github.com/commitizen/cz-conventional-changelog" traget="_blank">「cz-conventional-changelog」</a>可以得知，vue 使用的是<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank">Angular 规范</a>。</p>
<p>Angular 规范指定了「Commit message」包括三个部分：Header，Body 和 Footer。</p>
<pre  class="language-xml"><code class="language-xml">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre><h4 id="Header"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Header')">¶</a> Header</h4>
<p>Header 部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<p><strong>1.<code>type</code>用于说明 commit 的类别，只允许使用下面 7 个标识:</strong></p>
<pre  class="language-bash"><code class="language-bash">- feat：新功能（feature）
- fix：修补bug
- docs：文档（documentation）
- style： 格式（不影响代码运行的变动）
- refactor：重构（即不是新增功能，也不是修改bug的代码变动）
- perf: 性能优化
- test：增加测试
- chore：构建过程或辅助工具的变动
</code></pre><p><strong>2.<code>scope</code>用于说明此次提交影响的范围，比如数据层、控制层、视图层等等，视项目而定。</strong></p>
<p><strong>3.<code>subject</code>是 commit 目的的简短描述，不超过 <strong><em>100</em></strong> 个字符。</strong></p>
<pre  class="language-bash"><code class="language-bash">- 以动词开头，使用第一人称现在时，比如change，而不是changed或changes
- 第一个字母小写
- 结尾不加句号（.）
</code></pre><h4 id="Body"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Body')">¶</a> Body</h4>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。取一个 vue 的提交作为例子：</p>
<pre  data-line="7-10,12-17" class="language-bash"><code data-line="7-10,12-17" class="language-bash">* commit b9de23b1008b52deca7e7df40843e318a42f3f53
| Author: Evan You &lt;yyx990803@gmail.com&gt;
| Date:   Tue Feb 5 22:16:55 2019 -0500
|
|     fix: async component should use render owner as force update context
|
|     Previously, an async component uses its lexical owner as the force
|     update context. This works when the async component is rendered in a
|     scoped slot because in the past parent components always force update
|     child components with any type of slots.
|
|     After the optimization in
|     f219bed though, child components with only scoped slots are no longer
|     force-updated, and this cause async components inside scoped slots to
|     not trigger the proper update. Turns out they should have used the
|     actual render owner (the component that invokes the scoped slot) as the
|     force update context all along.
|
|     fix #9432
</code></pre><p>这里有几个注意的点：</p>
<ul>
<li>动词使用第一人称现在时，使用 fix, add, change 而不是 fixed, added, changed</li>
<li>第二行是空行</li>
<li>用换行来分割提交信息</li>
<li>说明代码变动的动机，以及与以前行为的对比</li>
</ul>
<h4 id="Footer"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Footer')">¶</a> Footer</h4>
<p>Footer 部分可能会存在两种情况。</p>
<h6 id="1bujianrongbiandong"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'1bujianrongbiandong')">¶</a> 1.不兼容变动</h6>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<pre  data-line="11" class="language-bash"><code data-line="11" class="language-bash">* commit 8bbd337eab7d54c82327159c41ac975f805e28f5 (HEAD -&gt; master)
| Author: CurtisLiong &lt;lkangd@gmail.com&gt;
| Date:   Thu Jul 9 19:13:49 2020 +0800
|
|     feat(scope): here is a short description
|
|     here is the first paragraph.
|
|     here is the second paragraph.
|
|     BREAKING CHANGE: here is a description about breaking changes
|
|     fix #123
</code></pre><h6 id="2guanbiIssue"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'2guanbiIssue')">¶</a> 2.关闭 Issue</h6>
<p>如果当前 commit 针对某些 issue，那么可以在 Footer 部分关闭这些相关的 issue。</p>
<pre  data-line="13" class="language-bash"><code data-line="13" class="language-bash">* commit 8bbd337eab7d54c82327159c41ac975f805e28f5 (HEAD -&gt; master)
| Author: CurtisLiong &lt;lkangd@gmail.com&gt;
| Date:   Thu Jul 9 19:13:49 2020 +0800
|
|     feat(scope): here is a short description
|
|     here is the first paragraph.
|
|     here is the second paragraph.
|
|     BREAKING CHANGE: here is a description about breaking changes
|
|     fix #123, #456
</code></pre><h4 id="teshuqingkuang"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'teshuqingkuang')">¶</a> 特殊情况</h4>
<p>「cz-conventional-changelog」的实现对前面 Header 的<code>type</code>部分增加了选项：</p>
<pre  class="language-bash"><code class="language-bash">- build：影响构建系统或外部依赖项的更改（如：gulp，webpack，npm）
- ci：构建过程或辅助工具的变动
- revert：恢复到之前的提交
</code></pre><p>其中使用 revert 时以<code>Revert</code>开头，后面跟着被撤销的 commit 的 Header，在 Footer 部分添加恢复的 commit 的 hash 号。</p>
<pre  data-line="7" class="language-bash"><code data-line="7" class="language-bash">* commit 80cc0a1f176f4eb6186d482e578a87af69b22b6d (HEAD -&gt; master)
| Author: CurtisLiong &lt;lkangd@gmail.com&gt;
| Date:   Thu Jul 9 19:42:57 2020 +0800
|
|     Revert &quot;feat(scope): here is a short description&quot;
|
|     This reverts commit 8bbd337eab7d54c82327159c41ac975f805e28f5.
</code></pre><h3 id="shiyongtijiaofuzhugongju"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shiyongtijiaofuzhugongju')">¶</a> 使用提交辅助工具</h3>
<p>了解了规范之后，接下来就是用工具来帮助我们提交时严格执行规范。这里主要介绍「commitizen」的使用。</p>
<h4 id="Commitizen"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Commitizen')">¶</a> Commitizen</h4>
<p>先使用 npm 命令进行安装，可进行全局安装或者根据项目安装,</p>
<p>全局安装：</p>
<pre  class="language-bash"><code class="language-bash"># 安装 commitizen 和 cz-conventional-changelog
npm i -g commitizen cz-conventional-changelog
</code></pre><p>在系统用户目录下创建.czrc 文件，并输入一下内容：</p>
<pre  class="language-json"><code class="language-json">{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }
</code></pre><p>项目安装：</p>
<pre  class="language-bash"><code class="language-bash"># 安装 commitizen 和 cz-conventional-changelog
npm i commitizen cz-conventional-changelog -D
</code></pre><p>然后在项目目录中的 package.json 文件内配置以下内容：</p>
<pre  class="language-json"><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;commit&quot;: &quot;git-cz&quot;
  },
  &quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;
    }
  }
}
</code></pre><p>提交的时候使用<code>git cz</code>（全局）或者<code>npm run commit</code>（项目）来代替<code>git commit</code>，效果如下：</p>
<p><img src="_nuxt/img/pic-git-commitizen.b98d059.png" alt=""></p>
<p>「commitizen」提供了一个交互式的 git 提交流程，保证了提交者不会因为一时疏忽而做出违反规范的提交行为。</p>
<h3 id="qiangzhixiaoyantijiaogeshi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'qiangzhixiaoyantijiaogeshi')">¶</a> 强制校验提交格式</h3>
<p>上面提到 vue 会在「commit-msg」钩子校验提交格式是否合格。如果你也想更进一步，可以使用<a href="https://github.com/conventional-changelog/commitlint#readme" target="_blank">「commitlint」</a>结合 <a href="https://github.com/typicode/husky#readme" target="_blank">「husky」</a>来进行强制校验提交格式。</p>
<ol>
<li>安装依赖：</li>
</ol>
<pre  class="language-bash"><code class="language-bash">npm i @commitlint/cli @commitlint/config-conventional husky -D
</code></pre><ol start="2">
<li>在项目根目录创建 commitlint 配置文件：commitlint.config.js：</li>
</ol>
<pre  class="language-javascript"><code class="language-javascript">module.exports = {
  extends: ['@commitlint/config-conventional'], // @commitlint/config-conventional Angular 规范
};
</code></pre><ol start="3">
<li>在项目根目录创建 husky 配置文件：husky.config.js：</li>
</ol>
<pre  class="language-javascript"><code class="language-javascript">module.exports = {
  hooks: {
    'commit-msg': 'commitlint -E HUSKY_GIT_PARAMS', // 在 commit-msg 钩子校验提交格式
  },
};
</code></pre><hr>
<h2 id="guifanhebingtuisongliucheng"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guifanhebingtuisongliucheng')">¶</a> 规范合并推送流程</h2>
<p>解决了「commit」格式规范的问题之后，接下来就是分支合并的事情了。一般情况下，开发者在本地进行新需求的开发或者 bug 修复之后，需要合并分支到测试分支或者远端主分支。常规会进行一下命令：</p>
<pre  class="language-bash"><code class="language-bash">~/FE-Project/git-test&gt;git branch # 查看当前分支
* feature-some
  master
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git merge feature-some # 合并功能分支，此时可能需要解决冲突
~/FE-Project/git-test&gt;git pull # 拉取最新的远端主分支代码，此时可能需要解决冲突
~/FE-Project/git-test&gt;git push # 推送分支，此时如果又有人更新代码的话，需要重新拉取解决冲突后才能推送
</code></pre><p>此时，按照 git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），git 会执行一次 merge 操作，因此产生一次没意义的提交记录，从而产生了下面所示的混乱。</p>
<pre  data-line="2" class="language-bash"><code data-line="2" class="language-bash">| * | | | | | | e63cdb7f htmlPlugin baseConf 中引入 - lisi, 8 months ago
| * | | | | | |   d6481470 Merge remote-tracking branch 'origin/master' into build-merge - lisi, 8 months ago
| |\ \ \ \ \ \ \
| * | | | | | | | 551b601b 商品详情富文本图片懒加载 - lisi, 8 months ago
| * | | | | | | |   804b8589 Merge branch 'master' into build-merge - lisi, 8 months ago
</code></pre><p>产生这个原因的本质原因是，<code>git pull</code>命令其实是一个组合命令，在你敲下回车时，这个命令会依次执行两个命令：</p>
<pre  class="language-bash"><code class="language-bash">git fetch # 拉取远程代码
git merge # 将远程分支与本地分支合并
</code></pre><p>用线图表示就像是这样的，其中<code>F'</code>就是类似<code>Merge remote-tracking branch 'origin/master' into ...</code>的记录：</p>
<pre  class="language-bash"><code class="language-bash"># after feature-some committed
A---B---C origin/master

A---B master
     \
      D---E feature-some

# after feature-some merge to master
A---B---C origin/master

A---B---D---E master
     \
      D---E feature-some

# after master pull
      A---B---C origin/master
         /     \
A---B---D---E---F master
     \
      D---E feature-some

# after master push
      A---B---C---F' origin/master
         /       /
A---B---D---E---F master
     \
      D---E feature-some
</code></pre><h3 id="shiyongrebasehebing"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shiyongrebasehebing')">¶</a> 使用 rebase 合并</h3>
<p>要解决这样的问题，唯一的做法就是使用<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank"><code>变基</code></a>，也就是<code>rebase</code>来进行分支合并，使用变基分两种情况：</p>
<p><strong>1.拉取时变基合并</strong><br>
依旧是运行上面一系列命令，但是在「git pull」的时候加上「--rebase」选项：</p>
<pre  data-line="6" class="language-bash"><code data-line="6" class="language-bash">~/FE-Project/git-test&gt;git branch # 查看当前分支
* feature-some
  master
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git merge feature-some # 合并功能分支，此时可能需要解决冲突
~/FE-Project/git-test&gt;git pull --rebase # 拉取最新的远端主分支代码，使用“--rebase”选项，此时可能需要解决冲突
~/FE-Project/git-test&gt;git push # 推送分支，此时如果又有人更新代码的话，需要重新拉取解决冲突后才能推送
</code></pre><p>这个时候 master 分支看起来就是线性的了：</p>
<pre  class="language-bash"><code class="language-bash"># after feature-some committed
A---B---C origin/master

A---B master
     \
      D---E feature-some

# after feature-some merge to master
A---B---C origin/master

A---B---D---E master
     \
      D---E feature-some

# after master pull --rebase
A---B---C origin/master

A---B---C---D'---E' master
         \
          D---E feature-some

# after master push
A---B---C---D'---E' origin/master

A---B---C---D'---E' master
         \
          D---E feature-some
</code></pre><p><strong>2.拉取后变基合并</strong><br>
这个做法步骤会更多，操作顺序是先更新本地「master」分支，然后在「feature-some」分支以更新完最新状态的本地「master」分支为基点进行变基，解决完冲突后再合并回本地「master」分支进行推送：</p>
<pre  data-line="7" class="language-bash"><code data-line="7" class="language-bash">~/FE-Project/git-test&gt;git branch # 查看当前分支
* feature-some
  master
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git pull # 拉取最新的远端主分支代码
~/FE-Project/git-test&gt;git checkout feature-some # 切换到 feature-some 分支
~/FE-Project/git-test&gt;git rebase master #  对 feature-some 分支以 master 分支为目标变基，此时可能需要解决冲突
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git merge feature-some # 合并功能分支
~/FE-Project/git-test&gt;git push # 推送分支，此时如果又有人更新代码的话，需要重新拉取解决冲突后才能推送
</code></pre><p>流程分析结果：</p>
<pre  class="language-bash"><code class="language-bash"># after feature-some committed
A---B---C origin/master

A---B master
     \
      D---E feature-some

# after master pull
A---B---C origin/master

A---B---C master
     \
      D---E feature-some

# after feature-some rebase from master
A---B---C origin/master

A---B---C master
         \
          D'---E' feature-some

# after feature-some merge to master
A---B---C origin/master

A---B---C---D'---E' master
         \
          D'---E' feature-some

# after master push
A---B---C---D'---E' origin/master

A---B---C---D'---E' master
         \
          D'---E' feature-some
</code></pre><p>推荐使用第二种做法，因为你不知道从远程分支拉取过来的代码会出现怎样的情况，当出现大量冲突时，处理起来比较棘手。相对来说，第二种做法更加可控，而且在切换回「master」分支去拉取代码之前，可以使用「git stash」进行代码的<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86" target="_blank">贮藏</a>，贮藏之后的代码肯定是干净的，且和 「master」拉取前的状态是同步的，所以此时「git rebase master」不会有任何冲突。这时在「feature-some」分支应用刚刚的贮藏就可以达到上面同样的效果，此时如果有冲突的话还是需要解决，但是你可以根据冲突的原因决定是否修改你新增的代码或者预想的提交信息，这是一种更加灵活可控的方法。</p>
<pre  class="language-bash"><code class="language-bash">~/FE-Project/git-test&gt;git branch # 查看当前分支
* feature-some
  master
~/FE-Project/git-test&gt;git add . # 添加所有变动文件到暂存区
~/FE-Project/git-test&gt;git stash # 贮藏暂存区的所有文件
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git pull # 拉取最新的远端主分支代码
~/FE-Project/git-test&gt;git checkout feature-some # 切换到 feature-some 分支
~/FE-Project/git-test&gt;git rebase master #  对 feature-some 分支以 master 分支为目标变基，此时可能需要解决冲突
~/FE-Project/git-test&gt;git stash pop # 应用贮藏
~/FE-Project/git-test&gt;npm run commit # commit 提交
~/FE-Project/git-test&gt;git checkout master # 切换到 master 分支
~/FE-Project/git-test&gt;git merge feature-some # 合并功能分支
~/FE-Project/git-test&gt;git push # 推送分支，此时如果又有人更新代码的话，需要重新拉取解决冲突后才能推送
</code></pre><h4 id="hebingqianxiugaiCommit"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'hebingqianxiugaiCommit')">¶</a> 合并前修改 Commit</h4>
<p>圣人千虑，必有一失，就算熟读了规范，应用了工具帮助「commit」，也总会出现需要修改「commit」的时候，比如：</p>
<ul>
<li>「commit」的类型/描述/issue 填写(选)错了；</li>
<li>「commit」了之后才发现添加少了文件；</li>
<li>多个「commit」其实加起来都只实现了一个功能；</li>
<li>因为有紧急 bug 需要处理而必须先搁置当前正在开发的代码而又不想使用贮藏；</li>
<li>...</li>
</ul>
<p>什么情况都有可能发生，这些常见突发状况可以总结为一下三种类型，对应的处理方法一并给出。</p>
<p><strong>1.只修改「commit」信息：</strong></p>
<pre  data-line="3" class="language-bash"><code data-line="3" class="language-bash"># 再次执行 commit 命令同时添加“--amend”指令
~/FE-Project/git-test&gt;git commit --amend
fix: bug fix readme

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Fri Jul 10 00:33:23 2020 +0800
#
# On branch feature-some
# Changes to be committed:
#       modified:   README.md
#

</code></pre><p>出现这个界面直接用 vi 的方式修改「commit」信息，然后用<code>:wq</code>命令保存退出就可以了。</p>
<p><strong>2.需要「commit」的文件少了：</strong></p>
<pre  data-line="3" class="language-bash"><code data-line="3" class="language-bash"># 这种情况和上面是类似的，但是在执行“git commit --amend”前先把文件添加到暂存区
~/FE-Project/git-test&gt;touch additional.js # 模拟新增文件
~/FE-Project/git-test&gt;echo 'some code' &gt; additional.js # 模拟新增代码
~/FE-Project/git-test&gt;git add additional.js # 添加遗漏的文件到暂存区
~/FE-Project/git-test&gt;git commit --amend
fix: bug fix readme

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Fri Jul 10 00:33:23 2020 +0800
#
# On branch feature-some
# Changes to be committed:
#       modified:   README.md
#

</code></pre><p><strong>3.合并多个「commit」记录：</strong></p>
<pre  data-line="3-5" class="language-bash"><code data-line="3-5" class="language-bash"># 使用“git rebase -i”命令来进行多个提交的修改，这时候可以看到三个提交信息以「从旧到新，从上往下」的方式进行分行显示
~/FE-Project/git-test&gt;git rebase -i HEAD~3 # 修改最后三个「commit」记录
pick 3c280ae revert(scope): short
pick 80cc0a1 Revert &quot;feat(scope): here is a short description&quot;
pick ea97323 fix: bug fix readme

# Rebase 8bbd337..ea97323 onto 8bbd337 (3 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like &quot;squash&quot;, but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre><p>需要合并三个「commit」的话，需要将第二三行的「pick」修改为「squash」，使用<code>:wq</code>保存退出,</p>
<pre  data-line="1-3" class="language-bash"><code data-line="1-3" class="language-bash">pick 3c280ae revert(scope): short
squash 80cc0a1 Revert &quot;feat(scope): here is a short description&quot;
squash ea97323 fix: bug fix readme and some additional operation
</code></pre><p>git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：</p>
<pre  class="language-bash"><code class="language-bash">feat: short

long

BREAKING CHANGE: beaking

fix #123

feat(scope): here is a short description

here is the first paragraph

BREAKING CHANGE: here is a description about breaking changes

fix #123

revert(scope): short

long

Revert &quot;feat(scope): here is a short description&quot;

This reverts commit 8bbd337eab7d54c82327159c41ac975f805e28f5.

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Thu Jul 9 17:58:06 2020 +0800
#
# interactive rebase in progress; onto 99a56e3
# Last command done (1 command done):
#    squash 267e38a feat: test
# Next command to do (1 remaining command):
#    reword 496f422 fix: bug fix readme heiheihei
# You are currently rebasing branch 'feature-some' on '99a56e3'.
#
# Changes to be committed:
#       modified:   README.md
#

</code></pre><p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。</p>
<p>关于「git rebase -i HEAD~[number]」的操作还有很多，比如它也可以做到重写「commit」信息、调整多个「commit」的先后顺序、拆分提交等等，篇幅有限，这里不再展开，如果有兴趣的话请狠狠点击<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2" target="_blank">这里</a>学习。</p>
<h4 id="zhuyi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhuyi')">¶</a> 注意！</h4>
<p>以上操作只能在本地分支的「commit」没有合并到远程分支前执行，所有与远程分支同步的「commit」都不可随意修改或合并，否者会给你的合作者带来各种神奇的麻烦，如果你一意孤行且敲下了罪恶的「git push --force」，你将会被世人所不齿，被人们所唾弃。三思。</p>
<h3 id="yuanchengmasterfenzhiquanxiankongzhi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yuanchengmasterfenzhiquanxiankongzhi')">¶</a> 远程 master 分支权限控制</h3>
<p>远程主分支和发布分支应该进严格的权限控制，只允许 master （管理员）的角色进行 commit 的合并，这些角色通常由小组负责人或项目负责人担任。其他代码贡献者（同事）设置为「developer」或其他对这些主要分支只有 <strong><em>访问</em></strong> 权限的角色。常用的 gitlab 设置如下图：</p>
<p><img src="_nuxt/img/pic-git-lab-setting.6bb57c6.png" alt=""></p>
<p>团队成员应该严格遵循团队内的「git workflow」（如果有的话），所有新需求或 bug 修复都应该在本地分支进行开发，开发完成后提交到测试分支或者远端「dev」分支，测试通过后，再由 master 角色的进行主要分支的合并。</p>
<h3 id="helifencha"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'helifencha')">¶</a> 合理分叉</h3>
<p>当然，以千万级使用量的开源库来对我们平时进行业务开发的代码库进行硬性要求，难免存在不合理性，脱离了业务的开源库的每个提交都是基于新增功能或者修复 bug 性质的，而业务开发更多时候是伴随着一个「功能模块」进行开发测试的。</p>
<p>比如业务需求增加了「积分」这一模块，这个「积分」模块可能涉及到多个功能模块的修改或者新增了一部分公共模块，这个时候如果还是「一条直线」的「git log」记录反而显得不那么清晰了。那么这时候可以使用「git merge --no-ff [branch-name]」命令来可以取消 git 默认的 「fast-forwarded」行为，进而刻意地创建一个「merge」类型的「commit」。</p>
<p>情景分析：在接到「积分」模块开发任务的时候，首先基于「master」创建一条「points-module」分支。在开发并提交了三个「feature points」相关功能后，发现需要修改「feature-1」的 bug 以适应积分模块。当整个模块测试完成需要合并到「master」的时候，切换到「master」，执行「git merge --no-ff points-module」命令来进行合并，此时输入「add points module」来作为提交信息。</p>
<p>结果如下所示：</p>
<pre  data-line="1" class="language-bash"><code data-line="1" class="language-bash">*   a1915ff (HEAD -&gt; master)  add points module - CurtisLiong, 2 minutes ago
|\
| * af0b028 fix(feature-1.js): fix bug to adapt feature points - CurtisLiong, 4 minutes ago
| * 5ca19a9 feat(feature-points-3.js): add feature points 3 - CurtisLiong, 7 minutes ago
| * 8a85062 feat(feature-points-2.js): add feature points 2 - CurtisLiong, 8 minutes ago
| * 87ae897 feat(feature-points-1.js): add feature points 1 - CurtisLiong, 8 minutes ago
|/
* 78c6ff0 feat(feature-1.js): add feature 1 - CurtisLiong, 13 minutes ago
* 37d2d11 feat(whole project): project init - CurtisLiong, 14 minutes ago
</code></pre><p>这样在回溯「积分」这个模块的开发过程的时候，就可以快速分辨出那些提交是属于「积分」这个模块的。</p>
<hr>
<h2 id="jieyan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyan')">¶</a> 结言</h2>
<p>一套酣畅淋漓的打法下来，规范提交「commit」的姿势相信你已经掌握得七七八八。</p>
<p>规范整洁的「git log」记录不仅可以给项目增加严谨性，还可以给项目带来快速方便回溯的好处，与此同时，也体现了我们作为编码工作者的专业性。</p>
<p>如果你对上面使用到的 git 相关命令不熟悉的话，请飞速前往<a href="https://git-scm.com/book/zh/v2" target="_blank">git pro</a>学习，为了你的同事，也为了你自己，请务必增强自己的 git 技能。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[代码整洁之道：JS 中的 S.O.L.I.D 原则]]></title>
            <link>/post/js-solid-principle/</link>
            <guid>/post/js-solid-principle/</guid>
            <description><![CDATA[【译】Clean Code concepts adapted for JavaScript：S.O.L.I.D]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#danyizhizeyuanzeSingleResponsibilityPrincipleSRP">单一职责原则 | Single Responsibility Principle (SRP)</a></li><li><a href="#kaifangfengbiyuanzeOpenClosedPrincipleOCP">开放封闭原则 | Open/Closed Principle (OCP)</a></li><li><a href="#lishitihuanyuanzeLiskovSubstitutionPrincipleLSP">里氏替换原则 | Liskov Substitution Principle (LSP)</a></li><li><a href="#jiekoufenliyuanzeInterfaceSegregationPrincipleISP">接口分离原则 | Interface Segregation Principle (ISP)</a></li><li><a href="#yilaifanzhuanyuanzeDependencyInversionPrincipleDIP">依赖翻转原则 | Dependency Inversion Principle (DIP)</a></li></ul></div></p>
<p><a href="https://book.douban.com/subject/4199741/" target="_blank">《代码整洁之道》</a>是一本致力于教人写出简洁、易维护且高质量代码的书籍，该书给出了一系列行之有效的整洁代码操作实践，阅读过后令人受益匪浅。Github 上的<a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank">clean-code-javascript</a>是一个用 JavaScript 去诠释「Clean Code」理念的项目，该项目以 Bad / Good 为正、反两面的范例，并辅以一些叙述和注释作为说明，以增强阅读者对「Clean Code」理念的理解。下文主要翻译其中提出的最常用的 S.O.L.I.D 原则。</p>
<h2 id="danyizhizeyuanzeSingleResponsibilityPrincipleSRP"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'danyizhizeyuanzeSingleResponsibilityPrincipleSRP')">¶</a> 单一职责原则 | Single Responsibility Principle (SRP)</h2>
<blockquote>
<p>As stated in Clean Code, &quot;There should never be more than one reason for a class to change&quot;. It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important. It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase.</p>
</blockquote>
<p>就如《代码整洁之道》中所提到的，“引起一个类发生变化的原因不应该多于一个”。的确，在一个类中塞入很多的功能很诱人，就像你只能携带一个旅行箱赶航班一样。但是问题在于，这些臃肿的类不再是概念上内聚的，在未来可能会因为很多理由而需要去修改它。尽量减少修改一个类的次数是非常重要的，因为如果一个类包含了太多功能，当你去修改这个类的某一部分时，将会很难理解这些新的修改如何影响代码库中其他的依赖模块。</p>
<blockquote>
<p>译者按：这里的类替换成函数理解也是一样的</p>
</blockquote>
<h4 id="Bad"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad')">¶</a> Bad:</h4>
<pre  class="language-js"><code class="language-js">class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
</code></pre><h4 id="Good"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good')">¶</a> Good:</h4>
<pre  class="language-js"><code class="language-js">class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
</code></pre><h2 id="kaifangfengbiyuanzeOpenClosedPrincipleOCP"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'kaifangfengbiyuanzeOpenClosedPrincipleOCP')">¶</a> 开放封闭原则 | Open/Closed Principle (OCP)</h2>
<blockquote>
<p>As stated by Bertrand Meyer, &quot;software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.&quot; What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.</p>
</blockquote>
<p>Bertrand Meyer 也曾经说过，“软件实体（类、模块、函数等）应该对可扩展性进行开放，而对可修改性进行封闭。”那是什么意思呢？这个原则基本上是说你应该允许用户在<strong>不更改现有代码</strong>的情况下添加新的功能。</p>
<h4 id="Bad-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-2')">¶</a> Bad:</h4>
<pre  class="language-js"><code class="language-js">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'ajaxAdapter';
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'nodeAdapter';
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === 'ajaxAdapter') {
      return makeAjaxCall(url).then(response =&gt; {
        // 处理响应结果并返回
      });
    } else if (this.adapter.name === 'nodeAdapter') {
      return makeHttpCall(url).then(response =&gt; {
        // 处理响应结果并返回
      });
    }
  }
}

function makeAjaxCall(url) {
  // 请求并返回 promise
}

function makeHttpCall(url) {
  // 请求并返回 promise
}
</code></pre><h4 id="Good-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-2')">¶</a> Good:</h4>
<pre  class="language-js"><code class="language-js">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'ajaxAdapter';
  }

  request(url) {
    // 请求并返回 promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'nodeAdapter';
  }

  request(url) {
    // 请求并返回 promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then(response =&gt; {
      // 处理响应结果并返回
    });
  }
}
</code></pre><h2 id="lishitihuanyuanzeLiskovSubstitutionPrincipleLSP"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'lishitihuanyuanzeLiskovSubstitutionPrincipleLSP')">¶</a> 里氏替换原则 | Liskov Substitution Principle (LSP)</h2>
<blockquote>
<p>This is a scary term for a very simple concept. It's formally defined as &quot;If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).&quot; That's an even scarier definition.</p>
</blockquote>
<p>这个术语（里氏替换）听起来很“可怕”，但是其实概念很简单。它的正式定义是：“如果 S 是 T 的子类型，那么类型 T 应该可以被类型 S 的对象所替换（例如，类型 S 的对象可以替换为类型 T 的对象）”，且不会改变该程序原来的任何预期（正确性、执行的任务等）。...这听起来令人更加“害怕”。</p>
<blockquote>
<p>The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the &quot;is-a&quot; relationship via inheritance, you quickly get into trouble.</p>
</blockquote>
<p>对这个原则最好的解释是，如果你有一个父类和一个子类，这对父子类可以互相替换使用而不会得到不正确的结果。这听起来可能还是比较令人难以理解，所以我们来看一个经典的<code>Square-Rectangle</code>例子。从算术语言的角度而言，一个<strong>正方形</strong>同时也是一个<strong>矩形</strong>，但如果你通过继承使用“is-a”关系为它建模，你很快就会遇到麻烦。</p>
<h4 id="Bad-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-3')">¶</a> Bad:</h4>
<pre  class="language-js"><code class="language-js">class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.forEach(rectangle =&gt; {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); // BAD: 预期的正方形面积应该为 20，但是却返回了 25
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
</code></pre><h4 id="Good-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-3')">¶</a> Good:</h4>
<pre  class="language-js"><code class="language-js">class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach(shape =&gt; {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
</code></pre><h2 id="jiekoufenliyuanzeInterfaceSegregationPrincipleISP"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiekoufenliyuanzeInterfaceSegregationPrincipleISP')">¶</a> 接口分离原则 | Interface Segregation Principle (ISP)</h2>
<blockquote>
<p>JavaScript doesn't have interfaces so this principle doesn't apply as strictly as others. However, it's important and relevant even with JavaScript's lack of type system.</p>
</blockquote>
<p>JavaScript 语言里没有“接口”类型的概念，所以这个原则不像其它原则那样严格适用。然而，即使 JavaScript 缺乏类型系统，遵循接口分离原则还是很重要的。</p>
<blockquote>
<p>ISP states that &quot;Clients should not be forced to depend upon interfaces that they do not use.&quot; Interfaces are implicit contracts in JavaScript because of duck typing.</p>
</blockquote>
<p>ISP 声明“客户端不应该被迫依赖于它们不使用的接口”。而且 JavaScript 具有“鸭子类型”的特性，因此接口在 JavaScript 中属于一种隐性约定。</p>
<blockquote>
<p>A good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a &quot;fat interface&quot;.</p>
</blockquote>
<p>在 JavaScript 中验证这一原则的一个很好的例子就是那些需要大量配置对象的类。不要求客户端配置大量选项是有益的，因为大多数时候它们不需要所有的设置项。让设置项保持<strong>可选</strong>可以有助防止“臃肿接口”的出现。</p>
<h4 id="Bad-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-4')">¶</a> Bad:</h4>
<pre  class="language-js"><code class="language-js">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.settings.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName('body'),
  animationModule() {}, // 大多数情况下，我们在遍历的时候并不需要动画
  // ...
});
</code></pre><h4 id="Good-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-4')">¶</a> Good:</h4>
<pre  class="language-js"><code class="language-js">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName('body'),
  options: {
    animationModule() {},
  },
});
</code></pre><h2 id="yilaifanzhuanyuanzeDependencyInversionPrincipleDIP"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yilaifanzhuanyuanzeDependencyInversionPrincipleDIP')">¶</a> 依赖翻转原则 | Dependency Inversion Principle (DIP)</h2>
<blockquote>
<p>This principle states two essential things:</p>
<ol>
<li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
<li>Abstractions should not depend upon details. Details should depend on abstractions.</li>
</ol>
</blockquote>
<p>这一原则阐述了两件重要的事情：</p>
<ol>
<li>高级模块不应该依赖于低级模块。两者都应该依赖于抽象。</li>
<li>抽象不应该依赖于具体实现。具体实现应该依赖于抽象。</li>
</ol>
<blockquote>
<p>This can be hard to understand at first, but if you've worked with AngularJS, you've seen an implementation of this principle in the form of Dependency Injection (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor.</p>
</blockquote>
<p>最开始可能难以理解，不过如果你曾经使用过 AngularJS，你就已经见识过这一原则的其中一种实现方式，也即“依赖注入”（DI）。虽然它们不是完全相同的概念，但 DIP 阻止了高级模块了解其低级模块的具体实现和设置。这可以通过“依赖注入”（DI）来达成目的。这样做带来的一个显著的好处就是可以减少模块之间的耦合。耦合是一种非常糟糕的开发模式，因为它会使你的代码难以维护。</p>
<blockquote>
<p>As stated previously, JavaScript doesn't have interfaces so the abstractions that are depended upon are implicit contracts. That is to say, the methods and properties that an object/class exposes to another object/class. In the example below, the implicit contract is that any Request module for an <code>InventoryTracker</code> will have a <code>requestItems</code> method.</p>
</blockquote>
<p>就像上文所说，JavaScript 语言没有“接口”这一概念，所以抽象只能依赖于隐性约定。也就是说，一个对象或类暴露给另一个对象或类的方法和属性。在下面的示例中的隐性约定是，<code>InventoryTracker</code>依赖的任一 Request 模块都将有一个<code>requestItems</code>方法。</p>
<h4 id="Bad-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bad-5')">¶</a> Bad:</h4>
<pre  class="language-js"><code class="language-js">class InventoryRequester {
  constructor() {
    this.REQ_METHODS = ['HTTP'];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryTracker {
  constructor(items) {
    this.items = items;

    // BAD: 这里产生了一个指定请求类型的依赖
    // 正确的做法应该是让 requestItems 去依赖请求方法：`request`
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach(item =&gt; {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker(['apples', 'bananas']);
inventoryTracker.requestItems();
</code></pre><h4 id="Good-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Good-5')">¶</a> Good:</h4>
<pre  class="language-js"><code class="language-js">class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach(item =&gt; {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = ['HTTP'];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = ['WS'];
  }

  requestItem(item) {
    // ...
  }
}

// 通过在外部完成依赖构建，并注入它们
// 我们可以很容易地将请求模块替换为使用 WebSockets 的新请求模块。
const inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());
inventoryTracker.requestItems();
</code></pre><p><a href="https://github.com/ryanmcdermott/clean-code-javascript#solid" target="_blank">原文地址</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Markdown基本语法与扩展语法]]></title>
            <link>/post/markdown-grammar-sammple/</link>
            <guid>/post/markdown-grammar-sammple/</guid>
            <description><![CDATA[博客文章的编写利器]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#Overview">Overview</a></li><li><a href="#Headings">Headings</a></li><li><a href="#AlternateSyntax">Alternate Syntax</a></li><li><a href="#Paragraphs">Paragraphs</a></li><li><a href="#LineBreaks">Line Breaks</a></li><li><a href="#Emphasis">Emphasis</a></li><li><a href="#Bold">Bold</a></li><li><a href="#Italic">Italic</a></li><li><a href="#BoldandItalic">Bold and Italic</a></li><li><a href="#Blockquotes">Blockquotes</a></li><li><a href="#BlockquoteswithMultipleParagraphs">Blockquotes with Multiple Paragraphs</a></li><li><a href="#NestedBlockquotes">Nested Blockquotes</a></li><li><a href="#BlockquoteswithOtherElements">Blockquotes with Other Elements</a></li><li><a href="#Lists">Lists</a></li><li><a href="#OrderedLists">Ordered Lists</a></li><li><a href="#UnorderedLists">Unordered Lists</a></li><li><a href="#AddingElementsinLists">Adding Elements in Lists</a><ul><li><a href="#Paragraphs">Paragraphs</a></li><li><a href="#Blockquotes">Blockquotes</a></li><li><a href="#CodeBlocks">Code Blocks</a></li><li><a href="#Images">Images</a></li></ul></li><li><a href="#Code">Code</a></li><li><a href="#EscapingBackticks">Escaping Backticks</a></li><li><a href="#CodeBlocks">Code Blocks</a></li><li><a href="#HorizontalRules">Horizontal Rules</a></li><li><a href="#Links">Links</a></li><li><a href="#AddingTitles">Adding Titles</a></li><li><a href="#URLsandEmailAddresses">URLs and Email Addresses</a></li><li><a href="#FormattingLinks">Formatting Links</a></li><li><a href="#ReferencestyleLinks">Reference-style Links</a></li><li><a href="#AnExamplePuttingthePartsTogether">An Example Putting the Parts Together</a></li><li><a href="#Images">Images</a></li><li><a href="#LinkingImages">Linking Images</a></li><li><a href="#EscapingCharacters">Escaping Characters</a></li><li><a href="#CharactersYouCanEscape">Characters You Can Escape</a></li><li><a href="#HTML">HTML</a></li><li><a href="#Limitations">Limitations</a></li><li><a href="#Tables">Tables</a></li><li><a href="#Alignment">Alignment</a></li><li><a href="#FormattingTextinTables">Formatting Text in Tables</a></li><li><a href="#EscapingPipeCharactersinTables">Escaping Pipe Characters in Tables</a></li><li><a href="#FencedCodeBlocks">Fenced Code Blocks</a></li><li><a href="#SyntaxHighlighting">Syntax Highlighting</a></li><li><a href="#HeadingIDs">Heading IDs</a></li><li><a href="#LinkingtoHeadingIDs">Linking to Heading IDs</a></li><li><a href="#DefinitionLists">Definition Lists</a></li><li><a href="#Strikethrough">Strikethrough</a></li><li><a href="#TaskLists">Task Lists</a></li><li><a href="#AutomaticURLLinking">Automatic URL Linking</a></li><li><a href="#DisablingAutomaticURLLinking">Disabling Automatic URL Linking</a></li></ul></div></p>
<p>记录Markdown基本的和扩展的语法, 主要用于博客样式实时调整和备忘.</p>
<p>内容来自<a href="https://www.markdownguide.org/basic-syntax/#code" target="_blank">这里(基本语法)</a>和<a href="https://www.markdownguide.org/extended-syntax/#alignment" target="_blank">这里(扩展语法)</a>.</p>
<h2 id="Overview"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Overview')">¶</a> Overview</h2>
<p>Nearly all Markdown applications support the basic syntax outlined in John Gruber’s original design document. There are minor variations and discrepancies between Markdown processors — those are noted inline wherever possible.</p>
<h2 id="Headings"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Headings')">¶</a> Headings</h2>
<p>To create a heading, add number signs (#) in front of a word or phrase. The number of number signs you use should correspond to the heading level. For example, to create a heading level three (&lt;h3&gt;), use three number signs (e.g., ### My Header).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"># Heading level 1</td>
<td style="text-align:left">&lt;h1&gt;Heading level 1&lt;/h1&gt;</td>
<td style="text-align:left"><h1>Heading level 1</h1></td>
</tr>
<tr>
<td style="text-align:left">## Heading level 2</td>
<td style="text-align:left">&lt;h2&gt;Heading level 2&lt;/h2&gt;</td>
<td style="text-align:left"><h2>Heading level 2</h2></td>
</tr>
<tr>
<td style="text-align:left">### Heading level 3</td>
<td style="text-align:left">&lt;h3&gt;Heading level 3&lt;/h3&gt;</td>
<td style="text-align:left"><h3>Heading level 3</h3></td>
</tr>
<tr>
<td style="text-align:left">#### Heading level 4</td>
<td style="text-align:left">&lt;h4&gt;Heading level 4&lt;/h4&gt;</td>
<td style="text-align:left"><h4>Heading level 4</h4></td>
</tr>
<tr>
<td style="text-align:left">##### Heading level 5</td>
<td style="text-align:left">&lt;h5&gt;Heading level 5&lt;/h5&gt;</td>
<td style="text-align:left"><h5>Heading level 5</h5></td>
</tr>
<tr>
<td style="text-align:left">###### Heading level 6</td>
<td style="text-align:left">&lt;h6&gt;Heading level 6&lt;/h6&gt;</td>
<td style="text-align:left"><h6>Heading level 6</h6></td>
</tr>
</tbody>
</table>
<h2 id="AlternateSyntax"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AlternateSyntax')">¶</a> Alternate Syntax</h2>
<p>Alternatively, on the line below the text, add any number of == characters for heading level 1 or -- characters for heading level 2.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Heading level 1<br>===============</td>
<td style="text-align:left">&lt;h1&gt;Heading level 1&lt;/h1&gt;</td>
<td style="text-align:left"><h1>Heading level 1</h1></td>
</tr>
<tr>
<td style="text-align:left">Heading level 2<br>---------------</td>
<td style="text-align:left">&lt;h2&gt;Heading level 2&lt;/h2&gt;</td>
<td style="text-align:left"><h2>Heading level 2</h2></td>
</tr>
</tbody>
</table>
<h2 id="Paragraphs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Paragraphs')">¶</a> Paragraphs</h2>
<p>To create paragraphs, use a blank line to separate one or more lines of text. You should not indent paragraphs with spaces or tabs.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I really like using Markdown.</td>
<td style="text-align:left">&lt;p&gt;I really like using Markdown.&lt;/p&gt;</td>
<td style="text-align:left"><p>I really like using Markdown.</p></td>
</tr>
<tr>
<td style="text-align:left">I think I'll use it to format all of my documents from now on.</td>
<td style="text-align:left">&lt;p&gt;I think I'll use it to format all of my documents from now on.&lt;/p&gt;</td>
<td style="text-align:left"><p>I think I'll use it to format all of my documents from now on.</p></td>
</tr>
</tbody>
</table>
<h2 id="LineBreaks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'LineBreaks')">¶</a> Line Breaks</h2>
<p>To create a line break (&lt;br&gt;), end a line with two or more spaces, and then type return.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">This is the first line.<br><br>And this is the second line.</td>
<td style="text-align:left">&lt;p&gt;This is the first line.&lt;br&gt;And this is the second line.&lt;/p&gt;</td>
<td style="text-align:left"><p>This is the first line.<br>And this is the second line.</p></td>
</tr>
</tbody>
</table>
<h2 id="Emphasis"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Emphasis')">¶</a> Emphasis</h2>
<p>You can add emphasis by making text bold or italic.</p>
<h2 id="Bold"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Bold')">¶</a> Bold</h2>
<p>To bold text, add two asterisks or underscores before and after a word or phrase. To bold the middle of a word for emphasis, add two asterisks without spaces around the letters.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">I just love **bold text**.</td>
<td style="text-align:left">I just love &lt;strong&gt;bold text&lt;/strong&gt;.</td>
<td style="text-align:left">I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td style="text-align:left">I just love __bold text__.</td>
<td style="text-align:left">I just love &lt;strong&gt;bold text&lt;/strong&gt;.</td>
<td style="text-align:left">I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td style="text-align:left">Love**is**bold</td>
<td style="text-align:left">Love&lt;strong&gt;is&lt;/strong&gt;bold</td>
<td style="text-align:left">Love<strong>is</strong>bold</td>
</tr>
</tbody>
</table>
<h2 id="Italic"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Italic')">¶</a> Italic</h2>
<p>To italicize text, add one asterisk or underscore before and after a word or phrase. To italicize the middle of a word for emphasis, add one asterisk without spaces around the letters.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Italicized text is the *cat's meow*.</td>
<td style="text-align:left">Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;.</td>
<td style="text-align:left">Italicized text is the <em>cat's meow</em>.</td>
</tr>
<tr>
<td style="text-align:left">Italicized text is the _cat's meow_.</td>
<td style="text-align:left">Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;.</td>
<td style="text-align:left">Italicized text is the <em>cat's meow</em>.</td>
</tr>
<tr>
<td style="text-align:left">A*cat*meow</td>
<td style="text-align:left">A&lt;em&gt;cat&lt;/em&gt;meow</td>
<td style="text-align:left">A<em>cat</em>meow</td>
</tr>
</tbody>
</table>
<h2 id="BoldandItalic"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BoldandItalic')">¶</a> Bold and Italic</h2>
<p>To emphasize text with bold and italics at the same time, add three asterisks or underscores before and after a word or phrase.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">This text is ***really important***.</td>
<td style="text-align:left">This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</td>
<td style="text-align:left">This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td style="text-align:left">This text is ___really important___.</td>
<td style="text-align:left">This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</td>
<td style="text-align:left">This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td style="text-align:left">This text is __*really important*__.</td>
<td style="text-align:left">This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</td>
<td style="text-align:left">This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td style="text-align:left">This text is **_really important_**.</td>
<td style="text-align:left">This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</td>
<td style="text-align:left">This text is <strong><em>really important</em></strong>.</td>
</tr>
</tbody>
</table>
<h2 id="Blockquotes"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Blockquotes')">¶</a> Blockquotes</h2>
<p>To create a blockquote, add a &gt; in front of a paragraph.</p>
<pre  class="language-text"><code class="language-text">&gt; Dorothy followed her through many of the beautiful rooms in her castle.
</code></pre><p>The rendered output looks like this:</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h2 id="BlockquoteswithMultipleParagraphs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BlockquoteswithMultipleParagraphs')">¶</a> Blockquotes with Multiple Paragraphs</h2>
<p>Blockquotes can contain multiple paragraphs. Add a &gt; on the blank lines between the paragraphs.</p>
<pre  class="language-text"><code class="language-text">&gt; Dorothy followed her through many of the beautiful rooms in her castle.
&gt;
&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.
</code></pre><p>The rendered output looks like this:</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
<h2 id="NestedBlockquotes"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'NestedBlockquotes')">¶</a> Nested Blockquotes</h2>
<p>Blockquotes can be nested. Add a &gt;&gt; in front of the paragraph you want to nest.</p>
<pre  class="language-text"><code class="language-text">&gt; Dorothy followed her through many of the beautiful rooms in her castle.
&gt;
&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.
</code></pre><blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h2 id="BlockquoteswithOtherElements"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BlockquoteswithOtherElements')">¶</a> Blockquotes with Other Elements</h2>
<p>Blockquotes can contain other Markdown formatted elements. Not all elements can be used — you’ll need to experiment to see which ones work.</p>
<pre  class="language-text"><code class="language-text">&gt; #### The quarterly results look great!
&gt;
&gt; - Revenue was off the chart.
&gt; - Profits were higher than ever.
&gt;
&gt;  *Everything* is going according to **plan**.
</code></pre><p>The rendered output looks like this:</p>
<blockquote>
<h4 id="Thequarterlyresultslookgreat"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Thequarterlyresultslookgreat')">¶</a> The quarterly results look great!</h4>
<ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
<h2 id="Lists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Lists')">¶</a> Lists</h2>
<p>You can organize items into ordered and unordered lists.</p>
<h2 id="OrderedLists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'OrderedLists')">¶</a> Ordered Lists</h2>
<p>To create an ordered list, add line items with numbers followed by periods. The numbers don’t have to be in numerical order, but the list should start with the number one.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. First item<br>2. Second item<br>3. Third item<br>4. Fourth item</td>
<td style="text-align:left">&lt;ol&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ol&gt;</td>
<td style="text-align:left"><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol></td>
</tr>
<tr>
<td style="text-align:left">1. First item<br>1. Second item<br>1. Third item<br>1. Fourth item</td>
<td style="text-align:left">&lt;ol&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ol&gt;</td>
<td style="text-align:left"><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol></td>
</tr>
<tr>
<td style="text-align:left">1. First item<br>8. Second item<br>2. Third item<br>5. Fourth item</td>
<td style="text-align:left">&lt;ol&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ol&gt;</td>
<td style="text-align:left"><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol></td>
</tr>
<tr>
<td style="text-align:left">1. First item<br>2. Second item<br>3. Third item<br>      1.Indented item<br>      2. Indented item<br>4. Fourth item</td>
<td style="text-align:left">&lt;ol&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item<br>&lt;ol&gt;<br>&lt;li&gt;Indented item&lt;/li&gt;<br>&lt;li&gt;Indented item&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ol&gt;</td>
<td style="text-align:left"><ol><li>First item</li><li>Second item</li><li>Third item<ol><li>Indented item</li><li>Indented item</li></ol></li><li>Fourth item</li></ol></td>
</tr>
</tbody>
</table>
<h2 id="UnorderedLists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'UnorderedLists')">¶</a> Unordered Lists</h2>
<p>To create an unordered list, add dashes (-), asterisks (*), or plus signs (+) in front of line items. Indent one or more items to create a nested list.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">- First item<br>- Second item<br>- Third item<br>- Fourth item</td>
<td style="text-align:left">&lt;ul&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ul&gt;</td>
<td style="text-align:left"><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul></td>
</tr>
<tr>
<td style="text-align:left">* First item<br>* Second item<br>* Third item<br>* Fourth item</td>
<td style="text-align:left">&lt;ul&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ul&gt;</td>
<td style="text-align:left"><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul></td>
</tr>
<tr>
<td style="text-align:left">+ First item<br>* Second item<br>- Third item<br>+ Fourth item</td>
<td style="text-align:left">&lt;ul&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ul&gt;</td>
<td style="text-align:left"><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul></td>
</tr>
<tr>
<td style="text-align:left">1. First item<br>8. Second item<br>2. Third item<br>5. Fourth item</td>
<td style="text-align:left">&lt;ul&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ul&gt;</td>
<td style="text-align:left"><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul></td>
</tr>
<tr>
<td style="text-align:left">- First item<br>- Second item<br>- Third item<br>      -Indented item<br>      - Indented item<br>- Fourth item</td>
<td style="text-align:left">&lt;ul&gt;<br>&lt;li&gt;First item&lt;/li&gt;<br>&lt;li&gt;Second item&lt;/li&gt;<br>&lt;li&gt;Third item<br>&lt;ul&gt;<br>&lt;li&gt;Indented item&lt;/li&gt;<br>&lt;li&gt;Indented item&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;li&gt;Fourth item&lt;/li&gt;<br>&lt;/ul&gt;</td>
<td style="text-align:left"><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="AddingElementsinLists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AddingElementsinLists')">¶</a> Adding Elements in Lists</h2>
<p>To add another element in a list while preserving the continuity of the list, indent the element four spaces or one tab, as shown in the following examples.</p>
<h3 id="Paragraphs-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Paragraphs-2')">¶</a> Paragraphs</h3>
<pre  class="language-text"><code class="language-text">*   This is the first list item.
*   Here's the second list item.

    I need to add another paragraph below the second list item.

*   And here's the third list item.
</code></pre><p>The rendered output looks like this:</p>
<ul>
<li>
<p>This is the first list item.</p>
</li>
<li>
<p>Here's the second list item.</p>
<p>I need to add another paragraph below the second list item.</p>
</li>
<li>
<p>And here's the third list item.</p>
</li>
</ul>
<h3 id="Blockquotes-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Blockquotes-2')">¶</a> Blockquotes</h3>
<pre  class="language-text"><code class="language-text">*   This is the first list item.
*   Here's the second list item.

    &gt; A blockquote would look great below the second list item.

*   And here's the third list item.
</code></pre><p>The rendered output looks like this:</p>
<ul>
<li>
<p>This is the first list item.</p>
</li>
<li>
<p>Here's the second list item.</p>
<blockquote>
<p>A blockquote would look great below the second list item.</p>
</blockquote>
</li>
<li>
<p>And here's the third list item.</p>
</li>
</ul>
<h3 id="CodeBlocks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CodeBlocks')">¶</a> Code Blocks</h3>
<p>Code blocks are normally indented four spaces or one tab. When they’re in a list, indent them eight spaces or two tabs.</p>
<pre  class="language-text"><code class="language-text">1.  Open the file.
2.  Find the following code block on line 21:

        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;Test&lt;/title&gt;
          &lt;/head&gt;

3.  Update the title to match the name of your website.
</code></pre><p>The rendered output looks like this:</p>
<ol>
<li>Open the file.</li>
<li>Find the following code block on line 21:</li>
</ol>
<pre  class="language-html"><code class="language-html">        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;Test&lt;/title&gt;
          &lt;/head&gt;
</code></pre><ol start="3">
<li>Update the title to match the name of your website.</li>
</ol>
<h3 id="Images"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Images')">¶</a> Images</h3>
<pre  class="language-text"><code class="language-text">1.  Open the file containing the Linux mascot.
2.  Marvel at its beauty.

    ![Tux, the Linux mascot](./tux.png)

3.  Close the file.
</code></pre><p>The rendered output looks like this:</p>
<ol>
<li>
<p>Open the file containing the Linux mascot.</p>
</li>
<li>
<p>Marvel at its beauty.</p>
<p><img src="_nuxt/img/tux.f79464a.png" alt="Tux, the Linux mascot"></p>
</li>
<li>
<p>Close the file.</p>
</li>
</ol>
<h2 id="Code"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Code')">¶</a> Code</h2>
<p>To denote a word or phrase as code, enclose it in backticks (`).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">At the command prompt, type `nano`.</td>
<td style="text-align:left">At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</td>
<td style="text-align:left">At the command prompt, type <code>nano</code>.</td>
</tr>
</tbody>
</table>
<h2 id="EscapingBackticks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'EscapingBackticks')">¶</a> Escaping Backticks</h2>
<p>If the word or phrase you want to denote as code includes one or more backticks, you can escape it by enclosing the word or phrase in double backticks (``).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">``Use `code` in your Markdown file.``</td>
<td style="text-align:left">&lt;code&gt;Use `code` in your Markdown file.&lt;/code&gt;</td>
<td style="text-align:left"><code>Use `code` in your Markdown file.</code></td>
</tr>
</tbody>
</table>
<h2 id="CodeBlocks-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CodeBlocks-2')">¶</a> Code Blocks</h2>
<p>To create code blocks, indent every line of the block by at least four spaces or one tab.</p>
<pre  class="language-text"><code class="language-text">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
&lt;/html&gt;
</code></pre><p>The rendered output looks like this:</p>
<pre  class="language-html"><code class="language-html">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
&lt;/html&gt;
</code></pre><h2 id="HorizontalRules"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'HorizontalRules')">¶</a> Horizontal Rules</h2>
<p>To create a horizontal rule, use three or more asterisks (***), dashes (---), or underscores (___) on a line by themselves.</p>
<pre  class="language-text"><code class="language-text">***

---

_________________
</code></pre><p>The rendered output of all three looks identical:</p>
<hr>
<h2 id="Links"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Links')">¶</a> Links</h2>
<p>To create a link, enclose the link text in brackets (e.g., [Duck Duck Go]) and then follow it immediately with the URL in parentheses (e.g., (<a href="https://duckduckgo.com">https://duckduckgo.com</a>)).</p>
<pre  class="language-text"><code class="language-text">My favorite search engine is [Duck Duck Go](https://duckduckgo.com).
</code></pre><p>The rendered output looks like this:</p>
<p>My favorite search engine is <a href="https://duckduckgo.com">Duck Duck Go</a>.</p>
<h2 id="AddingTitles"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AddingTitles')">¶</a> Adding Titles</h2>
<p>You can optionally add a title for a link. This will appear as a tooltip when the user hovers over the link. To add a title, enclose it in parentheses after the URL.</p>
<pre  class="language-text"><code class="language-text">My favorite search engine is [Duck Duck Go](https://duckduckgo.com &quot;The best search engine for privacy&quot;).
</code></pre><p>The rendered output looks like this:</p>
<p>My favorite search engine is <a href="https://duckduckgo.com" title="The best search engine for privacy">Duck Duck Go</a>.</p>
<h2 id="URLsandEmailAddresses"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'URLsandEmailAddresses')">¶</a> URLs and Email Addresses</h2>
<p>To quickly turn a URL or email address into a link, enclose it in angle brackets.</p>
<pre  class="language-text"><code class="language-text">&lt;https://www.markdownguide.org&gt;
&lt;fake@example.com&gt;
</code></pre><p>The rendered output looks like this:</p>
<p><a href="https://www.markdownguide.org">https://www.markdownguide.org</a></p>
<p><a href="mailto:fake@example.com">fake@example.com</a></p>
<h2 id="FormattingLinks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'FormattingLinks')">¶</a> Formatting Links</h2>
<p>To emphasize links, add asterisks before and after the brackets and parentheses. To denote links as code, add backticks in the brackets.</p>
<pre  class="language-text"><code class="language-text">I love supporting the **[EFF](https://eff.org)**.
This is the *[Markdown Guide](https://www.markdownguide.org)*.
See the section on [`code`](#code).
</code></pre><p>The rendered output looks like this:</p>
<p>I love supporting the <strong><a href="https://eff.org">EFF</a></strong>.<br>
This is the <em><a href="https://www.markdownguide.org">Markdown Guide</a></em>.<br>
See the section on <a href="#code"><code>code</code></a>.</p>
<h2 id="ReferencestyleLinks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'ReferencestyleLinks')">¶</a> Reference-style Links</h2>
<p>Reference-style links are a special kind of link that make URLs easier to display and read in Markdown. Reference-style links are constructed in two parts: the part you keep inline with your text and the part you store somewhere else in the file to keep the text easy to read.</p>
<h2 id="AnExamplePuttingthePartsTogether"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AnExamplePuttingthePartsTogether')">¶</a> An Example Putting the Parts Together</h2>
<p>Say you add a URL as a standard URL link to a paragraph and it looks like this in Markdown:</p>
<pre  class="language-text"><code class="language-text">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends
of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to
eat: it was a [hobbit-hole](https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;), and that means comfort.
</code></pre><p>Though it may point to interesting additional information, the URL as displayed really doesn’t add much to the existing raw text other than making it harder to read. To fix that, you could format the URL like this instead:</p>
<pre  class="language-text"><code class="language-text">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends
of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to
eat: it was a [hobbit-hole][1], and that means comfort.

[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;
</code></pre><p>In both instances above, the rendered output would be identical:</p>
<blockquote>
<p>In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends<br>
of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to<br>
eat: it was a <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle" title="Hobbit lifestyles">hobbit-hole</a>, and that means comfort.</p>
</blockquote>
<p>and the HTML for the link would be:</p>
<pre  class="language-text"><code class="language-text">&lt;a href=&quot;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&quot; title=&quot;Hobbit lifestyles&quot;&gt;hobbit-hole&lt;/a&gt;
</code></pre><h2 id="Images-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Images-2')">¶</a> Images</h2>
<p>To add an image, add an exclamation mark (!), followed by alt text in brackets, and the path or URL to the image asset in parentheses. You can optionally add a title after the URL in the parentheses.</p>
<pre  class="language-text"><code class="language-text">![Philadelphia's Magic Gardens. This place was so cool!](./philly-magic-garden.jpg &quot;Philadelphia's Magic Gardens&quot;)
</code></pre><p>The rendered output looks like this:</p>
<p><img src="_nuxt/img/philly-magic-garden.9c0b441.jpg" alt="Philadelphia's Magic Gardens. This place was so cool!" title="Philadelphia's Magic Gardens"></p>
<h2 id="LinkingImages"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'LinkingImages')">¶</a> Linking Images</h2>
<p>To add a link to an image, enclose the Markdown for the image in brackets, and then add the link in parentheses.</p>
<pre  class="language-text"><code class="language-text">[![An old rock in the desert](./shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv)
</code></pre><p>The rendered output looks like this:</p>
<p><a href="https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv"><img src="_nuxt/img/shiprock.c3b9a02.jpg" alt="An old rock in the desert" title="Shiprock, New Mexico by Beau Rogers"></a></p>
<h2 id="EscapingCharacters"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'EscapingCharacters')">¶</a> Escaping Characters</h2>
<p>To display a literal character that would otherwise be used to format text in a Markdown document, add a backslash () in front of the character.</p>
<pre  class="language-text"><code class="language-text">\* Without the backslash, this would be a bullet in an unordered list.
</code></pre><p>The rendered output looks like this:</p>
<p>* Without the backslash, this would be a bullet in an unordered list.</p>
<h2 id="CharactersYouCanEscape"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'CharactersYouCanEscape')">¶</a> Characters You Can Escape</h2>
<p>You can use a backslash to escape the following characters.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Character</th>
<th style="text-align:left">Name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">backslash</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">backtick</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">asterisk</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">underscore</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">curly braces</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">brackets</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">parentheses</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">pound sign</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">plus sign</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">minus sign (hyphen)</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">dot</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">pipe</td>
</tr>
</tbody>
</table>
<h2 id="HTML"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'HTML')">¶</a> HTML</h2>
<p>Many Markdown applications allow you to use HTML tags in Markdown-formatted text. This is helpful if you prefer certain HTML tags to Markdown syntax. For example, some people find it easier to use HTML tags for images. Using HTML is also helpful when you need to change the attributes of an element, like specifying the color of text or changing the width of an image.</p>
<p>To use HTML, place the tags in the text of your Markdown-formatted file.</p>
<pre  class="language-text"><code class="language-text">This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic.
</code></pre><p>The rendered output looks like this:</p>
<p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p>
<h2 id="Limitations"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Limitations')">¶</a> Limitations</h2>
<p>For security reasons, not all Markdown applications support HTML in Markdown documents. When in doubt, check your Markdown application’s documentation. Some applications support only a subset of HTML tags.</p>
<p>Use blank lines to separate block-level HTML elements like &lt;div&gt;, &lt;table&gt;, &lt;pre&gt;, and &lt;p&gt; from the surrounding content. Try not to indent the tags with tabs or spaces — that can interfere with the formatting.</p>
<p>You can’t use Markdown syntax inside block-level HTML tags. For example, &lt;p&gt;italic and **bold**&lt;/p&gt; won’t work.</p>
<hr>
<h2 id="Tables"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Tables')">¶</a> Tables</h2>
<p>To add a table, use three or more hyphens (---) to create each column’s header, and use pipes (|) to separate each column. You can optionally add pipes on either end of the table.</p>
<pre  class="language-text"><code class="language-text">| Syntax      | Description |
| ----------- | ----------- |
| Header      | Title       |
| Paragraph   | Text        |
</code></pre><p>The rendered output looks like this:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody>
</table>
<p>Cell widths can vary, as shown below. The rendered output will look the same.</p>
<pre  class="language-text"><code class="language-text">| Syntax | Description |
| --- | ----------- |
| Header | Title |
| Paragraph | Text |
</code></pre><h2 id="Alignment"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Alignment')">¶</a> Alignment</h2>
<p>You can align text in the columns to the left, right, or center by adding a colon (:) to the left, right, or on both side of the hyphens within the header row.</p>
<pre  class="language-text"><code class="language-text">| Syntax      | Description | Test Text     |
| :---        |    :----:   |          ---: |
| Header      | Title       | Here's this   |
| Paragraph   | Text        | And more      |
</code></pre><p>The rendered output looks like this:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Syntax</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Test Text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Header</td>
<td style="text-align:center">Title</td>
<td style="text-align:right">Here's this</td>
</tr>
<tr>
<td style="text-align:left">Paragraph</td>
<td style="text-align:center">Text</td>
<td style="text-align:right">And more</td>
</tr>
</tbody>
</table>
<h2 id="FormattingTextinTables"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'FormattingTextinTables')">¶</a> Formatting Text in Tables</h2>
<p>You can format the text within tables. For example, you can add links, code (words or phrases in backticks (`) only, not code blocks), and emphasis.</p>
<p>You can’t add headings, blockquotes, lists, horizontal rules, images, or HTML tags.</p>
<h2 id="EscapingPipeCharactersinTables"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'EscapingPipeCharactersinTables')">¶</a> Escaping Pipe Characters in Tables</h2>
<p>You can display a pipe (|) character in a table by using its HTML character code (&amp;#124;).</p>
<h2 id="FencedCodeBlocks"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'FencedCodeBlocks')">¶</a> Fenced Code Blocks</h2>
<p>The basic Markdown syntax allows you to create code blocks by indenting lines by four spaces or one tab. If you find that inconvenient, try using fenced code blocks. Depending on your Markdown processor or editor, you’ll use three backticks (```) or three tildes (~~~) on the lines before and after the code block. The best part? You don’t have to indent any lines!</p>
<pre  class="language-text"><code class="language-text">```//
{
  &quot;firstName&quot;: &quot;John&quot;,
  &quot;lastName&quot;: &quot;Smith&quot;,
  &quot;age&quot;: 25
}
```//
</code></pre><p>The rendered output looks like this:</p>
<pre  class="language-text"><code class="language-text">{
  &quot;firstName&quot;: &quot;John&quot;,
  &quot;lastName&quot;: &quot;Smith&quot;,
  &quot;age&quot;: 25
}
</code></pre><h2 id="SyntaxHighlighting"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SyntaxHighlighting')">¶</a> Syntax Highlighting</h2>
<p>Many Markdown processors support syntax highlighting for fenced code blocks. This feature allows you to add color highlighting for whatever language your code was written in. To add syntax highlighting, specify a language next to the backticks before the fenced code block.</p>
<pre  class="language-text"><code class="language-text">```json
{
  &quot;firstName&quot;: &quot;John&quot;,
  &quot;lastName&quot;: &quot;Smith&quot;,
  &quot;age&quot;: 25
}
```//
</code></pre><p>The rendered output looks like this:</p>
<pre  class="language-json"><code class="language-json">{
  &quot;firstName&quot;: &quot;John&quot;,
  &quot;lastName&quot;: &quot;Smith&quot;,
  &quot;age&quot;: 25
}
</code></pre><h2 id="HeadingIDs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'HeadingIDs')">¶</a> Heading IDs</h2>
<p>Many Markdown processors support custom IDs for headings — some Markdown processors automatically add them. Adding custom IDs allows you to link directly to headings and modify them with CSS. To add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading.</p>
<pre  class="language-text"><code class="language-text">### My Great Heading {#custom-id}
</code></pre><p>The HTML looks like this:</p>
<pre  class="language-html"><code class="language-html">&lt;h3 id=&quot;custom-id&quot;&gt;My Great Heading&lt;/h3&gt;
</code></pre><h2 id="LinkingtoHeadingIDs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'LinkingtoHeadingIDs')">¶</a> Linking to Heading IDs</h2>
<p>You can link to headings with custom IDs in the file by creating a standard link with a number sign (#) followed by the custom heading ID.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Markdown</th>
<th style="text-align:left">HTML</th>
<th style="text-align:left">Rendered Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[Heading IDs](#heading-ids)</td>
<td style="text-align:left">&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</td>
<td style="text-align:left"><a href="#heading-ids">Heading IDs</a></td>
</tr>
</tbody>
</table>
<p>Other websites can link to the heading by adding the custom heading ID to the full URL of the webpage (e.g, [Heading IDs](<a href="https://www.markdownguide.org/extended-syntax#heading-ids">https://www.markdownguide.org/extended-syntax#heading-ids</a>)).</p>
<h2 id="DefinitionLists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'DefinitionLists')">¶</a> Definition Lists</h2>
<p>Some Markdown processors allow you to create definition lists of terms and their corresponding definitions. To create a definition list, type the term on the first line. On the next line, type a colon followed by a space and the definition.</p>
<pre  class="language-text"><code class="language-text">First Term
: This is the definition of the first term.

Second Term
: This is one definition of the second term.
: This is another definition of the second term.
</code></pre><p>The HTML looks like this:</p>
<pre  class="language-html"><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;First Term&lt;/dt&gt;
  &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt;
  &lt;dt&gt;Second Term&lt;/dt&gt;
  &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt;
  &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;
&lt;/dl&gt;
</code></pre><p>The rendered output looks like this:</p>
<p>First Term<br>
: This is the definition of the first term.</p>
<p>Second Term<br>
: This is one definition of the second term.<br>
: This is another definition of the second term.</p>
<h2 id="Strikethrough"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Strikethrough')">¶</a> Strikethrough</h2>
<p>You can “strikethrough” words by putting a horizontal line through the center of them. The result looks like this. This feature allows you to indicate that certain words are a mistake not meant for inclusion in the document. To strikethrough words, use two tilde symbols (~~) before and after the words.</p>
<pre  class="language-text"><code class="language-text">~~The world is flat.~~ We now know that the world is round.
</code></pre><p>The rendered output looks like this:</p>
<p><s>The world is flat.</s> We now know that the world is round.</p>
<h2 id="TaskLists"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'TaskLists')">¶</a> Task Lists</h2>
<p>Task lists allow you to create a list of items with checkboxes. In Markdown applications that support task lists, checkboxes will be displayed next to the content. To create a task list, add dashes (-) and brackets with a space ([ ]) in front of task list items. To select a checkbox, add an x in between the brackets ([x]).</p>
<pre  class="language-text"><code class="language-text">- [x] Write the press release
- [ ] Update the website
- [ ] Contact the media
</code></pre><p>The rendered output looks like this:</p>
<ul>
<li>[x] Write the press release</li>
<li>[ ] Update the website</li>
<li>[ ] Contact the media</li>
</ul>
<h2 id="AutomaticURLLinking"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'AutomaticURLLinking')">¶</a> Automatic URL Linking</h2>
<p>Many Markdown processors automatically turn URLs into links. That means if you type <a href="http://www.example.com">http://www.example.com</a>, your Markdown processor will automatically turn it into a link even though you haven’t used brackets.</p>
<pre  class="language-text"><code class="language-text">http://www.example.com
</code></pre><p>The rendered output looks like this:</p>
<p><a href="http://www.example.com">http://www.example.com</a></p>
<h2 id="DisablingAutomaticURLLinking"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'DisablingAutomaticURLLinking')">¶</a> Disabling Automatic URL Linking</h2>
<p>If you don’t want a URL to be automatically linked, you can remove the link by denoting the URL as code with backticks.</p>
<pre  class="language-text"><code class="language-text">`http://www.example.com`
</code></pre><p>The rendered output looks like this:</p>
<p><code>http://www.example.com</code></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一文看全 Vue 3.X 带来的新变化]]></title>
            <link>/post/new-for-vue-3/</link>
            <guid>/post/new-for-vue-3/</guid>
            <description><![CDATA[只关注区别于 Vue 2.x 实现，助力快速过渡到 Vue 3.x]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#NEWxinzenggongnengtexing">NEW | 新增功能特性</a><ul><li><a href="#jichuxiangyingshiAPIReactivity">基础响应式 API Reactivity</a></li><li><a href="#Refs">Refs</a></li><li><a href="#Computed">Computed</a></li><li><a href="#WatchEffect">WatchEffect</a></li><li><a href="#Watch">Watch</a></li><li><a href="#setup">setup</a></li><li><a href="#setupzhuanyongshengmingzhouqigouzi">setup 专用生命周期钩子</a></li><li><a href="#Teleport">Teleport</a></li><li><a href="#duogenyuansuFragmentsmultirootnode">多根元素 Fragments(multi-root node)</a></li><li><a href="#Suspense">Suspense</a></li><li><a href="#zidingyishijianEvents">自定义事件 Events</a></li><li><a href="#zidingyixuanranqiRenderer">自定义渲染器 Renderer</a></li></ul></li><li><a href="#BREAKINGpohuaixinggenggai">BREAKING | 破坏性更改</a><ul><li><a href="#quanjuAPIGlobal">全局 API Global</a></li><li><a href="#shuangxiangbangdingvmodel">双向绑定 v-model</a></li><li><a href="#xuanranhanshuAPIRender">渲染函数 API Render</a></li><li><a href="#hanshushizujianFunctionalComponent">函数式组件 Functional Component</a></li><li><a href="#yibuzujianAsyncComponent">异步组件 Async Component</a></li><li><a href="#Dataxuanxiang">Data 选项</a></li><li><a href="#zidingyiyuansuElements">自定义元素 Elements</a></li><li><a href="#chacaoSlots">插槽 Slots</a></li><li><a href="#dongtaibangdingshuxingchuli">动态绑定属性处理</a></li><li><a href="#zidingyizhilingDirectives">自定义指令 Directives</a></li><li><a href="#donghuazujianTransitionComponent">动画组件 Transition Component</a></li><li><a href="#zhentingqiAPIWatch">侦听器 API Watch</a></li><li><a href="#xiangyingshizhuruProvideInject">响应式注入 Provide / Inject</a></li></ul></li><li><a href="#REMOVEDfeiqigongnengtexing">REMOVED | 废弃功能特性</a><ul><li><a href="#shijianAPIEvents">事件 API Events</a></li><li><a href="#shijianxiushifuKeyCode">事件修饰符 KeyCode</a></li><li><a href="#guolvqiFilters">过滤器 Filters</a></li><li><a href="#hangneimobanshuxinginlinetemplate">行内模板属性 inline-template</a></li></ul></li><li><a href="#zongjie">总结</a></li></ul></div></p>
<p>昨天(2020-07-18)，Vue 宣布 3.X 版本正式进入 <a href="https://github.com/vuejs/rfcs/issues/189" target="_blank">RC</a>阶段，进入 RC 阶段意味着 Vue 3.x 的核心实现已经趋于稳定，原则上在最终发布前不会再引入新的主要特性和破坏性更改，所以现在正是开始学习 Vue 3.x 的最好时机。</p>
<p>在通读了 Vue 3.x 最新的<a href="https://v3.vuejs.org/" target="_blank">官方文档</a>后，我总结了一下 Vue 3.x 对于 Vue 2.x 的一些主要变化，分别从新功能、破坏性更改和废弃特性三个方面进行汇总，方便在开发基于 Vue 3.x 新版本应用的时候进行快速查阅。可点击右侧 TOC 导航栏进行快速查看（PC 端）。</p>
<h2 id="NEWxinzenggongnengtexing"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'NEWxinzenggongnengtexing')">¶</a> NEW | 新增功能特性</h2>
<h3 id="jichuxiangyingshiAPIReactivity"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jichuxiangyingshiAPIReactivity')">¶</a> 基础响应式 API Reactivity</h3>
<h5 id="bianhuamiaoshu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu')">¶</a> 变化描述：</h5>
<ul>
<li>新增<code>reactive</code>全局 API，调用后返回一个响应式的<code>proxy</code>对象；</li>
<li>新增<code>readonly</code>全局 API，调用后根据源对象返回一个只读的<code>proxy</code>对象，如果源对象是响应式的，源对象发生变化时会同步变化；</li>
<li>新增<code>isProxy</code>全局 API，检查指定对象是否由<code>reactive</code>或者<code>readonly</code>创建；</li>
<li>新增<code>isReactive</code>全局 API，检查指定对象是否由<code>reactive</code>创建（经<code>readonly</code>创建的<code>reactive</code>值认为 true，e.g.，isReactive(readonly(reactive({}))) === true）；</li>
<li>新增<code>isReadonly</code>全局 API，检查指定对象是否由<code>readonly</code>创建；</li>
<li>新增<code>toRaw</code>全局 API，调用后返回一个<code>reactive</code>对象的原始对象；</li>
<li>新增<code>markRaw</code>全局 API，调用后返回一个不可被<code>reactive</code>将其作为源的对象；</li>
<li>新增<code>shallowReactive</code>全局 API，浅<code>reactive</code>，只将对象的顶层<code>reactive</code>；</li>
<li>新增<code>shallowReadonly</code>全局 API，浅<code>readonly</code>，只将对象的顶层<code>readonly</code>；</li>
</ul>
<h5 id="daimashili"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili')">¶</a> 代码示例：</h5>
<p><code>reactive</code>：</p>
<p>调用后返回一个响应式的<code>proxy</code>对象。</p>
<pre  class="language-js"><code class="language-js">const obj = reactive({ count: 0 });
</code></pre><hr>
<p><code>readonly</code>：</p>
<p>调用后根据源对象返回一个只读的<code>proxy</code>对象，如果源对象是响应式的，源对象发生变化时会同步变化。</p>
<pre  class="language-js"><code class="language-js">const original = reactive({ count: 0 });

const copy = readonly(original);

watchEffect(() =&gt; {
  // works for reactivity tracking
  console.log(copy.count);
});

// mutating original will trigger watchers relying on the copy
original.count++;

// mutating the copy will fail and result in a warning
copy.count++; // warning!
</code></pre><hr>
<p><code>isProxy</code>：</p>
<p>检查指定对象是否由<code>reactive</code>或者<code>readonly</code>创建。</p>
<pre  class="language-js"><code class="language-js">const rt = reactive({ count: 0 });
const rd = readonly(rt);
const plainObj = {};

isProxy(rt); // true
isProxy(rd); // true
isProxy(plainObj); // false
</code></pre><hr>
<p><code>isReactive</code>：</p>
<p>检查指定对象是否由<code>reactive</code>创建（经<code>readonly</code>创建的<code>reactive</code>值认为 true，e.g.，isReactive(readonly(reactive({}))) === true）。</p>
<pre  data-line="7-15" class="language-js"><code data-line="7-15" class="language-js">import { reactive, isReactive, readonly } from 'vue';
export default {
  setup() {
    const state = reactive({
      name: 'John',
    });
    // 由普通对象创建的 readonly proxy
    const plain = readonly({
      name: 'Mary',
    });
    console.log(isReactive(plain)); // -&gt; false

    // 由 reactive proxy 创建的 readonly proxy
    const stateCopy = readonly(state);
    console.log(isReactive(stateCopy)); // -&gt; true
  },
};
</code></pre><hr>
<p><code>isReadonly</code>：</p>
<p>检查指定对象是否由<code>readonly</code>创建。</p>
<pre  class="language-js"><code class="language-js">const rt = reactive({ count: 0 });
const rd = readonly(rt);
const plainObj = {};

isReadonly(rt); // false
isReadonly(rd); // true
isReadonly(plainObj); // false
</code></pre><hr>
<p><code>toRaw</code>：</p>
<p>调用后返回一个<code>reactive</code>对象的原始对象。</p>
<pre  class="language-js"><code class="language-js">const foo = {};
const reactiveFoo = reactive(foo);

console.log(toRaw(reactiveFoo) === foo); // true
</code></pre><hr>
<p><code>markRaw</code>：</p>
<p>调用后返回一个不可被<code>reactive</code>将其作为源的对象。</p>
<pre  class="language-js"><code class="language-js">const foo = markRaw({});
console.log(isReactive(reactive(foo))); // false

// 嵌套 reactive 也可使用
const bar = reactive({ foo });
console.log(isReactive(bar.foo)); // false

// 被 markRaw 对象的嵌套对象不受影响
const baz = markRaw({
  nested: {},
});
const qux = reactive({
  // 即使 `baz` 被标记为 raw, 但是 baz.nested 不受影响.
  nested: baz.nested,
});

console.log(baz.nested === qux.nested); // false
</code></pre><hr>
<p><code>shallowReactive</code>：</p>
<p>浅<code>reactive</code>，只将对象的顶层<code>reactive</code>。</p>
<pre  class="language-js"><code class="language-js">const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2,
  },
});

// 改变 state 自身的属性是响应式的
state.foo++;
// ...但是深层嵌套对象不是响应式的
isReactive(state.nested); // false
state.nested.bar++; // non-reactive
</code></pre><hr>
<p><code>shallowReadonly</code>：</p>
<p>浅<code>readonly</code>，只将对象的顶层<code>readonly</code>。</p>
<pre  class="language-js"><code class="language-js">const state = shallowReadonly({
  foo: 1,
  nested: {
    bar: 2,
  },
});

// 不可以改变 state 自身的属性值
state.foo++;
// ...但是深层嵌套对象的属性值可被改变
isReadonly(state.nested); // false
state.nested.bar++; // works
</code></pre><hr>
<h3 id="Refs"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Refs')">¶</a> Refs</h3>
<h5 id="bianhuamiaoshu-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-2')">¶</a> 变化描述：</h5>
<ul>
<li>新增<code>ref</code>全局 API，调用后返回一个基础值的响应式对象，该对象只有一个 value 固定值。当源值不是基础值（即对象）时，会静默地对该对象调用<code>reactive</code>；</li>
<li>新增<code>unref</code>全局 API，调用后返回一个<code>ref</code>值的 value 值，这个 API 是<code>val = isRef(val) ? val.value : val</code>的语法糖；</li>
<li>新增<code>toRef</code>全局 API，调用后返回一个<code>reactive</code>对象的指定属性作为<code>ref</code>，该<code>ref</code>与<code>reactive</code>的原值互相影响；</li>
<li>新增<code>toRefs</code>全局 API，调用后返回一个<code>reactive</code>对象的所有属性的<code>ref</code>集合，该<code>ref</code>集合的每一个属性值（即每一个 ref）与<code>reactive</code>的原值相互影响；</li>
<li>新增<code>isRef</code>全局 API，检查指定对象是否<code>ref</code>；</li>
<li>新增<code>customRef</code>全局 API，创建自定义的<code>ref</code>用于细粒度的控制依赖收集和触发，需要提供一个工厂函数，该工厂函数接受参数分别为<code>track</code>和<code>trigger</code>两个参数，返回值必须是带<code>get</code>、<code>set</code>方法的对象；</li>
<li>新增<code>shallowRef</code>全局 API，浅<code>ref</code>，因为对非基础值调用<code>ref</code>会隐式调用<code>reactive</code>，相当于对<code>ref</code>的 value 值调用<code>shallowReactive</code>；</li>
<li>新增<code>triggerRef</code>全局 API，改变由<code>shallowRef</code>创建的<code>ref</code>值后，手动触发<code>ref</code>更新以驱动<code>computed</code>和<code>watch</code>等逻辑；</li>
</ul>
<h5 id="daimashili-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-2')">¶</a> 代码示例：</h5>
<p><code>ref</code>：</p>
<p>调用后返回一个基础值的响应式对象，该对象只有一个 value 固定值。当源值不是基础值（即对象）时，会静默地对该对象调用<code>reactive</code>。</p>
<pre  class="language-js"><code class="language-js">const count = ref(0);
console.log(count.value); // 0

count.value++;
console.log(count.value); // 1
</code></pre><hr>
<p><code>unref</code>：</p>
<p>调用后返回一个<code>ref</code>值的 value 值，这个 API 是<code>val = isRef(val) ? val.value : val</code>的语法糖。</p>
<pre  class="language-js"><code class="language-js">function useFoo(x: number | Ref&lt;number&gt;) {
  const unwrapped = unref(x); // unwrapped is guaranteed to be number now
}
</code></pre><hr>
<p><code>toRef</code>：</p>
<p>调用后返回一个<code>reactive</code>对象的指定属性作为<code>ref</code>，该<code>ref</code>与<code>reactive</code>的原值互相影响。</p>
<pre  class="language-js"><code class="language-js">const state = reactive({
  foo: 1,
  bar: 2,
});

const fooRef = toRef(state, 'foo');

fooRef.value++;
console.log(state.foo); // 2

state.foo++;
console.log(fooRef.value); // 3
</code></pre><hr>
<p><code>toRefs</code>：</p>
<p>调用后返回一个<code>reactive</code>对象的所有属性的<code>ref</code>集合，该<code>ref</code>集合的每一个属性值（即每一个 ref）与<code>reactive</code>的原值相互影响。</p>
<pre  class="language-js"><code class="language-js">const state = reactive({
  foo: 1,
  bar: 2,
});

const stateAsRefs = toRefs(state);
/*
Type of stateAsRefs:

{
  foo: Ref&lt;number&gt;,
  bar: Ref&lt;number&gt;
}
*/

// The ref and the original property is &quot;linked&quot;
state.foo++;
console.log(stateAsRefs.foo.value); // 2

stateAsRefs.foo.value++;
console.log(state.foo); // 3
</code></pre><hr>
<p><code>isRef</code>：</p>
<p>检查指定对象是否<code>ref</code>。</p>
<pre  class="language-js"><code class="language-js">const count = ref(0);
const sum = 0;

isRef(count); // true
isRef(sum); // false
</code></pre><hr>
<p><code>customRef</code>：</p>
<p>创建自定义的<code>ref</code>用于细粒度的控制依赖收集和触发，需要提供一个工厂函数，该工厂函数接受参数分别为<code>track</code>和<code>trigger</code>两个参数，返回值必须是带<code>get</code>、<code>set</code>方法的对象。</p>
<pre  class="language-html"><code class="language-html">&lt;input v-model=&quot;text&quot; /&gt;
</code></pre><pre  class="language-js"><code class="language-js">function useDebouncedRef(value, delay = 200) {
  let timeout;
  return customRef((track, trigger) =&gt; {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        clearTimeout(timeout);
        timeout = setTimeout(() =&gt; {
          value = newValue;
          trigger();
        }, delay);
      },
    };
  });
}

export default {
  setup() {
    return {
      text: useDebouncedRef('hello'),
    };
  },
};
</code></pre><hr>
<p><code>shallowRef</code>：</p>
<p>因为对非基础值调用<code>ref</code>会隐式调用<code>reactive</code>，相当于对<code>ref</code>的 value 值调用<code>shallowReactive</code>。</p>
<pre  class="language-js"><code class="language-js">const foo = shallowRef({});
// mutating the ref's value is reactive
foo.value = {};
// but the value will not be converted.
isReactive(foo.value); // false
</code></pre><hr>
<p><code>triggerRef</code>：</p>
<p>新增<code>triggerRef</code>全局 API，改变由<code>shallowRef</code>创建的<code>ref</code>值后，手动触发<code>ref</code>更新以驱动<code>computed</code>和<code>watch</code>等逻辑。</p>
<pre  class="language-js"><code class="language-js">const shallow = shallowRef({
  greet: 'Hello, world',
});

// Logs &quot;Hello, world&quot; once for the first run-through
watchEffect(() =&gt; {
  console.log(shallow.value.greet);
});

// This won't trigger the effect because the ref is shallow
shallow.value.greet = 'Hello, universe';

// Logs &quot;Hello, universe&quot;
triggerRef(shallow);
</code></pre><hr>
<h3 id="Computed"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Computed')">¶</a> Computed</h3>
<h5 id="bianhuamiaoshu-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-3')">¶</a> 变化描述：</h5>
<ul>
<li>新增<code>computed</code>全局 API，调用该 API 创建动态计算值时，需要提供一个计算函数或者带有<code>get</code>和<code>set</code>函数的对象字面量；</li>
</ul>
<h5 id="daimashili-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-3')">¶</a> 代码示例：</h5>
<p>类型注解：</p>
<pre  class="language-js"><code class="language-js">// read-only
function computed&lt;T&gt;(getter: () =&gt; T): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt;

// writable
function computed&lt;T&gt;(options: { get: () =&gt; T; set: (value: T) =&gt; void }): Ref&lt;T&gt;
</code></pre><p>使用计算函数的情况：</p>
<pre  class="language-javascript"><code class="language-javascript">const count = ref(1);
const plusOne = computed(() =&gt; count.value++);

console.log(plusOne.value); // 2

plusOne.value++; // error
</code></pre><p>使用对象字面量的情况：</p>
<pre  class="language-javascript"><code class="language-javascript">const count = ref(1);
const plusOne = computed({
  get: () =&gt; count.value + 1,
  set: val =&gt; {
    count.value = val - 1;
  },
});

plusOne.value = 1;
console.log(count.value); // 0
</code></pre><hr>
<h3 id="WatchEffect"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'WatchEffect')">¶</a> WatchEffect</h3>
<h5 id="bianhuamiaoshu-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-4')">¶</a> 变化描述：</h5>
<ul>
<li>新增<code>watchEffect</code>全局 API，调用该函数侦听变化时，会<strong>立即执行</strong>一次；</li>
<li>调用该函数后返回<code>stop</code>函数，调用<code>stop</code>后停止侦听；</li>
<li><code>watchEffect</code>的第一个参数为 handle 函数，该 handle 函数接收<code>onInvalidate</code>函数，<code>onInvalidate</code>在<code>watchEffect</code>被重新触发或者被终止时触发；</li>
<li><code>watchEffect</code>的第二个参数为侦听选项，值为对象字面量，
<ul>
<li>选项<code>flush</code>，用于控制<code>watchEffect</code>的执行时机：<pre  class="language-text"><code class="language-text">pre  -&gt; 在组件更新前运行
sync -&gt; 在组件更新时同步运行
post -&gt; 在组件更新后运行（默认）
</code></pre></li>
<li>选项<code>onTrack</code>，<code>watchEffect</code>依赖收集时调用，用于 debugger，只在开发模式（development）可用；</li>
<li>选项<code>onTrigger</code>，<code>watchEffect</code>重新运行时调用，用于 debugger，只在开发模式（development）可用；</li>
</ul>
</li>
</ul>
<h5 id="daimashili-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-4')">¶</a> 代码示例：</h5>
<p>类型注解：</p>
<pre  class="language-js"><code class="language-js">function watchEffect(
  effect: (onInvalidate: InvalidateCbRegistrator) =&gt; void,
  options?: WatchEffectOptions
): StopHandle

interface WatchEffectOptions {
  flush?: 'pre' | 'post' | 'sync'
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}

interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}

type InvalidateCbRegistrator = (invalidate: () =&gt; void) =&gt; void

type StopHandle = () =&gt; void
</code></pre><p>默认使用方式：</p>
<pre  class="language-javascript"><code class="language-javascript">const count = ref(0);

const stop = watchEffect(() =&gt; console.log(count.value));
// -&gt; logs 0

setTimeout(() =&gt; {
  count.value++;
  // -&gt; logs 1
}, 100);

// later 手动结束 watchEffect
setTimeout(() =&gt; {
  stop();
}, 200);
</code></pre><p>同步 Invalidation sync：</p>
<pre  class="language-javascript"><code class="language-javascript">watchEffect(onInvalidate =&gt; {
  const token = performAsyncOperation(id.value);
  onInvalidate(() =&gt; {
    // id 发生了变化或者 watcher 被终止
    // 手动终止上一个未结束的异步操作
    token.cancel();
  });
});
</code></pre><p>异步 Invalidation async：</p>
<pre  class="language-javascript"><code class="language-javascript">const data = ref(null)
watchEffect(async onInvalidate =&gt; {
  onInvalidate(() =&gt; {...}) // 在异步函数 resolve 前注册清理函数
  data.value = await fetchData(props.id)
})
</code></pre><p>参数选项：</p>
<pre  class="language-javascript"><code class="language-javascript">watchEffect(
  () =&gt; {
    /* side effect */
  },
  {
    flush: 'pre', // 改变执行时机
    // 收集依赖时 debug
    onTrack(e) {
      debugger;
    },
    // 被触发时 debug
    onTrigger(e) {
      debugger;
    },
  },
);
</code></pre><hr>
<h3 id="Watch"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Watch')">¶</a> Watch</h3>
<h5 id="bianhuamiaoshu-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-5')">¶</a> 变化描述：</h5>
<ul>
<li>新增<code>watch</code>全局 API，调用该函数侦听变化时，默认执行方式为<code>lazy</code>；</li>
<li>可同时侦听多个属性；</li>
<li><code>watch</code>的第二个参数为 handle 函数，该 handle 函数接收<code>onInvalidate</code>函数，<code>onInvalidate</code>在<code>watch</code>被重新触发或者被终止时触发；</li>
<li><code>watch</code>的第三个参数为侦听选项，值为对象字面量，
<ul>
<li>选项<code>flush</code>，用于控制<code>watch</code>的执行时机：<pre  class="language-text"><code class="language-text">pre  -&gt; 在组件更新前运行
sync -&gt; 在组件更新时同步运行
post -&gt; 在组件更新后运行（默认）
</code></pre></li>
<li>选项<code>onTrack</code>，<code>watch</code>依赖收集时调用，用于 debugger，只在开发模式（development）可用；</li>
<li>选项<code>onTrigger</code>，<code>watch</code>重新运行时调用，用于 debugger，只在开发模式（development）可用；</li>
</ul>
</li>
</ul>
<h5 id="daimashili-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-5')">¶</a> 代码示例：</h5>
<p>类型注解：</p>
<pre  class="language-js"><code class="language-js">// 侦听单个属性源
function watch&lt;T&gt;(
  source: WatcherSource&lt;T&gt;,
  callback: (
    value: T,
    oldValue: T,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options?: WatchOptions
): StopHandle

// 侦听多个属性源
function watch&lt;T extends WatcherSource&lt;unknown&gt;[]&gt;(
  sources: T
  callback: (
    values: MapSources&lt;T&gt;,
    oldValues: MapSources&lt;T&gt;,
    onInvalidate: InvalidateCbRegistrator
  ) =&gt; void,
  options? : WatchOptions
): StopHandle

type WatcherSource&lt;T&gt; = Ref&lt;T&gt; | (() =&gt; T)

type MapSources&lt;T&gt; = {
  [K in keyof T]: T[K] extends WatcherSource&lt;infer V&gt; ? V : never
}

// 从 `watchEffect` 类型扩展
interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // default: false
  deep?: boolean
  // flush?: 'pre' | 'post' | 'sync'
  // onTrack?: (event: DebuggerEvent) =&gt; void
  // onTrigger?: (event: DebuggerEvent) =&gt; void
}

interface DebuggerEvent {
  effect: ReactiveEffect
  target: any
  type: OperationTypes
  key: string | symbol | undefined
}

type InvalidateCbRegistrator = (invalidate: () =&gt; void) =&gt; void

type StopHandle = () =&gt; void
</code></pre><p>侦听单属性：</p>
<pre  class="language-javascript"><code class="language-javascript">// 侦听 getter
const state = reactive({ count: 0 });
watch(
  () =&gt; state.count,
  (count, prevCount) =&gt; {
    /* ... */
  },
);

// 直接侦听 ref
const count = ref(0);
const stop = watch(count, (count, prevCount) =&gt; {
  /* ... */
});

// later 手动结束 watch
setTimeout(() =&gt; {
  stop();
}, 200);
</code></pre><p>侦听多属性：</p>
<pre  class="language-javascript"><code class="language-javascript">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; {
  /* ... */
});
</code></pre><p>同步 Invalidation sync：</p>
<pre  class="language-javascript"><code class="language-javascript">const data = ref(null);
watch(data, (data, prevData, onInvalidate) =&gt; {
  const token = performAsyncOperation(data.value);
  onInvalidate(() =&gt; {
    // id 发生了变化或者 watcher 被终止
    // 手动终止上一个未结束的异步操作
    token.cancel();
  });
});
</code></pre><p>异步 Invalidation async：</p>
<pre  class="language-javascript"><code class="language-javascript">const data = ref(null);
watch(data, async (data, prevData, onInvalidate) =&gt; {
  onInvalidate(() =&gt; {...}); // 在异步函数 resolve 前注册清理函数
  data.value = await fetchData(props.id);
})
</code></pre><p>参数选项：</p>
<pre  class="language-javascript"><code class="language-javascript">const data = ref(null);
watch(
  data,
  (data, prevData) =&gt; {
    /* side effect */
  },
  {
    immediate: true, // 立即执行
    deep: true, // 深度侦听
    flush: 'pre', // 改变执行时机
    // 收集依赖时 debug
    onTrack(e) {
      debugger;
    },
    // 被触发时 debug
    onTrigger(e) {
      debugger;
    },
  },
);
</code></pre><hr>
<h3 id="setup"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'setup')">¶</a> setup</h3>
<h5 id="bianhuamiaoshu-6"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-6')">¶</a> 变化描述：</h5>
<ul>
<li>添加<code>setup</code>组件选项，在组件<strong>创建前</strong>被调用，接收<code>props</code>和<code>context</code>两个参数；</li>
</ul>
<h5 id="daimashili-6"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-6')">¶</a> 代码示例：</h5>
<p>类型注解：</p>
<pre  class="language-js"><code class="language-js">interface Data {
  [key: string]: unknown;
}

interface SetupContext {
  attrs: Data;
  slots: Slots;
  emit: (event: string, ...args: unknown[]) =&gt; void;
}

function setup(props: Data, context: SetupContext): Data;
</code></pre><p>使用<code>&lt;template&gt;</code>的方式：</p>
<pre  class="language-html"><code class="language-html">&lt;!-- MyBook.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ readersNumber }} {{ book.title }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { ref, reactive } from 'vue';

  export default {
    setup() {
      const readersNumber = ref(0);
      const book = reactive({ title: 'Vue 3 Guide' });

      // expose to template
      return {
        readersNumber,
        book,
      };
    },
  };
&lt;/script&gt;
</code></pre><p>使用<code>render</code> function 的方式：</p>
<pre  data-line="10" class="language-js"><code data-line="10" class="language-js">// MyBook.vue

import { h, ref, reactive } from 'vue';

export default {
  setup() {
    const readersNumber = ref(0);
    const book = reactive({ title: 'Vue 3 Guide' });
    // 注意返回的 render 函数内使用 ref 类型的值，应该取它的 value 值
    return () =&gt; h('div', [readersNumber.value, book.title]);
  },
};
</code></pre><hr>
<h3 id="setupzhuanyongshengmingzhouqigouzi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'setupzhuanyongshengmingzhouqigouzi')">¶</a> setup 专用生命周期钩子</h3>
<h5 id="bianhuamiaoshu-7"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-7')">¶</a> 变化描述：</h5>
<ul>
<li>
<p>增加<code>setup()</code>专用的生命周期钩子，除<code>beforeCreate</code>和<code>created</code>外其它钩子与选项内的钩子相同，如同下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项 API</th>
<th style="text-align:left"><code>setup()</code>内 API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">beforeCreate</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">created</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">beforeMount</td>
<td style="text-align:left">onBeforeMount</td>
</tr>
<tr>
<td style="text-align:left">mounted</td>
<td style="text-align:left">onMounted</td>
</tr>
<tr>
<td style="text-align:left">beforeUpdate</td>
<td style="text-align:left">onBeforeUpdate</td>
</tr>
<tr>
<td style="text-align:left">updated</td>
<td style="text-align:left">onUpdated</td>
</tr>
<tr>
<td style="text-align:left">beforeUnmount</td>
<td style="text-align:left">onBeforeUnmount</td>
</tr>
<tr>
<td style="text-align:left">unmounted</td>
<td style="text-align:left">onUnmounted</td>
</tr>
<tr>
<td style="text-align:left">errorCaptured</td>
<td style="text-align:left">onErrorCaptured</td>
</tr>
<tr>
<td style="text-align:left">renderTracked</td>
<td style="text-align:left">onRenderTracked</td>
</tr>
<tr>
<td style="text-align:left">renderTriggered</td>
<td style="text-align:left">onRenderTriggered</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h5 id="daimashili-7"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-7')">¶</a> 代码示例：</h5>
<pre  class="language-javascript"><code class="language-javascript">import { onMounted, onUpdated, onUnmounted } from 'vue';

const MyComponent = {
  setup() {
    onMounted(() =&gt; {
      console.log('mounted!');
    });
    onUpdated(() =&gt; {
      console.log('updated!');
    });
    onUnmounted(() =&gt; {
      console.log('unmounted!');
    });
  },
};
</code></pre><hr>
<h3 id="Teleport"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Teleport')">¶</a> Teleport</h3>
<h5 id="bianhuamiaoshu-8"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-8')">¶</a> 变化描述：</h5>
<ul>
<li>添加<code>&lt;teleport&gt;</code>组件；</li>
<li>需要通过 prop <code>to</code> 给<code>&lt;teleport&gt;</code>组件提供一个目标元素，值可选项为<code>HTMLElement</code>或者是一个合法的<code>querySelector</code>字符串；</li>
<li><code>&lt;teleport&gt;</code>组件将会移动它的 children 元素到上面指定的 DOM；</li>
<li>在 virtual DOM 的层面上，children 元素仍属于<code>&lt;teleport&gt;</code>的后代，因此<code>&lt;teleport&gt;</code>包含的其它自定义子组件可以访问到祖先组件的注入（injections）；</li>
<li>多个<code>&lt;teleport&gt;</code>组件具有相同的<code>to</code>目标时，将会按照组件顺序 append 到目标 DOM 内；</li>
</ul>
<h5 id="daimashili-8"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-8')">¶</a> 代码示例：</h5>
<pre  data-line="4,14" class="language-html"><code data-line="4,14" class="language-html">&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;Move the #content with the portal component&lt;/h1&gt;
    &lt;teleport to=&quot;#endofbody&quot;&gt;
      &lt;div id=&quot;content&quot;&gt;
        &lt;p&gt;
          this will be moved to #endofbody.&lt;br /&gt;
          Pretend that it's a modal
        &lt;/p&gt;
        &lt;Child /&gt;
      &lt;/div&gt;
    &lt;/teleport&gt;
  &lt;/div&gt;
  &lt;div id=&quot;endofbody&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    new Vue({
      el: '#app',
      components: {
        Child: { template: '&lt;div&gt;Placeholder&lt;/div&gt;' },
      },
    });
  &lt;/script&gt;
&lt;/body&gt;
</code></pre><pre  class="language-html"><code class="language-html">&lt;!-- result--&gt;

&lt;div id=&quot;app&quot;&gt;
  &lt;!-- --&gt;
&lt;/div&gt;
&lt;div id=&quot;endofbody&quot;&gt;
  &lt;div id=&quot;content&quot;&gt;
    &lt;p&gt;
      this will be moved to #endofbody.&lt;br /&gt;
      Pretend that it's a modal
    &lt;/p&gt;
    &lt;div&gt;Placeholder&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>多个<code>&lt;teleport&gt;</code>目标为同一个 DOM 的情况：</p>
<pre  class="language-html"><code class="language-html">&lt;teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
&lt;/teleport&gt;
&lt;teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/teleport&gt;
</code></pre><pre  class="language-html"><code class="language-html">&lt;!-- result--&gt;

&lt;div id=&quot;modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/div&gt;
</code></pre><hr>
<h3 id="duogenyuansuFragmentsmultirootnode"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'duogenyuansuFragmentsmultirootnode')">¶</a> 多根元素 Fragments(multi-root node)</h3>
<h5 id="bianhuamiaoshu-9"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-9')">¶</a> 变化描述：</h5>
<ul>
<li>不再限制自定义组件只能具有一个根元素，支持多个根元素的情况；</li>
</ul>
<h5 id="daimabianhuaduibi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;...&lt;/header&gt;
    &lt;main&gt;...&lt;/main&gt;
    &lt;footer&gt;...&lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>3.x</p>
<pre  class="language-html"><code class="language-html">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
  &lt;header&gt;...&lt;/header&gt;
  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main
  &gt;&lt;!-- 手动绑定组件外部未声明为 prop 的属性 --&gt;
  &lt;footer&gt;...&lt;/footer&gt;
&lt;/template&gt;
</code></pre><hr>
<h3 id="Suspense"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Suspense')">¶</a> Suspense</h3>
<h5 id="bianhuamiaoshu-10"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-10')">¶</a> 变化描述：</h5>
<ul>
<li>增加<code>&lt;suspense&gt;</code>组件，用于控制数据显示；</li>
<li>需要提供两个<code>&lt;template&gt;</code>作为<code>&lt;suspense&gt;</code>的子元素，id 为<code>default</code>的模板装载的内容为正常显示内容，id 为<code>fallback</code>的模板装载的内容为无内容时显示；</li>
</ul>
<h5 id="daimashili-9"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-9')">¶</a> 代码示例：</h5>
<pre  data-line="3,11" class="language-html"><code data-line="3,11" class="language-html">&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;div v-for=&quot;item in articleList&quot; :key=&quot;item.id&quot;&gt;
        &lt;article&gt;
          &lt;h2&gt;{{ item.title }}&lt;/h2&gt;
          &lt;p&gt;{{ item.body }}&lt;/p&gt;
        &lt;/article&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      Articles loading...
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;

&lt;script&gt;
  import getArticleList from 'getArticleList';
  export default {
    async setup() {
      let articleList = await getArticleList();
      return {
        articleList,
      };
    },
  };
&lt;/script&gt;
</code></pre><hr>
<h3 id="zidingyishijianEvents"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zidingyishijianEvents')">¶</a> 自定义事件 Events</h3>
<h5 id="bianhuamiaoshu-11"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-11')">¶</a> 变化描述：</h5>
<ul>
<li>增加组件<code>emits</code>选项，用于定义该组件需要关注的事件，当该选项包含原生事件（e.g.，<code>click</code>）时，该原生事件将被组件的自定义事件覆盖；</li>
<li><code>emits</code>选项内可指定事件的校验函数，用于事件触发时校验提供的参数是否合理；</li>
</ul>
<h5 id="daimashili-10"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-10')">¶</a> 代码示例：</h5>
<p>使用数组结构定义：</p>
<pre  class="language-js"><code class="language-js">app.component('custom-form', {
  emits: ['in-focus', 'submit'],
});
</code></pre><p>使用对象结构定义：</p>
<pre  class="language-javascript"><code class="language-javascript">app.component('custom-form', {
  emits: {
    // 不校验事件
    click: null,

    // 校验触发的事件
    submit: ({ email, password }) =&gt; {
      if (email &amp;&amp; password) {
        return true;
      } else {
        console.warn('Invalid submit event payload!');
        return false;
      }
    },
  },
  methods: {
    submitForm() {
      this.$emit('submit', { email, password });
    },
  },
});
</code></pre><hr>
<h3 id="zidingyixuanranqiRenderer"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zidingyixuanranqiRenderer')">¶</a> 自定义渲染器 Renderer</h3>
<h5 id="bianhuamiaoshu-12"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-12')">¶</a> 变化描述：</h5>
<ul>
<li>支持使用 API<code>createRenderer</code>自定义渲染器，调用该 API 需要返回<code>render</code>和<code>createApp</code>两个全局 API；</li>
</ul>
<h5 id="daimashili-11"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashili-11')">¶</a> 代码示例：</h5>
<pre  class="language-js"><code class="language-js">import { createRenderer } from 'vue'
const { render, createApp } = createRenderer&lt;Node, Element&gt;({
  patchProp,
  ...nodeOps
});
</code></pre><hr>
<h2 id="BREAKINGpohuaixinggenggai"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BREAKINGpohuaixinggenggai')">¶</a> BREAKING | 破坏性更改</h2>
<h3 id="quanjuAPIGlobal"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'quanjuAPIGlobal')">¶</a> 全局 API Global</h3>
<h5 id="bianhuamiaoshu-13"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-13')">¶</a> 变化描述：</h5>
<ul>
<li>
<p>提供的新的<code>createApp</code> api 用以声明式实例化应用；</p>
</li>
<li>
<p>部分<code>Vue</code>构造函数的静态方法转变为全局方法，并移除<code>$</code>开头的同名实例方法，整体变化如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">2.x 静态方法</th>
<th style="text-align:left">3.x 全局方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vue.nextTick</td>
<td style="text-align:left">nextTick</td>
</tr>
<tr>
<td style="text-align:left">Vue.observable</td>
<td style="text-align:left">reactive</td>
</tr>
<tr>
<td style="text-align:left">Vue.version</td>
<td style="text-align:left">version</td>
</tr>
<tr>
<td style="text-align:left">Vue.compile</td>
<td style="text-align:left">compile</td>
</tr>
<tr>
<td style="text-align:left">Vue.set</td>
<td style="text-align:left">set</td>
</tr>
<tr>
<td style="text-align:left">Vue.delete</td>
<td style="text-align:left">delete</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>部分全局 API 变为实例 API，整体变化如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">2.x 全局 API</th>
<th style="text-align:left">3.x 实例 API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vue.config</td>
<td style="text-align:left">app.config</td>
</tr>
<tr>
<td style="text-align:left">Vue.config.productionTip</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">Vue.config.ignoredElements</td>
<td style="text-align:left">app.config.isCustomElement</td>
</tr>
<tr>
<td style="text-align:left">Vue.component</td>
<td style="text-align:left">app.component</td>
</tr>
<tr>
<td style="text-align:left">Vue.directive</td>
<td style="text-align:left">app.directive</td>
</tr>
<tr>
<td style="text-align:left">Vue.mixin</td>
<td style="text-align:left">app.mixin</td>
</tr>
<tr>
<td style="text-align:left">Vue.use</td>
<td style="text-align:left">app.use</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>提供内部帮助函数作为全局 API，例如<code>h</code>、<code>Transition</code>、<code>withDirectives</code>、<code>vShow</code>...</p>
</li>
</ul>
<h5 id="daimashixian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian')">¶</a> 代码实现：</h5>
<p><code>createApp</code></p>
<pre  class="language-javascript"><code class="language-javascript">import { createApp } from 'vue';

const app = createApp({});
app.mount('#app');
</code></pre><p>全局方法：</p>
<pre  class="language-js"><code class="language-js">import { shallowMount } from '@vue/test-utils';
import { MyComponent } from './MyComponent.vue';
import { nextTick } from 'vue';

test('an async feature', async () =&gt; {
  const wrapper = shallowMount(MyComponent);

  // execute some DOM-related tasks

  await nextTick();

  // run your assertions
});
</code></pre><p>实例方法：</p>
<pre  class="language-js"><code class="language-js">const app = createApp(MyApp);

app.component('button-counter', {
  data: () =&gt; ({
    count: 0,
  }),
  template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;',
});

app.directive('focus', {
  mounted: el =&gt; el.focus(),
});

// now every application instance mounted with app.mount(), along with its
// component tree, will have the same “button-counter” component
// and “focus” directive without polluting the global environment
app.mount('#app');
</code></pre><p>内部帮助函数：</p>
<pre  class="language-js"><code class="language-js">import { h, Transition, withDirectives, vShow } from 'vue';

export function render() {
  return h(Transition, [withDirectives(h('div', 'hello'), [[vShow, this.ok]])]);
}
</code></pre><hr>
<h3 id="shuangxiangbangdingvmodel"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shuangxiangbangdingvmodel')">¶</a> 双向绑定 v-model</h3>
<h5 id="bianhuamiaoshu-14"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-14')">¶</a> 变化描述：</h5>
<ul>
<li>自定义组件内的<code>v-model</code>的 prop 和 event 默认名称变更如下：<pre  class="language-text"><code class="language-text">prop: value -&gt; modelValue;
event: input -&gt; update:modelValue;
</code></pre></li>
<li><code>v-bind</code>的<code>.sync</code>修饰符和自定义组件的<code>model</code>选项移除，并用<code>v-model</code>上的参数作为替代；</li>
<li>自定义组件支持多个自定义的<code>v-model</code>绑定；</li>
<li><code>v-model</code>支持自定义修饰符；</li>
</ul>
<h5 id="daimabianhuaduibi-2"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-2')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<p>默认使用方式：</p>
<pre  class="language-html"><code class="language-html">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;

&lt;!-- 等价于下面的写法: --&gt;

&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;
</code></pre><p>自定义<code>v-model</code>的 prop 和 event 的使用方式：</p>
<pre  class="language-html"><code class="language-html">&lt;!-- ParentComponent.vue --&gt;

&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;
</code></pre><pre  data-line="4-7" class="language-js"><code data-line="4-7" class="language-js">// ChildComponent.vue

export default {
  model: {
    prop: 'title',
    event: 'change',
  },
  props: {
    // 释放 `value` prop 以用作其它用途
    value: String,
    // 使用 `title` 替换默认的 `value` v-model 值
    title: {
      type: String,
      default: 'Default title',
    },
  },
};
</code></pre><pre  class="language-html"><code class="language-html">&lt;!-- 等价于下面的写法: --&gt;

&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;
</code></pre><p>使用<code>v-bind.sync</code>的方式：</p>
<pre  class="language-js"><code class="language-js">// 在子组件内 emit 以 :update 开头的自定义事件

this.$emit('update:title', newValue);
</code></pre><pre  class="language-html"><code class="language-html">&lt;!-- 监听自定义的 update 事件 --&gt;

&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;

&lt;!-- 等价于下面的写法: --&gt;

&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;
</code></pre><p>3.x</p>
<p>默认使用方式：</p>
<pre  class="language-html"><code class="language-html">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;

&lt;!-- 等价于下面的写法: --&gt;
&lt;!-- value -&gt; modelValue --&gt;
&lt;!-- input -&gt; update:modelValue --&gt;

&lt;ChildComponent :modelValue=&quot;pageTitle&quot; @update:modelValue=&quot;pageTitle = $event&quot; /&gt;
</code></pre><p>自定义<code>v-model</code>和多个<code>v-model</code>的方式（<code>.sync</code>因这种实现方式而不再有用，所以废除）：</p>
<pre  class="language-html"><code class="language-html">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; v-model:content=&quot;pageContent&quot; /&gt;

&lt;!-- 等价于下面的写法: --&gt;

&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; :content=&quot;pageContent&quot; @update:content=&quot;pageContent = $event&quot; /&gt;
</code></pre><p><img src="_nuxt/img/pic-0.cb59705.png" alt=""></p>
<hr>
<p><code>v-model</code>自定义修饰符：</p>
<pre  data-line="2" class="language-html"><code data-line="2" class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-component v-model.capitalize=&quot;myText&quot;&gt;&lt;/my-component&gt;
  {{ myText }}
&lt;/div&gt;
</code></pre><pre  data-line="13-15,21" class="language-js"><code data-line="13-15,21" class="language-js">const app = Vue.createApp({
  data() {
    return {
      myText: '',
    };
  },
});

app.component('my-component', {
  props: {
    modelValue: String,
    // 默认修饰符的 prop 为 modelModifiers，自定义 v-model 的修饰符形如：[propName]Modifiers，
    modelModifiers: {
      default: () =&gt; ({}),
    },
  },
  methods: {
    emitValue(e) {
      let value = e.target.value;
      // 根据修饰符可以做相应处理
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
      }
      this.$emit('update:modelValue', value);
    },
  },
  template: `&lt;input
    type=&quot;text&quot;
    :value=&quot;modelValue&quot;
    @input=&quot;emitValue&quot;&gt;`,
});

app.mount('#app');
</code></pre><p>自定义 v-model 情况下的自定义修饰符：</p>
<pre  class="language-html"><code class="language-html">&lt;my-component v-model:foo.capitalize=&quot;bar&quot;&gt;&lt;/my-component&gt;
</code></pre><pre  data-line="2,9" class="language-js"><code data-line="2,9" class="language-js">app.component('my-component', {
  props: ['foo', 'fooModifiers'],
  template: `
    &lt;input type=&quot;text&quot;
      :value=&quot;foo&quot;
      @input=&quot;$emit('update:foo', $event.target.value)&quot;&gt;
  `,
  created() {
    console.log(this.fooModifiers); // { capitalize: true }
  },
});
</code></pre><hr>
<h3 id="xuanranhanshuAPIRender"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xuanranhanshuAPIRender')">¶</a> 渲染函数 API Render</h3>
<h5 id="bianhuamiaoshu-15"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-15')">¶</a> 变化描述：</h5>
<ul>
<li><code>h</code>需要从<code>Vue</code>全局引入，以取代原<code>render</code>函数内提供的<code>createElement</code>函数；</li>
<li>render 函数不再接受任何参数；</li>
<li>VNodes 的 props 结构扁平化；</li>
</ul>
<h5 id="daimabianhuaduibi-3"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-3')">¶</a> 代码变化对比：</h5>
<p>render 函数参数</p>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// Vue 2 Render Function Example
export default {
  render(h) {
    return h('div');
  },
};
</code></pre><p>3.x</p>
<pre  data-line="2" class="language-javascript"><code data-line="2" class="language-javascript">// Vue 3 Render Function Example
import { h } from 'vue';

export default {
  render() {
    return h('div');
  },
};
</code></pre><hr>
<p>render 函数签名变化</p>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// Vue 2 Render Function Example
export default {
  render(h) {
    return h('div');
  },
};
</code></pre><p>3.x</p>
<pre  class="language-javascript"><code class="language-javascript">import { h, reactive } from 'vue';

export default {
  setup(props, { slots, attrs, emit }) {
    const state = reactive({
      count: 0,
    });

    function increment() {
      state.count++;
    }

    // return the render function
    return () =&gt;
      h(
        'div',
        {
          onClick: increment,
        },
        state.count,
      );
  },
};
</code></pre><hr>
<p>VNode props 格式</p>
<p>2.x</p>
<pre  class="language-js"><code class="language-js">// 2.x
{
  class: ['button', 'is-outlined'],
  style: { color: '#34495E' },
  attrs: { id: 'submit' },
  domProps: { innerHTML: '' },
  on: { click: submitForm },
  key: 'submit-button'
}
</code></pre><p>3.x</p>
<pre  data-line="5-7" class="language-js"><code data-line="5-7" class="language-js">// 3.x Syntax
{
  class: ['button', 'is-outlined'],
  style: { color: '#34495E' },
  id: 'submit',
  innerHTML: '',
  onClick: submitForm,
  key: 'submit-button'
}
</code></pre><hr>
<h3 id="hanshushizujianFunctionalComponent"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'hanshushizujianFunctionalComponent')">¶</a> 函数式组件 Functional Component</h3>
<h5 id="bianhuamiaoshu-16"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-16')">¶</a> 变化描述：</h5>
<ul>
<li>函数式组件的性能优化已经在 3.x 被忽略，建议只使用有状态的组件；</li>
<li>函数式组件只能使用简单函数创建，该函数接收<code>props</code>和<code>context</code>两个参数；</li>
<li>单文件组件的<code>functional</code>属性移除；</li>
<li><code>{ functional: true }</code>选项移除；</li>
</ul>
<h5 id="daimabianhuaduibi-4"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-4')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<p>无<code>&lt;template&gt;</code>的情况：</p>
<pre  data-line="2" class="language-javascript"><code data-line="2" class="language-javascript">export default {
  functional: true,
  props: ['level'],
  render(h, { props, data, children }) {
    return h(`h${props.level}`, data, children);
  },
};
</code></pre><p>带<code>&lt;template&gt;</code>的情况：</p>
<pre  data-line="2" class="language-html"><code data-line="2" class="language-html">&lt;template&gt;
  &lt;template functional&gt;
    &lt;component :is=&quot;`h${props.level}`&quot; v-bind=&quot;attrs&quot; v-on=&quot;listeners&quot; /&gt;
  &lt;/template&gt;

  &lt;script&gt;
    export default {
      props: ['level'],
    };
  &lt;/script&gt;&lt;/template
&gt;
</code></pre><p>3.x</p>
<pre  class="language-javascript"><code class="language-javascript">import { h } from 'vue';

const DynamicHeading = (props, context) =&gt; {
  return h(`h${props.level}`, context.attrs, context.slots);
};

DynamicHeading.props = ['level'];

export default DynamicHeading;
</code></pre><hr>
<h3 id="yibuzujianAsyncComponent"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yibuzujianAsyncComponent')">¶</a> 异步组件 Async Component</h3>
<h5 id="bianhuamiaoshu-17"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-17')">¶</a> 变化描述：</h5>
<ul>
<li>使用新的<code>defineAsyncComponent</code>方法定义异步组件；</li>
<li>定义组件带选项时，<code>component</code>更名为<code>loader</code>；</li>
<li>新的<code>loader</code>选项必须返回一个 <strong><em>Promise</em></strong>；</li>
<li>定义组件带选项时，<code>loading</code>更名为<code>LoadingComponent</code>；</li>
<li>定义组件带选项时，<code>error</code>更名为<code>errorComponent</code>；</li>
<li>新增定义组件选项<code>retryWhen</code>，用于控制当组件加载失败时，指定情况才进行重试加载；</li>
<li>新增定义组件选项<code>maxRetries</code>，控制重试加载的次数；</li>
<li>新增定义组件选项<code>suspensible</code>，默认为 true，为 true 时，定义的<code>loadingComponent</code>和<code>errorComponent</code>将被无视；</li>
</ul>
<h5 id="daimabianhuaduibi-5"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-5')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">import ErrorComponent from './components/ErrorComponent.vue';
import LoadingComponent from './components/LoadingComponent.vue';

// 无选项异步组件
Vue.component('async-component', () =&gt; import('./my-async-component'));

// 带选项异步组件
const AsyncComponent = () =&gt; ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000,
});
</code></pre><p>3.x</p>
<pre  data-line="3,11" class="language-javascript"><code data-line="3,11" class="language-javascript">import ErrorComponent from './components/ErrorComponent.vue';
import LoadingComponent from './components/LoadingComponent.vue';
import { defineAsyncComponent } from 'vue';

// 无选项异步组件
const asyncPage = defineAsyncComponent(() =&gt; import('./my-async-component'));

// 带选项异步组件
const asyncPageWithOptions = defineAsyncComponent({
  // component 更名为 loader
  loader: () =&gt; import('./my-async-component'),
  // A component to use while the async component is loading
  loadingComponent: LoadingComponent,
  // A component to use if the load fails
  errorComponent: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000,
  // A function that returns a boolean indicating whether the async component should retry when the loader promise rejects
  retryWhen: error =&gt; error.code !== 404,
  // Maximum allowed retries number
  maxRetries: 3,
  // Defining if component is suspensible
  suspensible: false,
});
</code></pre><hr>
<h3 id="Dataxuanxiang"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'Dataxuanxiang')">¶</a> Data 选项</h3>
<h5 id="bianhuamiaoshu-18"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-18')">¶</a> 变化描述：</h5>
<ul>
<li><code>data</code>组件选项声明不再接受对象字面量，只接受<code>function</code>的声明方式；</li>
</ul>
<h5 id="daimabianhuaduibi-6"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-6')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;!-- Object Declaration --&gt;
&lt;script&gt;
  const app = new Vue({
    data: {
      apiKey: 'a1b2c3',
    },
  });
&lt;/script&gt;

&lt;!-- Function Declaration --&gt;
&lt;script&gt;
  const app = new Vue({
    data() {
      return {
        apiKey: 'a1b2c3',
      };
    },
  });
&lt;/script&gt;
</code></pre><p>3.x</p>
<pre  data-line="5-9" class="language-html"><code data-line="5-9" class="language-html">&lt;script&gt;
  import { createApp } from 'vue';

  createApp({
    data() {
      return {
        apiKey: 'a1b2c3',
      };
    },
  }).mount('#app');
&lt;/script&gt;
</code></pre><hr>
<h3 id="zidingyiyuansuElements"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zidingyiyuansuElements')">¶</a> 自定义元素 Elements</h3>
<h5 id="bianhuamiaoshu-19"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-19')">¶</a> 变化描述：</h5>
<ul>
<li>自定义元素白名单现在在模板编译期间执行，并且应该通过编译器选项而不是运行时配置来配置；</li>
<li>特殊的<code>is</code> prop 现在限定只能在<code>&lt;component&gt;</code>上使用；</li>
<li>提供新的<code>v-is</code>指令以支持 2.x 的使用情况；</li>
</ul>
<h5 id="daimabianhuaduibi-7"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-7')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// 这可以使 Vue 忽略在外部定义的自定义元素
// (e.g., 使用 Web Components APIs 定义的元素)

Vue.config.ignoredElements = ['plastic-button'];
</code></pre><p>3.x</p>
<p>使用打包工具选项定义的情况：</p>
<pre  class="language-javascript"><code class="language-javascript">// in webpack config
rules: [
  {
    test: /\.vue$/,
    use: 'vue-loader',
    options: {
      compilerOptions: {
        isCustomElement: tag =&gt; tag === 'plastic-button',
      },
    },
  },
  // ...
];
</code></pre><p>使用运行时定义的情况（注意这种配置对预编译的模板无效）：</p>
<pre  class="language-javascript"><code class="language-javascript">const app = Vue.createApp({});
app.config.isCustomElement = tag =&gt; tag === 'plastic-button';
</code></pre><hr>
<h3 id="chacaoSlots"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'chacaoSlots')">¶</a> 插槽 Slots</h3>
<h5 id="bianhuamiaoshu-20"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-20')">¶</a> 变化描述：</h5>
<ul>
<li>指定 slot 的方式由对象字面量变为函数式；</li>
<li><code>this.$scopedSlots</code>移除；</li>
</ul>
<h5 id="daimabianhuaduibi-8"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-8')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// 2.x Syntax
h(LayoutComponent, [h('div', { slot: 'header' }, this.header), h('div', { slot: 'content' }, this.content)]);
</code></pre><pre  class="language-js"><code class="language-js">// 2.x 在组件内获取指定的槽
this.$scopedSlots.header;
</code></pre><p>3.x</p>
<pre  class="language-javascript"><code class="language-javascript">// 3.x Syntax
h(
  LayoutComponent,
  {},
  {
    header: () =&gt; h('div', this.header),
    content: () =&gt; h('div', this.content),
  },
);
</code></pre><pre  class="language-js"><code class="language-js">// 3.x 在组件内获取指定的槽
this.$slots.header;
</code></pre><hr>
<h3 id="dongtaibangdingshuxingchuli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dongtaibangdingshuxingchuli')">¶</a> 动态绑定属性处理</h3>
<h5 id="bianhuamiaoshu-21"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-21')">¶</a> 变化描述：</h5>
<ul>
<li>删除 Vue 内部定义的“枚举属性”（<code>contenteditable</code>，<code>draggable</code>和<code>spellcheck</code>）概念，并将这些“枚举属性”当作非布尔值处理；</li>
<li>当 DOM 上的动态属性绑定值为<code>false</code>时，不再删除该属性。如果需要删除属性，使用<code>null</code>或者<code>undefined</code>；</li>
</ul>
<h5 id="shuxingchulibianhuaduibi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shuxingchulibianhuaduibi')">¶</a> 属性处理变化对比：</h5>
<p>2.x</p>
<table>
<thead>
<tr>
<th style="text-align:left">绑定表达式</th>
<th style="text-align:left"><code>foo</code>(常规值)</th>
<th style="text-align:left"><code>draggable</code>(枚举值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:attr=&quot;null&quot;</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">draggable=&quot;false&quot;</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;undefined&quot;</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;true&quot;</td>
<td style="text-align:left">foo=&quot;true&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;false&quot;</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">draggable=&quot;false&quot;</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;0&quot;</td>
<td style="text-align:left">foo=&quot;0&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:left">attr=&quot;&quot;</td>
<td style="text-align:left">foo=&quot;&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:left">attr=&quot;foo&quot;</td>
<td style="text-align:left">foo=&quot;foo&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:left">attr</td>
<td style="text-align:left">foo=&quot;&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
</tbody>
</table>
<p>3.x</p>
<table>
<thead>
<tr>
<th style="text-align:left">绑定表达式</th>
<th style="text-align:left"><code>foo</code>(常规值)</th>
<th style="text-align:left"><code>draggable</code>(枚举值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:attr=&quot;null&quot;</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><strong>N/A</strong> *</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;undefined&quot;</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;true&quot;</td>
<td style="text-align:left">foo=&quot;true&quot;</td>
<td style="text-align:left">draggable=&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;false&quot;</td>
<td style="text-align:left"><strong>foo=&quot;false&quot;</strong> *</td>
<td style="text-align:left">draggable=&quot;false&quot;</td>
</tr>
<tr>
<td style="text-align:left">:attr=&quot;0&quot;</td>
<td style="text-align:left">foo=&quot;0&quot;</td>
<td style="text-align:left"><strong>draggable=&quot;0&quot;</strong> *</td>
</tr>
<tr>
<td style="text-align:left">attr=&quot;&quot;</td>
<td style="text-align:left">foo=&quot;&quot;</td>
<td style="text-align:left"><strong>draggable=&quot;&quot;</strong> *</td>
</tr>
<tr>
<td style="text-align:left">attr=&quot;foo&quot;</td>
<td style="text-align:left">foo=&quot;foo&quot;</td>
<td style="text-align:left"><strong>draggable=&quot;o&quot;</strong> *</td>
</tr>
<tr>
<td style="text-align:left">attr</td>
<td style="text-align:left">foo=&quot;&quot;</td>
<td style="text-align:left"><strong>draggable=&quot;&quot;</strong> *</td>
</tr>
</tbody>
</table>
<p>*：发生变化</p>
<hr>
<h3 id="zidingyizhilingDirectives"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zidingyizhilingDirectives')">¶</a> 自定义指令 Directives</h3>
<h5 id="bianhuamiaoshu-22"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-22')">¶</a> 变化描述：</h5>
<ul>
<li>
<p>重命名自定义指令的生命周期钩子，使其与组件的生命周期一致(部分)：</p>
<pre  class="language-text"><code class="language-text">- bind → beforeMount

- inserted → mounted

- beforeUpdate: 新钩子，在元素更新前调用

- update → 已删除

- beforeUnmount 新钩子，在元素卸载前调用

- unbind -&gt; unmounted
</code></pre></li>
<li>
<p>当指令应用在自定义组件时，需要在组件内使用<code>v-bind=&quot;$attrs&quot;</code>手动绑定到具体的 DOM，因为可能存在多根元素的情况；</p>
</li>
</ul>
<h5 id="daimabianhuaduibi-9"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-9')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;p v-highlight=&quot;yellow&quot;&gt;Highlight this text bright yellow&lt;/p&gt;
</code></pre><pre  class="language-javascript"><code class="language-javascript">Vue.directive('highlight', {
  bind(el, binding, vnode) {
    el.style.background = binding.value;
  },
});
</code></pre><p>3.x<br>
使用在原生 DOM 的情况：</p>
<pre  class="language-html"><code class="language-html">&lt;p v-highlight=&quot;yellow&quot;&gt;Highlight this text bright yellow&lt;/p&gt;
</code></pre><pre  class="language-javascript"><code class="language-javascript">const app = Vue.createApp({});

app.directive('highlight', {
  beforeMount(el, binding, vnode) {
    el.style.background = binding.value;
  },
  mounted() {},
  beforeUpdate() {}, // new
  updated() {},
  beforeUnmount() {}, // new
  unmounted() {},
});
</code></pre><p>使用在自定义组件的情况：</p>
<p>组件外部：</p>
<pre  class="language-html"><code class="language-html">&lt;custom-component v-highlight=&quot;yellow&quot; /&gt;
</code></pre><p>组件内部：</p>
<pre  class="language-html"><code class="language-html">&lt;template&gt;
  &lt;p v-bind=&quot;$attrs&quot;&gt;Highlight this text bright yellow&lt;/p&gt;
  &lt;p v-bind=&quot;$attrs&quot;&gt;Highlight this text bright yellow&lt;/p&gt;
  &lt;p&gt;Keep this text normal&lt;/p&gt;
&lt;/template&gt;
</code></pre><hr>
<h3 id="donghuazujianTransitionComponent"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'donghuazujianTransitionComponent')">¶</a> 动画组件 Transition Component</h3>
<h5 id="bianhuamiaoshu-23"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-23')">¶</a> 变化描述：</h5>
<ul>
<li>当<code>&lt;transition&gt;</code>作为组件根元素时，在组件外部使用<code>v-if</code>或者<code>v-show</code>改变显隐值将不再生效，需要暴露指定值来控制显隐以驱动 transition 动画；</li>
<li>将<code>v-enter</code> transition class 更名为<code>v-enter-from</code>；</li>
<li>将<code>v-leave</code> transition class 更名为<code>v-leave-from</code>；</li>
</ul>
<h5 id="daimabianhuaduibi-10"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-10')">¶</a> 代码变化对比：</h5>
<p><code>&lt;transition&gt;</code>作为组件根元素：</p>
<p>2.x</p>
<pre  data-line="9" class="language-html"><code data-line="9" class="language-html">&lt;!-- modal component --&gt;
&lt;template&gt;
  &lt;transition&gt;
    &lt;div class=&quot;modal&quot;&gt;&lt;slot /&gt;&lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;

&lt;!-- usage --&gt;
&lt;modal v-if=&quot;showModal&quot;&gt;hello&lt;/modal&gt;
</code></pre><p>3.x</p>
<pre  data-line="9" class="language-html"><code data-line="9" class="language-html">&lt;!-- modal component --&gt;
&lt;template&gt;
  &lt;transition&gt;
    &lt;div v-if=&quot;show&quot; class=&quot;modal&quot;&gt;&lt;slot /&gt;&lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;

&lt;!-- usage --&gt;
&lt;modal :show=&quot;showModal&quot;&gt;hello&lt;/modal&gt;
</code></pre><hr>
<p>class 更名：</p>
<p>2.x</p>
<pre  class="language-css"><code class="language-css">/* before */
.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre><p>3.x</p>
<pre  class="language-css"><code class="language-css">/* after */
.v-enter-from,
.v-leave-to {
  opacity: 0;
}
.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre><hr>
<h3 id="zhentingqiAPIWatch"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhentingqiAPIWatch')">¶</a> 侦听器 API Watch</h3>
<h5 id="bianhuamiaoshu-24"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-24')">¶</a> 变化描述：</h5>
<ul>
<li>更改形如<code>a.b.c</code>的键路径观察方式为计算函数式，如<code>() =&gt; this.a.b.c</code>；</li>
</ul>
<h5 id="daimabianhuaduibi-11"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-11')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// 键路径
vm.$watch('a.b.c', function(newVal, oldVal) {
  // 做点什么
});
</code></pre><p>3.x</p>
<pre  data-line="2,10" class="language-javascript"><code data-line="2,10" class="language-javascript">vm.$watch(
  () =&gt; vm.a.b.c,
  (newVal, oldVal) =&gt; {
    // 做点什么
  },
);

// 多依赖的情况
vm.$watch(
  () =&gt; vm.a.b.c + vm.d.e.f,
  (newVal, oldVal) =&gt; {
    // 做点什么
  },
);
</code></pre><hr>
<h3 id="xiangyingshizhuruProvideInject"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangyingshizhuruProvideInject')">¶</a> 响应式注入 Provide / Inject</h3>
<h5 id="bianhuamiaoshu-25"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-25')">¶</a> 变化描述：</h5>
<ul>
<li>通过<code>ref</code>、<code>computed</code>和<code>reactive</code> api，现在可以注入响应式的值和该值对应的更新方法；</li>
</ul>
<h5 id="daimabianhuaduibi-12"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-12')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// 父级组件提供 'foo'
var Provider = {
  provide: {
    foo: 'bar',
  },
  // ...
};

// 子组件注入 'foo'
var Child = {
  inject: ['foo'],
  created() {
    console.log(this.foo); // =&gt; &quot;bar&quot;
  },
  // ...
};
</code></pre><p>3.x</p>
<p>在组件选项内定义的情况：</p>
<pre  data-line="5" class="language-js"><code data-line="5" class="language-js">app.component('todo-list', {
  // ...
  provide() {
    return {
      todoLength: Vue.computed(() =&gt; this.todos.length),
    };
  },
});
</code></pre><p>在<code>setup</code>函数内定义的情况：</p>
<pre  data-line="21-23,27" class="language-html"><code data-line="21-23,27" class="language-html">&lt;!-- src/components/MyMap.vue --&gt;
&lt;template&gt;
  &lt;MyMarker /&gt;
&lt;/template&gt;

&lt;script&gt;
  import { provide, reactive, ref } from 'vue'
  import MyMarker from './MyMarker.vue

  export default {
    components: {
      MyMarker
    },
    setup() {
      const location = ref('North Pole')
      const geolocation = reactive({
        longitude: 90,
        latitude: 135
      })

      const updateLocation = () =&gt; {
        location.value = 'South Pole'
      }

      provide('location', location)
      provide('geolocation', geolocation)
      provide('updateLocation', updateLocation)
    }
  }
&lt;/script&gt;
</code></pre><pre  data-line="9,14" class="language-html"><code data-line="9,14" class="language-html">&lt;!-- src/components/MyMarker.vue --&gt;
&lt;script&gt;
  import { inject } from 'vue';

  export default {
    setup() {
      const userLocation = inject('location', 'The Universe');
      const userGeolocation = inject('geolocation');
      const updateUserLocation = inject('updateUserLocation'); // 注入更新方法

      return {
        userLocation,
        userGeolocation,
        updateUserLocation, // 可再导出更新方法
      };
    },
  };
&lt;/script&gt;
</code></pre><hr>
<h2 id="REMOVEDfeiqigongnengtexing"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'REMOVEDfeiqigongnengtexing')">¶</a> REMOVED | 废弃功能特性</h2>
<h3 id="shijianAPIEvents"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shijianAPIEvents')">¶</a> 事件 API Events</h3>
<h5 id="bianhuamiaoshu-26"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-26')">¶</a> 变化描述：</h5>
<ul>
<li><code>$on</code>，<code>$off</code>和<code>$once</code>实例方法移除。应用实例不再提供事件中心的接口。</li>
</ul>
<h5 id="daimabianhuaduibi-13"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-13')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-javascript"><code class="language-javascript">// eventHub.js

const eventHub = new Vue();

export default eventHub;
</code></pre><pre  class="language-javascript"><code class="language-javascript">// ChildComponent.vue
import eventHub from './eventHub';

export default {
  mounted() {
    // adding eventHub listener
    eventHub.$on('custom-event', () =&gt; {
      console.log('Custom event triggered!');
    });
  },
  beforeDestroy() {
    // removing eventHub listener
    eventHub.$off('custom-event');
  },
};
</code></pre><pre  class="language-javascript"><code class="language-javascript">// ParentComponent.vue
import eventHub from './eventHub';

export default {
  methods: {
    callGlobalCustomEvent() {
      eventHub.$emit('custom-event'); // if ChildComponent is mounted, we will have a message in the console
    },
  },
};
</code></pre><p>3.x</p>
<p><code>$on</code>，<code>$off</code>和<code>$once</code>实例方法移除。保留<code>$emit</code>实例方法作为子组件发射自定义事件的 api。</p>
<hr>
<h3 id="shijianxiushifuKeyCode"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shijianxiushifuKeyCode')">¶</a> 事件修饰符 KeyCode</h3>
<h5 id="bianhuamiaoshu-27"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-27')">¶</a> 变化描述：</h5>
<ul>
<li><code>v-on</code>指令的修饰符不再支持 keyCodes；</li>
<li>移除<code>config.keyCodes</code>;</li>
</ul>
<h5 id="daimabianhuaduibi-14"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-14')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;!-- keyCode version --&gt;
&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;

&lt;!-- alias version --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;
</code></pre><pre  class="language-js"><code class="language-js">Vue.config.keyCodes = {
  f1: 112,
};
</code></pre><pre  class="language-html"><code class="language-html">&lt;!-- keyCode version --&gt;
&lt;input v-on:keyup.112=&quot;showHelpText&quot; /&gt;

&lt;!-- custom alias version --&gt;
&lt;input v-on:keyup.f1=&quot;showHelpText&quot; /&gt;
</code></pre><p>3.x</p>
<pre  class="language-html"><code class="language-html">&lt;!-- Vue 3 Key Modifier on v-on --&gt;
&lt;input v-on:keyup.delete=&quot;confirmDelete&quot; /&gt;
</code></pre><hr>
<h3 id="guolvqiFilters"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guolvqiFilters')">¶</a> 过滤器 Filters</h3>
<h5 id="bianhuamiaoshu-28"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-28')">¶</a> 变化描述：</h5>
<ul>
<li>完全移除<code>Filters</code>；</li>
</ul>
<h5 id="daimabianhuaduibi-15"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-15')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountBalance | currencyUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true,
      },
    },
    filters: {
      currencyUSD(value) {
        return '$' + value;
      },
    },
  };
&lt;/script&gt;
</code></pre><p>3.x</p>
<p>使用计算属性或者自定义方法处理：</p>
<pre  data-line="15-17" class="language-html"><code data-line="15-17" class="language-html">&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;{{ accountInUSD }}&lt;/p&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    props: {
      accountBalance: {
        type: Number,
        required: true,
      },
    },
    computed: {
      accountInUSD() {
        return '$' + this.accountBalance;
      },
    },
  };
&lt;/script&gt;
</code></pre><hr>
<h3 id="hangneimobanshuxinginlinetemplate"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'hangneimobanshuxinginlinetemplate')">¶</a> 行内模板属性 inline-template</h3>
<h5 id="bianhuamiaoshu-29"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'bianhuamiaoshu-29')">¶</a> 变化描述：</h5>
<ul>
<li>完全移除<code>inline-template</code>方法；</li>
</ul>
<h5 id="daimabianhuaduibi-16"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimabianhuaduibi-16')">¶</a> 代码变化对比：</h5>
<p>2.x</p>
<pre  class="language-html"><code class="language-html">&lt;my-component inline-template&gt;
  &lt;div&gt;
    &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt;
    &lt;p&gt;Not parent's transclusion content.&lt;/p&gt;
  &lt;/div&gt;
&lt;/my-component&gt;
</code></pre><p>3.x</p>
<p>不再支持<code>inline-template</code>。</p>
<h2 id="zongjie"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zongjie')">¶</a> 总结</h2>
<p>通过学习 Vue 3.x 的新特性可以体会到，Vue 在<strong>性能</strong>、<strong>工程化</strong>和<strong>可移植性</strong>这三个大方向里面作出了很大的努力，主要体现在这五个方面：</p>
<ul>
<li>Tree-shaking support；
<ul>
<li>大多数可选功能现在都支持 Tree-shaking，例如 Composition API、<code>v-model</code>、<code>&lt;transition&gt;</code>；</li>
<li>最小可运行的 HelloWorld 例子的文件总大小: 13.5kb， 只使用 Composition API 的情况下最小可达到 11.75kb；</li>
<li>全运行时打包总大小为: 22.5kb，功能更多更强大，但是大小比 Vue 2 更小；</li>
</ul>
</li>
<li>Composition API；
<ul>
<li>可与原有的选项 API 同时存在，更灵活和更易于 2.x 升级 3.x，同时利于开发人员  过渡升级版本；</li>
<li>更加灵活的逻辑组合和复用，大大地提升了复杂组件的可维护性；</li>
<li>Reactivity 模块可作为独立的库使用，使得 Vue 3.x 在与其它框架配合使用时更加灵活；</li>
</ul>
</li>
<li>Fragment, Teleport, Suspense；
<ul>
<li>Fragment 特性的到来，可以使<code>&lt;template&gt;</code>中不再局限于单一的根节点，同时<code>render</code>函数也可以返回包含多个 Vnode 的数组；</li>
<li>Teleport 组件让原来的复杂组件的嵌套关系变得更加灵活和清晰；</li>
<li>Suspense 组件大大减少了书写异步数据 DOM 渲染和异步组件的代码量；</li>
</ul>
</li>
<li>Better TypeScript support；
<ul>
<li>Vue 3.x 库代码编写由原来的<code>flow</code>转换为<code>ts</code>，所以在编写业务代码时使用 ts 可以大大受益；</li>
<li>API 在 js 和 ts 环境下的使用一致；</li>
<li>支持 TSX；</li>
<li>Class 组件仍然可用（需要引入<code>vue-class-component@next</code>）；</li>
</ul>
</li>
<li>Custom Renderer API；
<ul>
<li>允许生成自定义的 renderer，降低了 Vue 3.x 迁移到其它平台的难度，比如小程序、Weex 等；</li>
</ul>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[控制前端业务重复请求的一个新思路]]></title>
            <link>/post/prevent-duplicate-requests/</link>
            <guid>/post/prevent-duplicate-requests/</guid>
            <description><![CDATA[少一个请求，少一分负担]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#xuqiubeijing">需求背景</a><ul><li><a href="#zhongfuqingqiudehuaichu">重复请求的坏处</a></li><li><a href="#zhongfuqingqiuchulifenxi">重复请求处理分析</a></li></ul></li><li><a href="#zailanjieqiliguanlizhongfuqingqiu">在拦截器里管理重复请求</a><ul><li><a href="#lanjieqideshixianyuanli">拦截器的实现原理</a></li><li><a href="#shixianzhongfuqingqiuguanliqi">实现重复请求管理器</a></li></ul></li><li><a href="#weishimoshiflybushiaxios">为什么是 fly 不是 axios？</a><ul><li><a href="#axiosguanjianyuanmafenxi">axios 关键源码分析</a></li><li><a href="#flyguanjianyuanmafenxi">fly 关键源码分析</a></li><li><a href="#nengfoushiyongaxiosdadaomude">能否使用 axios 达到目的？</a></li></ul></li><li><a href="#jieyan">结言</a></li></ul></div></p>
<h2 id="xuqiubeijing"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xuqiubeijing')">¶</a> 需求背景</h2>
<p>在上一家公司的时候，因为业务重组，笔者被分配到一个电商项目组，负责项目中 hybrid app 的前端模块功能迭代。该项目代码已经具有一定规模，长期的快速业务需求迭代，导致前端模块耦合的程度也到了不容忽视的时候，而且还存在一些小 bug。比如，没有对可能导致重复请求的场景进行处理。</p>
<h3 id="zhongfuqingqiudehuaichu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhongfuqingqiudehuaichu')">¶</a> 重复请求的坏处</h3>
<p>前端重复请求如果不及时处理可能会带来以下几个坏处：</p>
<ul>
<li>消耗额外的 <strong>服务器/客户端</strong> 资源；</li>
<li>后端若未对请求做幂等处理，造成后端脏数据；</li>
<li>多个重复请求占据请求队列，达到浏览器并发请求上限，导致正常请求阻塞；</li>
</ul>
<h3 id="zhongfuqingqiuchulifenxi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhongfuqingqiuchulifenxi')">¶</a> 重复请求处理分析</h3>
<p>因此，在新的需求没来之前，第一件事就是着手处理这个问题。众所周知，拦截重复请求的常规手段不外乎以下几种：</p>
<ol>
<li><strong>请求发起后，前端添加 遮罩层+loading 提示。</strong></li>
<li><strong>对请求方法进行防抖和节流。</strong></li>
<li><strong>利用流行前端 ajax 库中的拦截器进行拦截取消，如 <a href="https://github.com/axios/axios" target="_blank">axios</a> 的 cancelToken。</strong></li>
</ol>
<p>因为是新接手的具有一定规模的项目，使用一、二种方法去处理的话需要短时间内投入大量的工作量，而且还不能保证做到百分百的覆盖。第三种方法看来很适合，在统一的进出口进行处理，就不会有前两种方法的问题，但是这种捕捉到重复请求就立马取消，一刀切式的方式真的适合吗？</p>
<p>试想一下是不是会有这样的业务场景存在？</p>
<ul>
<li>A 页面作为总的页面入口，具有 BCDEF 等子页面。A 页面依赖请求 X 的数据；</li>
<li>B 页面也依赖请求 X 的数据，但 CDEF 不依赖请求 X 的数据；</li>
<li>进入 A 页面时有可能在 X 请求前未返回前直接跳转到 B 页面；</li>
<li>B 页面可能会作为独立的营销页对外公开；</li>
</ul>
<p>如果进行了一刀切处理，在遇到「进入 A 页面时有可能在 X 请求前未返回前直接跳转到 B 页面」这种情况时，B 页面所依赖的 X 数据就再也拿不到了。如果在 B 页面添加额外处理逻辑，就会遇到第一二种方法同样的问题。</p>
<p>虽然方法三也不可行，但在统一的出入口进行处理这个思路是没有问题的。我们需要改进一下这个一刀切的操作，在避免重复请求的同时保证原来的业务逻辑不能受到影响。</p>
<p>如何改进？首先先来看看拦截器的实现原理是怎样的。</p>
<h2 id="zailanjieqiliguanlizhongfuqingqiu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zailanjieqiliguanlizhongfuqingqiu')">¶</a> 在拦截器里管理重复请求</h2>
<h3 id="lanjieqideshixianyuanli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'lanjieqideshixianyuanli')">¶</a> 拦截器的实现原理</h3>
<p>在使用了如 axios 的前端请求库的请求过程一般如下图所示，在调用请求方法时，传入<code>Options</code>，然后这个请求配置会经过请求拦截器<code>RequestInterceptor</code>处理，过后配置传到<code>Request</code>方法中进行正式请求，待请求从服务端返回后将请求交给响应拦截器<code>ResponseInterceptor</code>进行处理，处理完成后将数据交给业务逻辑：</p>
<pre  class="language-text"><code class="language-text">         ┌─────────┐
         │ Options │
         └─────────┘
              │
┌ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─┐ ─ ─ ─ ─┐
              ▼
│  ┌────────────────────┐  │        │
   │ RequestInterceptor │
│  └────────────────────┘  │        │
              │
│             ▼            │        │
   ┌────────────────────┐
│  │  Request(Options)  │  │     请求过程
   └────────────────────┘
│             │            │        │
              ▼
│  ┌────────────────────┐  │        │
   │ ResponseInterceptor│
│  └────────────────────┘  │        │
              │
└ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─┘ ─ ─ ─ ─┘
              │
              ▼
         ┌─────────┐
         │ bsLogic │
         └─────────┘
</code></pre><p>那么 axios 等类库是如何将这个过程串成一条链的呢？答案就是 promise。下来就用简单的代码示例讲解拦截器的实现原理。</p>
<p>首先创建一些请求拦截器和响应拦截器，在每个拦截器里面打印自身名称，方便请求时观察触发顺序：</p>
<pre  class="language-js"><code class="language-js">// 模拟配置
const config = { url: 'https://lkangd.com/', count: 0 };

// 模拟请求拦截器s
const reqInterceptor1 = config =&gt; {
  config.count++;
  console.log('reqInterceptor1');
  return config;
};
const reqInterceptor2 = config =&gt; {
  config.count++;
  console.log('reqInterceptor2');
  return config;
};
const reqInterceptor3 = config =&gt; {
  config.count++;
  console.log('reqInterceptor3');
  return config;
};
// 按倒序插入
const reqInterceptors = [reqInterceptor3, reqInterceptor2, reqInterceptor1];

// 模拟响应拦截器s
const resInterceptor1 = config =&gt; {
  config.count++;
  console.log('resInterceptor1');
  return config;
};
const resInterceptor2 = config =&gt; {
  console.log('resInterceptor2');
  config.count++;
  return config;
};
const resInterceptor3 = config =&gt; {
  console.log('resInterceptor3');
  config.count++;
  return config;
};
// 按正序插入
const resInterceptors = [resInterceptor1, resInterceptor2, resInterceptor3];
</code></pre><p>promise 的 then 方法会默认返回一个新的 promise，我们可以利用这个特性，将所有拦截器包装起来，然后串成一条链：</p>
<pre  data-line="19-22" class="language-js"><code data-line="19-22" class="language-js">const request = (config, reqInterceptors, resInterceptors) =&gt; {
  const makeRequest = config =&gt; {
    console.log('makeRequest!');
    return new Promise((resolve, reject) =&gt; {
      // 模拟请求延时
      setTimeout(() =&gt; {
        resolve({ data: 'response', ...config });
      }, 3000);
    });
  };
  const chain = [makeRequest];
  let promise = Promise.resolve(config);

  // 将请求拦截器放在请求前
  reqInterceptors.forEach(ri =&gt; chain.unshift(ri));
  // 将响应拦截器放在请求后
  resInterceptors.forEach(ri =&gt; chain.push(ri));

  // 将 chain 串成一条 promise 链
  while (chain.length) {
    promise = promise.then(chain.shift()); // then 的默认行为是返回一个新的 promise
  }
  // 将 promise 链返回
  return promise;
};
</code></pre><p>调用<code>request</code>方法，按参数顺序传入，配置、请求拦截器，响应拦截器，看打印结果：</p>
<pre  class="language-js"><code class="language-js">request(config, reqInterceptors, resInterceptors).then(data =&gt; {
  console.log(data);
});
// 留意触发顺序
// reqInterceptor1
// reqInterceptor2
// reqInterceptor3
// makeRequest!
// Promise {&lt;pending&gt;} 3 秒后打印下面的内容
// resInterceptor1
// resInterceptor2
// resInterceptor3
// {data: &quot;response&quot;, url: &quot;https://lkangd.com/&quot;, count: 6}，count 被处理了 6 次
</code></pre><h3 id="shixianzhongfuqingqiuguanliqi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shixianzhongfuqingqiuguanliqi')">¶</a> 实现重复请求管理器</h3>
<p>知道了拦截器的实现原理之后，答案就呼之欲出了，我们不是直接取消掉后续的重复请求，而是将这些重复请求挂起，等到第一个元子请求的结果返回后，将这个结果传递给挂起的重复请求。这样就做到了重复请求只发出一次，但是业务逻辑不用做额外的处理，整个处理流程图如下所示：</p>
<pre  class="language-text"><code class="language-text">         ┌─────────┐
         │ Options │
         └─────────┘
              │
┌ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ──┐ ─ ─ ─ ─┐
              ▼
│  ┌────────────────────┐   Yes    ┌───────────────────┐  │        │
   │   hasRequesting?   │ ───────&gt; │ waitForRequesting │
│  └────────────────────┘    ▲     └───────────────────┘  │        │
           No │              │ resolve        │
│             ▼              │                │           │        │
   ┌────────────────────┐    │                │
│  │   addRequesting    │    │                │           │        │
   └────────────────────┘    │                │
│             │              │                │           │        │
              ▼              │                │
│  ┌────────────────────┐    │                │           │        │
   │ requestInterceptor │    │                │
│  └────────────────────┘    │                │           │        │
              │              │                │
│             ▼              │                │           │     请求过程
   ┌────────────────────┐    │                │
│  │  request(Options)  │    │                │           │        │
   └────────────────────┘    │                │
│             │              │                │           │        │
              ▼              │                │
│  ┌────────────────────┐    │                │           │        │
   │ ResponseInterceptor│    │                │
│  └────────────────────┘    │                │           │        │
              │              │                │
│             ▼              │                │           │        │
   ┌────────────────────┐    │                │
│  │  resolveRequesting │ ───┘                │           │        │
   └────────────────────┘                     │
│             │&lt;──────────────────────────────┘           │        │
              │
└ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘ ─ ─ ─ ─┘
              │
              ▼
         ┌─────────┐
         │ bsLogic │
         └─────────┘
</code></pre><p>第一步，如何识别多个请求是否重复请求？很简单，只要将每个新请求中的<code>method(请求方法)</code>、<code>params(请求参数)</code>、<code>body(请求体)</code>和<code>url(请求地址)</code>组装成一个新对象，然后对这个新对象进行 JSON 序列化，获得的字符串就是这个请求的唯一标识，如下所示：</p>
<pre  class="language-js"><code class="language-js">const { method, params, body, url } = request;
const _serialization = JSON.stringify({ method, params, body, url });
</code></pre><p>有了唯一标识后，第二步就是将<strong>已经发出但是还未返回</strong>的请求存储起来，在这个请求未返回期间，如果识别到具有同一标识的请求发生，就分配一个处于<code>pending</code>状态的 promise ，待请求结束后将请求结果去<code>resolve</code>所有<code>pending</code>状态中的 promise：</p>
<pre  data-line="9,14,20,21" class="language-js"><code data-line="9,14,20,21" class="language-js">// 最简实现原理
const repeatRecord = {};
let count = 0;

function requestInterceptor(request) {
  const { method, params, body, url } = request;
  const _serialization = JSON.stringify({ method, params, body, url });

  if (repeatRecord[_serialization]) return repeatRecord[_serialization]; // 存在则立即返回

  return new Promise(resolve =&gt; {
    let resolveRepeat;
    repeatRecord[_serialization] = new Promise(resolve =&gt; {
      resolveRepeat = resolve; // 将新 promise 的 resolver 存储起来
    });

    setTimeout(() =&gt; {
      const result = `done! ${++count}`;
      // 使用结果同时 resolve 两个 promise
      resolve(result);
      resolveRepeat(result);
      delete repeatRecord[_serialization]; // 请求结束后删除状态
    }, 3000);
  });
}

// 进行 4 次重复请求，count 只累加了一次
const request = { method: 'GET', params: { p1: 'p1' }, body: { b1: 'b1' }, url: 'https://lkangd.com/' };
requestInterceptor(request).then(res =&gt; {
  console.log(res); // done! 1
});
requestInterceptor(request).then(res =&gt; {
  console.log(res); // done! 1
});
requestInterceptor(request).then(res =&gt; {
  console.log(res); // done! 1
});
requestInterceptor(request).then(res =&gt; {
  console.log(res); // done! 1
});
</code></pre><p>关键代码和思路已经具备，接下来就是完善整个管理器的实现了，除了请求成功的状态当然还会有请求失败的状态：</p>
<pre  class="language-js"><code class="language-js">const requestManager = {
  data: {}, // 存储请求
  resolvers: {}, // 存储每一个请求的 promise 的 resolve 回调
  rejecters: {}, // 存储每一个请求的 promise 的 reject 回调
  // 将新请求存入 data
  add(request) {
    const serialized = this._serialization(request);
    return (this.data[serialized] = new Promise((resolve, reject) =&gt; {
      this.resolvers[serialized] = resolve;
      this.rejecters[serialized] = reject;
    }));
  },
  // 获取请求中的请求
  get(request) {
    const serialized = this._serialization(request);
    return this.data[serialized];
  },
  // 请求成功时调用
  success(request, response) {
    const serialized = this._serialization(request);
    this.resolvers[serialized] &amp;&amp; this.resolvers[serialized](response);
    this._clean(request);
  },
  // 请求失败时调用
  fail(request, error) {
    const serialized = this._serialization(request);
    this.rejecters[serialized] &amp;&amp; this.rejecters[serialized](error);
    this._clean(request);
  },
  // 清除存储的请求
  _clean(request) {
    const serialized = this._serialization(request);
    delete this.resolvers[serialized];
    delete this.rejecters[serialized];
    delete this.data[serialized];
  },
  // 对请求的配置进行序列化，获得请求的唯一序列
  _serialization(request) {
    const { method, params, body, url } = request;
    return JSON.stringify({ method, params, body, url });
  },
};
</code></pre><p>最后就是在拦截器里面加入重复请求管理器的逻辑，有一个需要注意的地方是，这里笔者选择使用的是 <a href="https://github.com/wendux/fly" target="_blank">fly</a> 而不是 axios（原因后面再说），如下所示：</p>
<pre  class="language-js"><code class="language-js">import Flyio from 'flyio/dist/npm/fly';
const flyInstance = new Flyio();

const requestInterceptor = request =&gt; {
  const repeatedRequest = requestManager.get(request);
  if (repeatedRequest) return repeatedRequest; // 判断是否有相同请求正在进行中，有的话直接返回

  requestManager.add(request); // 添加新请求

  // do some stuff...

  return request;
};

const responseInterceptor = [
  response =&gt; {
    requesting.success(response.request, response.data); // 请求成功，响应其它重复请求的成功回调

    // do some stuff...

    return response.data;
  },
  error =&gt; {
    requesting.fail(error.request, error); // 请求失败，响应其它重复请求的失败回调

    // do some stuff...

    return Promise.reject(error);
  },
];

flyInstance.interceptors.request.use(requestInterceptor);
flyInstance.interceptors.response.use(...responseInterceptor);
</code></pre><h2 id="weishimoshiflybushiaxios"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'weishimoshiflybushiaxios')">¶</a> 为什么是 fly 不是 axios？</h2>
<h3 id="axiosguanjianyuanmafenxi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'axiosguanjianyuanmafenxi')">¶</a> axios 关键源码分析</h3>
<p>我们打开 axios 的源码中的 <a href="https://github.com/axios/axios/blob/master/lib/core/Axios.js#L49" target="_blank">request</a>部分，可以看到在 promise 链的正中是<code>dispatchRequest</code>进行请求：</p>
<pre  data-line="3" class="language-js"><code data-line="3" class="language-js">Axios.prototype.request = function request(config) {
  // ...
  var chain = [dispatchRequest, undefined]; // 默认调用方法是 dispatchRequest
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};
</code></pre><p><a href="https://github.com/axios/axios/blob/master/lib/core/dispatchRequest.js#L52" target="_blank"><code>dispatchRequest</code></a> 返回 adapter 对传入 config 进行处理后的结果：</p>
<pre  data-line="3" class="language-js"><code data-line="3" class="language-js">module.exports = function dispatchRequest(config) {
  // ...
  return adapter(config); // ...
};
</code></pre><p>axios 默认的 adapter 是 xhr，最后去看看 adapter 的实现，发现最终<code>new XMLHttpRequest()</code>使用 config 中的 <a href="https://github.com/axios/axios/blob/master/lib/adapters/xhr.js#L14" target="_blank">data</a> 作为数据进行发送，如果传入的是 promise，肯定是不存在 data 属性的，最后只能产生错误。</p>
<pre  class="language-js"><code class="language-js">module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;

    // ...

    var request = new XMLHttpRequest();

    // ...

    request.send(requestData);
  });
};
</code></pre><h3 id="flyguanjianyuanmafenxi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'flyguanjianyuanmafenxi')">¶</a> fly 关键源码分析</h3>
<p>而 fly 在请求方法会对传入的 options 进行判断，如果经过请求拦截器处理后返回的结果不是 options，则将这个结果直接返回，所以就能达到我们上面流程图想要的结果：</p>
<pre  data-line="18,26-30" class="language-js"><code data-line="18,26-30" class="language-js">// ...
class Fly {
  // ...
  request(url, data, options) {
    // ...
    enqueueIfLocked(requestInterceptor.p, () =&gt; {
      utils.merge(options, JSON.parse(JSON.stringify(this.config)));
      let headers = options.headers;
      headers[contentType] = headers[contentType] || headers[contentTypeLowerCase] || '';
      delete headers[contentTypeLowerCase];
      options.body = data || options.body;
      url = utils.trim(url || '');
      options.method = options.method.toUpperCase();
      options.url = url;
      let ret = options;
      if (requestInterceptorHandler) {
        // 处理请求拦截器逻辑
        ret = requestInterceptorHandler.call(requestInterceptor, options, Promise) || options;
      }
      if (!isPromise(ret)) {
        ret = Promise.resolve(ret);
      }
      ret.then(
        d =&gt; {
          //if options continue
          if (d === options) {
            makeRequest(d);
          } else {
            resolve(d); // 如果请求拦截器返回了非 options 结果，则跳过了请求阶段
          }
        },
        err =&gt; {
          reject(err);
        },
      );
    });
    // ...
  }
  // ...
}
// ...
</code></pre><h3 id="nengfoushiyongaxiosdadaomude"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'nengfoushiyongaxiosdadaomude')">¶</a> 能否使用 axios 达到目的？</h3>
<p>我们知道，axios 和 fly 都支持使用自定义的 adapter 来作为请求发送器的，理论上，在 axios 生成实例的时候将原来默认的 adapter 包装一下，判断一下传入 config 是否为 promise，然后直接返回，应该是可以得到支持的。</p>
<pre  class="language-js"><code class="language-js">import Axios from 'axios';
const wrappedAdapter = config =&gt; {
  if ('function' == typeof config.then) return config;
  return Axios.defaults.adapter(config);
};

const instance = Axios.createInstance({ adapter: wrappedAdapter });
</code></pre><p>然后，理想很丰满，现实却是骨感的。因为 axios 在真正发送请求前，会在 dispatchRequest 方法内对传入的 config 进行多个特殊处理，而 dispatchRequest 的实现是不对外暴露的，所以如果此时 config 的类型为 promise，可能会产生很多意想不到的错误。因此，不建议对 axios 进行类似的包装操作。</p>
<pre  data-line="2-25" class="language-js"><code data-line="2-25" class="language-js">module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  // 上面的代码都是对传入 config 的处理
  return adapter(config).then(
    function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(response.data, response.headers, config.transformResponse);

      return response;
    },
    function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason &amp;&amp; reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise.reject(reason);
    },
  );
};
</code></pre><h2 id="jieyan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyan')">¶</a> 结言</h2>
<p>本文铺垫了一个特定的业务场景，讲述了前端重复请求会带来的几种危害，并且陈列了几种常规的前端控制重复请求的方法，然后针对每种方法进行简单分析，在不违反开放-封闭原则的前提下，对其中一种方法进行改进后达到了我们想要的结果。</p>
<p>这次优化给笔者带来的最大启发就是，我们在使用流行框架、库的时候，不应当仅仅学习其 api，更应该对其实现进行分析研究，这样在我们遇到特殊难题的时候可以获得更广阔的视野，从而获得更好的解决方案。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[剖析无限滚动虚拟列表的实现原理]]></title>
            <link>/post/virtual-infinite-scroll/</link>
            <guid>/post/virtual-infinite-scroll/</guid>
            <description><![CDATA[长列表渲染的终极优化手段]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#shimoshixuniliebiao">什么是虚拟列表？</a><ul><li><a href="#xiangguangainian">相关概念</a></li><li><a href="#shixianluojibuzhou">实现逻辑步骤</a></li></ul></li><li><a href="#gudinggaodudexuniliebiao">固定高度的虚拟列表</a><ul><li><a href="#zhunbeigongzuogudinggaodu">准备工作|固定高度</a></li><li><a href="#jisuankegundonggaodu">计算「可滚动高度」</a></li><li><a href="#jisuanchushikeshiyuansu">计算初始「可视元素」</a></li><li><a href="#gundonggengxinkeshiyuansugudinggaodu">滚动更新「可视元素」|固定高度</a></li></ul></li><li><a href="#dongtaigaodudexuniliebiao">动态高度的虚拟列表</a><ul><li><a href="#guanjiandianyiruhehuodeyuansudedongtaigaodu">关键点一：如何获得元素的动态高度？</a></li><li><a href="#guanjiandianerruhemonikegundonggaodu">关键点二：如何模拟「可滚动高度」？</a></li><li><a href="#guanjiandiansanruhejisuanmeiyigeyuansudescrollY">关键点三：如何计算每一个元素的「scrollY」？</a></li><li><a href="#zhunbeigongzuodongtaigaodu">准备工作|动态高度</a></li><li><a href="#jiantingyuansugaodubianhua">监听元素高度变化</a></li><li><a href="#gundonggengxinkeshiyuansudongtaigaodu">滚动更新「可视元素」|动态高度</a></li><li><a href="#xiuzhenggundongtiao">修正滚动条</a></li></ul></li><li><a href="#zongjie">总结</a></li></ul></div></p>
<blockquote>
<p><strong>TL;DR：</strong>「虚拟列表」的本质就是仅将<strong>需要显示在视窗中</strong>的列表节点挂载到 DOM，是一种优化长列表加载的技术手段。其中按照节点的高度是否固定又分为「固定高度的虚拟列表」和「动态高度的虚拟列表」。这是本文对两种虚拟列表场景实现的 <a href="https://lkangd.github.io/infinite-scroll-sample/#/" target="_blank">demo</a>(页面托管在 github pages 可能需要爬梯子) 和 <a href="https://github.com/lkangd/infinite-scroll-sample" target="_blank">代码库</a>(基于 Vue 2.x)。</p>
</blockquote>
<p>在进行前端业务开发时，很容易遇到需要加载巨大列表的场景。比如微博的信息流、微信的朋友圈和直播平台的聊天框等，这些列表通常具有两个显著的特点：</p>
<ul>
<li>不能分页；</li>
<li>只要用户愿意就可以无限地滚动下去。</li>
</ul>
<p>在这种场景下，如果直接加载一个数量级很大的列表，会造成页面假死，使用传统的上拉分页加载模式或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank">window.requestAnimationFrame</a>空闲加载模式可以在一定程度上缓解这种情况，但是在加载到一定量级的页面时，会因为页面同时存在大量的 DOM 元素而出现过渡占用内存、页面卡顿等性能问题，带来糟糕的用户体验。因此必须对这种业务场景做相应的加载优化，<strong>只加载需要显示的元素</strong>是这种情况的唯一解，「虚拟列表」的概念应运而生。</p>
<h2 id="shimoshixuniliebiao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshixuniliebiao')">¶</a> 什么是虚拟列表？</h2>
<p>首先，来说说「虚拟列表」的定义，它的本质就是仅将<strong>需要显示在视窗中</strong>的列表节点挂载到 DOM，以达到「减少<strong>一次性加载节点数量</strong>」和「减少<strong>滚动容器内总挂载节点数量</strong>」的目的，也即：</p>
<blockquote>
<p>通过「<strong>单个元素高度</strong>」计算当前列表全部加载时的高度作为「<strong>滚动容器</strong>」的「<strong>可滚动高度</strong>」，按该「<strong>可滚动高度</strong>」撑开「<strong>滚动容器</strong>」。并根据「<strong>当前滚动高度</strong>」，在「<strong>可视区域</strong>」内按需加载列表元素。</p>
</blockquote>
<h3 id="xiangguangainian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangguangainian')">¶</a> 相关概念</h3>
<p>上面的描述提到了几个关键的概念，它们分别是：</p>
<ul>
<li>
<p><strong>单个元素高度</strong>：列表内每个独立元素的高度，它可以是固定的或者是动态的。</p>
</li>
<li>
<p><strong>滚动容器</strong>：意指挂载列表元素的 DOM 对象，它可以是自定义的元素或者<code>window</code>对象(默认)。</p>
</li>
<li>
<p><strong>可滚动高度</strong>：滚动容器可滚动的纵向高度。当滚动容器的高度（宽度），小于它的子元素所占的总高度（宽度）且该滚动容器的<code>overflow</code>不为<code>hidden</code>时，此时滚动容器的<code>scrollHeight</code>为<strong>可滚动高度</strong>。</p>
</li>
<li>
<p><strong>可视区域</strong>：滚动容器的视觉可见区域。如果容器元素是<code>window</code>对象，可视区域就是浏览器的视口大小（即视觉视口）；如果容器元素是某个 ul 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域，也即是该滚动容器的<code>offsetHeight</code>。</p>
</li>
<li>
<p><strong>当前滚动高度</strong>：与平常的滚动高度概念一致。虽然虚拟列表仅加载需要显示在可视区域内的元素，但是为了维持与常规列表一致的滚动体验，必须通过监听当前滚动高度来动态更新需要显示的元素。</p>
</li>
</ul>
<p>参考下图加深理解：</p>
<p><img src="_nuxt/img/pic-0.8c610f9.png" alt=""></p>
<h3 id="shixianluojibuzhou"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shixianluojibuzhou')">¶</a> 实现逻辑步骤</h3>
<p>因此，实现「虚拟列表」可以简单理解为就是在列表发生滚动时，改变「可视区域」内的渲染元素。大概的文字逻辑步骤如下：</p>
<ol>
<li>根据单个元素高度计算出滚动容器的可滚动高度，并撑开滚动容器；</li>
<li>根据可视区域计算总挂载元素数量；</li>
<li>根据可视区域和总挂载元素数量计算头挂载元素（初始为 0）和尾挂载元素；</li>
<li>当发生滚动时，根据滚动差值和滚动方向，重新计算头挂载元素和尾挂载元素。</li>
</ol>
<p>根据这些步骤，下面开始通过实际代码对「虚拟列表」进行实现。</p>
<h2 id="gudinggaodudexuniliebiao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gudinggaodudexuniliebiao')">¶</a> 固定高度的虚拟列表</h2>
<h3 id="zhunbeigongzuogudinggaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhunbeigongzuogudinggaodu')">¶</a> 准备工作|固定高度</h3>
<p>首先，创建列表元素组件，约定它的高度固定为<code>180px</code>：</p>
<pre  class="language-html"><code class="language-html">&lt;template&gt;
  &lt;li class=&quot;item&quot; ref=&quot;item&quot;&gt;
    &lt;div class=&quot;item__wrapper&quot;&gt;
      &lt;div class=&quot;item__info&quot;&gt;
        &lt;img :src=&quot;data.avatar&quot; class=&quot;item__avatar&quot; /&gt;
        &lt;p class=&quot;item__name&quot;&gt;{{ index }}. {{ data.name }}&lt;/p&gt;
        &lt;p class=&quot;item__date&quot;&gt;{{ data.dob }}&lt;/p&gt;
      &lt;/div&gt;
      &lt;p class=&quot;item__text&quot;&gt;E-mail: {{ data.email }}&lt;/p&gt;
      &lt;p class=&quot;item__text&quot;&gt;Phone: {{ data.phone }}&lt;/p&gt;
      &lt;p class=&quot;item__text&quot;&gt;City: {{ data.address.city }}&lt;/p&gt;
      &lt;p class=&quot;item__text&quot;&gt;Street: {{ data.address.street }}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: 'item',
    props: {
      index: {
        type: Number, // 元素下标
        default: 0,
      },
      data: {
        type: Object,
        default: () =&gt; ({}),
      },
    },
  };
&lt;/script&gt;
&lt;style scoped lang=&quot;scss&quot;&gt;
  .item {
    height: 180px;
    /* ... */
  }
&lt;/style&gt;
</code></pre><p>通过<a href="https://github.com/marak/Faker.js/" target="_blank">faker.js</a>来生成一些随机数据，以满足分页加载的测试情况：</p>
<pre  class="language-js"><code class="language-js">import faker from 'faker';

export function fetchData(count = 30) {
  const result = [];
  for (let i = 0; i &lt; count; i++) {
    const item = faker.helpers.contextualCard();
    item.paragraph = faker.lorem.paragraph();
    result.push(item);
  }
  return result;
}
</code></pre><p>最后，创建滚动容器组件，引入<code>item</code>组件和随机数据，渲染列表：</p>
<pre  class="language-html"><code class="language-html">&lt;template&gt;
  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot;&gt;
    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in listData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; /&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
  import Item from './components/item';
  import { fetchData } from './helpers';

  const FIXED_HEIGHT = 180;

  export default {
    name: 'height-fixed',
    data() {
      return {
        listData: [],
      };
    },
    mounted() {
      this.fetchData();
    },
    methods: {
      fetchData() {
        this.listData.push(...this.setItemIndex(fetchData()));
      },
      // 给每个列表元素设置固定的下标
      setItemIndex(list) {
        let latestIndex = this.listData.length;
        for (let i = 0; i &lt; list.length; i++) {
          const item = list[i];
          item.index = latestIndex + i;
          Object.freeze(item);
        }
        return list;
      },
    },
    components: { Item },
  };
&lt;/script&gt;
&lt;style scoped lang=&quot;scss&quot;&gt;
  .height-fixed {
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    overflow-y: scroll;
    /* ... */
  }
&lt;/style&gt;
</code></pre><p>通过路由挂载后，完成一个常规列表的渲染，如下图：</p>
<p><img src="_nuxt/img/pic-1.92a1651.png" alt=""></p>
<h3 id="jisuankegundonggaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jisuankegundonggaodu')">¶</a> 计算「可滚动高度」</h3>
<p>因为元素高度是固定，所以在拿到列表数据时就可以通过 <strong>列表长度</strong> * <strong>元素高度</strong> 获得「可滚动高度」，然后使用此高度撑开滚动容器。通过上文图一可以得知，可滚动高度由「可视区域」+「已浏览区域」+「待浏览区域」组成，关于如何撑开「已浏览区域」和「待浏览区域」，有两种常规的做法：</p>
<ul>
<li>直接使用 padding 撑开列表高度；</li>
<li>在列表可视区域外部放置哨兵元素撑开高度。</li>
</ul>
<p>为了更好地理解后文「动态高度的虚拟列表」的内容，这里选用第二种方法。</p>
<p>新增<code>scrollRunwayEnd</code>属性，在列表获取后计算总高度：</p>
<pre  data-line="6,12" class="language-js"><code data-line="6,12" class="language-js">export default {
  // ...
  data() {
    return {
      // ...
      scrollRunwayEnd: 0,
    };
  },
  methods: {
    fetchData() {
      this.listData.push(...this.setItemIndex(fetchData()));
      this.scrollRunwayEnd = this.listData.length * FIXED_HEIGHT;
    },
  },
  // ...
};
</code></pre><p>在模板内增加<code>scroll-runway</code>元素，根据<code>scrollRunwayEnd</code>，使用<code>transform: translateY</code>的方式撑开「滚动容器」高度：</p>
<pre  data-line="3" class="language-html"><code data-line="3" class="language-html">&lt;template&gt;
  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot; @scroll=&quot;handleScroll&quot;&gt;
    &lt;li class=&quot;height-fixed__scroll-runway&quot; :style=&quot;`transform: translate(0, ${scrollRunwayEnd}px)`&quot;&gt;&lt;/li&gt;
    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in listData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; /&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;!-- ... --&gt;
&lt;style scoped lang=&quot;scss&quot;&gt;
  .height-fixed {
    /* ... */
    &amp;__scroll-runway {
      position: absolute;
      width: 1px;
      height: 1px;
      transition: transform 0.2s;
    }
  }
&lt;/style&gt;
</code></pre><h3 id="jisuanchushikeshiyuansu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jisuanchushikeshiyuansu')">¶</a> 计算初始「可视元素」</h3>
<p>「可视元素」使用<code>visibleData</code>表示，<code>visibleData</code>可使用「头挂载元素」和「尾挂载元素」分别代表的元素下标在原始的<code>listData</code>进行动态截取。</p>
<p>根据固定的元素高度和「滚动容器」的高度，可以轻松得出「可视元素」的个数为 <strong>滚动容器高度</strong> / <strong>单个元素高度</strong>，使用<code>VISIBLE_COUNT</code>表示。同时，为了在快速滚动的情况下也能获得较为良好的数据现实体验，可以适当设置「缓冲区元素」，使用<code>BUFFER_SIZE</code>表示。</p>
<p>新增<code>visibleData</code>数组，用于「可视元素」的装载。页面初次挂载时，「头挂载元素」<code>firstAttachedItem</code>必定为 0，再根据<code>VISIBLE_COUNT</code>和<code>BUFFER_SIZE</code>可得「尾挂载元素」<code>lastAttachedItem</code>：</p>
<pre  class="language-js"><code class="language-js">// ...
const BUFFER_SIZE = 3; // 「缓冲区元素」个数
let VISIBLE_COUNT = 0;

export default {
  name: 'height-fixed',
  data() {
    return {
      // ...
      visibleData: [],
      firstAttachedItem: 0, // 「头挂载元素」
      lastAttachedItem: 0, // 「尾挂载元素」
    };
  },
  mounted() {
    VISIBLE_COUNT = Math.ceil(this.$refs.scroller.offsetHeight / FIXED_HEIGHT);
    this.lastAttachedItem = VISIBLE_COUNT + BUFFER_SIZE;
    this.visibleData = this.listData.slice(this.firstAttachedItem, this.lastAttachedItem);
  },
};
</code></pre><p>将<code>listData</code>更改为<code>visibleData</code>：</p>
<pre  data-line="4" class="language-html"><code data-line="4" class="language-html">&lt;template&gt;
  &lt;ul class=&quot;height-fixed&quot; ref=&quot;scroller&quot;&gt;
    &lt;li class=&quot;height-fixed__scroll-runway&quot; :style=&quot;`transform: translate(0, ${scrollRunwayEnd}px)`&quot;&gt;&lt;/li&gt;
    &lt;item class=&quot;height-fixed__item&quot; v-for=&quot;item in visibleData&quot; :data=&quot;item&quot; :index=&quot;item.index&quot; :key=&quot;item.username + item.phone&quot; /&gt;
  &lt;/ul&gt;
&lt;/template&gt;
</code></pre><p>在获得了<code>visibleData</code>后，下一步需要改变列表元素的显示方式。对每个列表元素使用绝对定位，使其脱离文档流，然后使用<code>transform: translateY</code>的方式来对元素进行定位。</p>
<p>将<code>setItemIndex</code>方法更改为<code>calItemScrollY</code>，并根据下标，赋值给每个元素固定的<code>scrollY</code>：</p>
<pre  data-line="15" class="language-js"><code data-line="15" class="language-js">// setItemIndex(list) {
//   let latestIndex = this.listData.length;
//   for (let i = 0; i &lt; list.length; i++) {
//     const item = list[i];
//     item.index = latestIndex + i;
//     Object.freeze(item);
//   }
//   return list;
// }
calItemScrollY(list) {
  let latestIndex = this.listData.length;
  for (let i = 0; i &lt; list.length; i++) {
    const item = list[i];
    item.index = latestIndex + i;
    item.scrollY = this.scrollRunwayEnd + i * FIXED_HEIGHT;
    Object.freeze(item);
  }
  return list;
},
</code></pre><pre  data-line="9,17" class="language-html"><code data-line="9,17" class="language-html">&lt;template&gt;
  &lt;!-- ... --&gt;
  &lt;item
    class=&quot;height-fixed__item&quot;
    v-for=&quot;item in visibleData&quot;
    :data=&quot;item&quot;
    :index=&quot;item.index&quot;
    :key=&quot;item.username + item.phone&quot;
    :style=&quot;`transform: translate(0, ${item.scrollY}px)`&quot;
  /&gt;
  &lt;!-- ... --&gt;
&lt;/template&gt;
&lt;!-- ... --&gt;
&lt;style scoped lang=&quot;scss&quot;&gt;
  .height-fixed {
    /* ... */
    &amp;__item {
      position: absolute;
      contain: layout;
      will-change: transform;
    }
  }
&lt;/style&gt;
</code></pre><h3 id="gundonggengxinkeshiyuansugudinggaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gundonggengxinkeshiyuansugudinggaodu')">¶</a> 滚动更新「可视元素」|固定高度</h3>
<p>在处理滚动逻辑之前，先引入一个概念：<strong>「锚点元素」</strong>，即处于「滚动容器」的「可视区域」内的<strong>第一个元素</strong>。我们需要在滚动时候，根据每一次滚动事件的滚动差值和方向来更新「锚点元素」，计算出「锚点元素」后，就可以根据新的「锚点元素」下标和缓冲区值<code>BUFFER_SIZE</code>、<code>VISIBLE_COUNT</code>来计算「头挂载元素」和「尾挂载元素」。</p>
<pre  class="language-text"><code class="language-text">「锚点元素」= 「当前滚动高度」/ FIXED_HEIGHT // 当偏移量绝对值大于 FIXED_HEIGHT 时需要重新计算；
「头挂载元素」=「锚点元素」- BUFFER_SIZE // 不能小于 0，即第一个元素；
「尾挂载元素」= 「头挂载元素」+ VISIBLE_COUNT + BUFFER_SIZE // 不能大于列表长度，即最后一个元素；
</code></pre><p>「锚点元素」大部分情况下处于被<strong>部分遮盖</strong>的状态，被遮盖的部分为它的偏移量<code>offset</code>，其中包含指向具体元素的下标<code>index</code>，如下图所示：</p>
<p><img src="_nuxt/img/pic-3.9db10a7.png" alt=""></p>
<hr>
<p>了解了「锚点元素」概念之后，接下来就可以处理「滚动容器」的滚动行为了，首先监听滚动事件：</p>
<pre  data-line="2" class="language-html"><code data-line="2" class="language-html">&lt;template&gt;
  &lt;ul ref=&quot;scroller&quot; class=&quot;height-fixed&quot; @scroll=&quot;handleScroll&quot;&gt;
    &lt;!-- ... --&gt;
  &lt;/ul&gt;
&lt;/template&gt;
</code></pre><p>根据滚动方向和偏移量，按顺序更新「锚点元素」→「头挂载元素」→「尾挂载元素」→「可视元素」：</p>
<pre  data-line="52" class="language-js"><code data-line="52" class="language-js">// ...
export default {
  // ...
  data() {
    return {
      // ...
      anchorItem: { index: 0, offset: 0 }, // 「锚点元素」初始值
      lastScrollTop: 0, // 记录上次滚动事件时「滚动容器」的「滚动高度」
    };
  },
  methods: {
    // 「锚点元素」更新方法
    updateAnchorItem() {
      const index = Math.floor(this.$refs.scroller.scrollTop / FIXED_HEIGHT);
      const offset = this.$refs.scroller.scrollTop - index * FIXED_HEIGHT;
      this.anchorItem = { index, offset };
    },
    handleScroll() {
      // 滚动差值
      const delta = this.$refs.scroller.scrollTop - this.lastScrollTop;
      this.lastScrollTop = this.$refs.scroller.scrollTop;

      // 更新「锚点元素」偏移量
      this.anchorItem.offset += delta;
      const isPositive = delta &gt;= 0;
      // 判断滚动方向
      if (isPositive) {
        // 1.当「锚点元素」偏移量大于等于固定高度时，说明视图滚动条向下，并超过一个元素，需要更新「锚点元素」
        if (this.anchorItem.offset &gt;= FIXED_HEIGHT) {
          this.updateAnchorItem();
        }
        // 2.计算「头挂载元素」
        if (this.anchorItem.index - this.firstAttachedItem &gt;= BUFFER_SIZE) {
          this.firstAttachedItem = Math.min(this.listData.length - VISIBLE_COUNT, this.anchorItem.index - BUFFER_SIZE);
        }
      } else {
        if (this.$refs.scroller.scrollTop &lt;= 0) {
          // 特殊情况：处理滚动到顶部，更新「锚点元素」为初始值
          this.anchorItem = { index: 0, offset: 0 };
        } else if (this.anchorItem.offset &lt; 0) {
          // 1.当「锚点元素」偏移量小于零时，说明视图滚动条向上，并超过一个元素，需要更新「锚点元素」
          this.updateAnchorItem();
        }
        // 2.计算「头挂载元素」
        if (this.anchorItem.index - this.firstAttachedItem &lt; BUFFER_SIZE) {
          this.firstAttachedItem = Math.max(0, this.anchorItem.index - BUFFER_SIZE);
        }
      }
      // 3.更新「尾挂载元素」
      this.lastAttachedItem = Math.min(this.firstAttachedItem + VISIBLE_COUNT + BUFFER_SIZE * 2, this.listData.length);
      // 4.更新「可视元素」
      this.visibleData = this.listData.slice(this.firstAttachedItem, this.lastAttachedItem);
    },
  },
};
</code></pre><p>至此，一个简单的「固定高度虚拟滚动」就实现了，打开开发者工具，可以观察到就算滚动条一直向下，列表元素的个数是恒定的：</p>
<p><img src="_nuxt/img/pic-8.a90bd13.gif" alt=""></p>
<p>你可以点击<a href="https://lkangd.github.io/infinite-scroll-sample/#/height-fixed" target="_blank">此处</a>进行体验。</p>
<h2 id="dongtaigaodudexuniliebiao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'dongtaigaodudexuniliebiao')">¶</a> 动态高度的虚拟列表</h2>
<p>因为不再具有固定的元素高度，所以「可滚动高度」和「可视元素」很难像实现固定高度的虚拟列表那样，可以在获取数据后进行一次性计算就完事。下面来说说动态高度虚拟列表的关键难点：</p>
<h3 id="guanjiandianyiruhehuodeyuansudedongtaigaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandianyiruhehuodeyuansudedongtaigaodu')">¶</a> 关键点一：如何获得元素的动态高度？</h3>
<p>按常规情况，一个列表元素高度为动态的情况大致分为三种：</p>
<ol>
<li>列表元素内初始渲染时高度就不确定。比如<strong>不定行数</strong>的多行文本、列表元素内包含<strong>不定长度</strong>的内嵌列表等；</li>
<li>列表元素内初始渲染后因用户操作而高度发生变化。比如展开一个<strong>收缩项目</strong>、<strong>删除或增加</strong>子元素等；</li>
<li>列表元素内包含异步渲染元素。比如未缓存过的<strong>图片</strong>、<strong>异步组件</strong>等。</li>
</ol>
<p>由于这些复杂的情况可能同时存在一个列表元素内，所以只能够实时监听每一个<strong>处于可视区域</strong>内的元素的高度。现阶段 ECMA DOM 规范下，有两个 API 可以达到这个目的：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank">MutationObserver</a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver" target="_blank">ResizeObserver</a>。</p>
<p>这两个 API 都存在一定的兼容性问题，<a href="https://caniuse.com/#feat=resizeobserver" target="_blank">caniuse#ResizeObserver</a> | <a href="https://caniuse.com/#search=MutationObserver" target="_blank">caniuse#MutationObserver</a>，可以使用对应的<code>polyfill</code>进行解决，因为<code>ResizeObserver</code>可以更直观地达到监听元素高度变动的目的，所以这里选择使用<code>ResizeObserver</code>。<code>ResizeObserver</code>的 <a href="https://github.com/que-etc/resize-observer-polyfill" target="_blank">polyfill</a>。</p>
<h3 id="guanjiandianerruhemonikegundonggaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandianerruhemonikegundonggaodu')">¶</a> 关键点二：如何模拟「可滚动高度」？</h3>
<p>因为列表元素的高度不再是固定的，所以「可滚动高度」不能再通过「列表元素个数」*「固定元素高度」简单逻辑关系来获得。此时，只能基于业务的实际情况，给每个列表元素定一个「估算高度」：<code>ESTIMATED_HEIGHT</code>。</p>
<p>同时，还需要新增一个<code>cachedHeight</code>数组，根据上一关键点提到的元素高度变化事件，以每一个列表元素对应的下标记录最后一次变化的高度。如果元素未渲染或者被略过渲染时，用<code>ESTIMATED_HEIGHT</code>进行暂时代替。</p>
<p>由此可得知，「可滚动高度」<code>scrollRunwayEnd</code>只能是「动态」且「大致准确」的。在 vue 里，可以用一个「计算属性」进行实时估值：</p>
<pre  class="language-js"><code class="language-js">  // ...
  data() {
    return {
      // ...
      // scrollRunwayEnd: 0,
    };
  },
  computed: {
    scrollRunwayEnd() {
      // 根据当前已渲染的元素高度，求得当前所有元素总高度
      const maxScrollY = this.cachedHeight.reduce((sum, h) =&gt; (sum += h || ESTIMATED_HEIGHT), 0);
      // 根据当前所有元素总高度，求得元素平均高度
      const currentAverageH = maxScrollY / this.cachedHeight.length;
      // 返回估算高度
      return maxScrollY + (this.listData.length - this.cachedHeight.length) * currentAverageH;
    },
  },
  // ...
</code></pre><h3 id="guanjiandiansanruhejisuanmeiyigeyuansudescrollY"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanjiandiansanruhejisuanmeiyigeyuansudescrollY')">¶</a> 关键点三：如何计算每一个元素的「scrollY」？</h3>
<p>这一步是最难的，因为除了第一个元素外的每一个元素的「scrollY」可能都会因为下面几种情况而失效：</p>
<ol>
<li><strong>当前元素的上一个元素高度发生了变化。</strong> 这种情况意味着从<strong>当前元素</strong>开始，每一个后续元素都需要按<strong>上一个元素</strong>的高度差值进行「scrollY」计算。</li>
<li><strong>用户快速拖动滚动条至底部或顶部。</strong> 由于略过了中间元素的渲染，<code>cachedHeight</code>会缺少略过元素的真实高度，所以只能用上文的<code>ESTIMATED_HEIGHT</code>进行代替。这种情况下用户再缓慢滚动到顶部时，略过元素的初次渲染会更新<code>cachedHeight</code>中对应的记录。此时更新的高度肯定是大于或者小于<code>ESTIMATED_HEIGHT</code>的，所以当用户持续滚动缓慢滚动到<code>scrollTop</code>为 0 时，可能会出现 <strong><em>上部滚动区域</em></strong>「不足」或者「多余」的情况。因此，必须在<strong>保证当前页面滚动情况不变</strong>的前提下，提前对这两种情况进行实时修正，也即修正<code>scrollTop</code>的同时重新计算「锚点元素」。</li>
<li><strong>屏幕宽度发生改变。</strong> 手机屏幕横竖方向改变和手动改变浏览器窗口大小都可能导致「滚动容器」的宽度发生变化，「滚动容器」的宽度决定了列表元素的高度，这种情况下每一个元素的「scrollY」都将失效，需要重新计算。同时，为了更好地的用户体验，我们应该在宽度发生变化时，保持「锚定元素」的<code>offset</code>不变，举一个 twitter 例子：<br>
<img src="_nuxt/img/pic-4.194b7ea.gif" alt=""></li>
</ol>
<p>因此，这里我们不再将「scrollY」直接赋予每一个列表元素，而是新增一个<code>cachedScrollY</code>数组用于存储所有列表元素的临时「scrollY」。在每一次滚动事件发生时，根据滚动差值是否超过「锚点元素」对应的<code>cachedHeight</code>去判断是否需要更新「锚点元素」。如果「锚点元素」发生改变，以「锚点元素」为基点，用每一个「可视元素」对应的<code>cachedHeight</code>叠加「锚点元素」的「scrollY」去计算自身的「scrollY」，然后更新每个列表元素对应<code>cachedScrollY</code>，最后渲染到「可视区域」。</p>
<h3 id="zhunbeigongzuodongtaigaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zhunbeigongzuodongtaigaodu')">¶</a> 准备工作|动态高度</h3>
<p>修改随机数据函数，给每个元素增加<strong>随机图片</strong>和该图片的<strong>随机宽度</strong>：</p>
<pre  data-line="7,8" class="language-js"><code data-line="7,8" class="language-js">export function fetchData(count = 30) {
  const result = [];
  for (let i = 0; i &lt; count; i++) {
    const item = faker.helpers.contextualCard();
    item.paragraph = faker.lorem.paragraph();
    item.img = {
      src: `/images/${faker.random.number({ min: 1, max: 20 })}.jpeg`, // 从给定的 20 张图片内随机
      width: `${faker.random.number({ min: 100, max: 700 })}px`, // 从 100px - 700px 范围内随机
    };
    result.push(item);
  }
  return result;
}
</code></pre><p>修改<code>item</code>组件，注意加载的两张图片：一张为正常加载的图片，一张为<strong>人工延时</strong>加载的图片：</p>
<pre  data-line="8-14" class="language-html"><code data-line="8-14" class="language-html">&lt;template&gt;
  &lt;li class=&quot;item&quot; ref=&quot;item&quot;&gt;
    &lt;div class=&quot;item__wrapper&quot; :class=&quot;{ 'is-fixed': fixedHeight }&quot;&gt;
      &lt;!-- ... --&gt;
      &lt;template v-if=&quot;fixedHeight&quot;&gt;
        &lt;!-- ... --&gt;
      &lt;/template&gt;
      &lt;template v-else&gt;
        &lt;p class=&quot;item__paragraph&quot;&gt;{{ data.paragraph }}&lt;/p&gt;
        &lt;!-- 模拟延时加载图片 --&gt;
        &lt;img class=&quot;item__img&quot; :src=&quot;defferImgSrc&quot; :style=&quot;{width: data.img.width}&quot; /&gt;
        &lt;!-- 正常加载图片 --&gt;
        &lt;img class=&quot;item__img&quot; :src=&quot;data.img.src&quot; :style=&quot;{width: data.img.width}&quot; /&gt;
      &lt;/template&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/template&gt;
&lt;script&gt;
  // ...
  export default {
    // ...
    props: {
      // ...
      fixedHeight: {
        type: Boolean,
        default: true,
      },
    },
    data() {
      return {
        defferImgSrc: '',
      };
    },
    created() {
      // 模拟图片加载时间
      if (this.data.img.isDeffer) {
        this.defferImgSrc = this.data.img.src;
      } else {
        setTimeout(() =&gt; {
          this.defferImgSrc = this.data.img.src;
          this.data.img.isDeffer = true;
        }, faker.random.number({ min: 300, max: 5000 }));
      }
    },
  };
&lt;/script&gt;
</code></pre><p>最后，在<code>mounted</code>钩子内使用 <a href="https://github.com/que-etc/resize-observer-polyfill" target="_blank">resize-observer-polyfill</a> 监听元素高度变化：</p>
<pre  data-line="10" class="language-js"><code data-line="10" class="language-js">import ResizeObserver from 'resize-observer-polyfill';

export default {
  // ...
  mounted() {
    if (this.fixedHeight) return;

    const ro = new ResizeObserver((entries, observer) =&gt; {
      // 高度发生变化时，将 'size-change' 事件 emit 到父组件
      this.$emit('size-change', this.index);
    });
    ro.observe(this.$refs.item);
    this.$once('hook:beforeDestroy', ro.disconnect.bind(ro));
  },
  // ...
};
</code></pre><p>通过路由挂载后，完成一个动态高度元素列表的渲染，如下图：<br>
<img src="_nuxt/img/pic-2.42bae0b.png" alt=""></p>
<h3 id="jiantingyuansugaodubianhua"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jiantingyuansugaodubianhua')">¶</a> 监听元素高度变化</h3>
<p>在每一次「可视元素」的高度发生变化时，以「锚点元素」为基点，计算出「锚点元素」的<code>scrollY</code>，然后按「锚点元素」之前和之后的元素进行区别计算，得出所有「可视元素」的最新<code>scrollY</code>。</p>
<p><em>注意：列表元素的初次渲染和后续的高度变化都会触发<code>ResizeObserver</code>事件</em></p>
<pre  data-line="13" class="language-html"><code data-line="13" class="language-html">&lt;template&gt;
  &lt;ul ref=&quot;scroller&quot; class=&quot;height-dynamic&quot; @scroll=&quot;handleScroll&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;item
      class=&quot;height-dynamic__item&quot;
      v-for=&quot;item in visibleData&quot;
      ref=&quot;items&quot;
      :data=&quot;item&quot;
      :fixed-height=&quot;false&quot;
      :key=&quot;item.username + item.phone&quot;
      :index=&quot;item.index&quot;
      :style=&quot;`transform: translate(0, ${cachedScrollY[item.index]}px)`&quot;
      @size-change=&quot;handleSizeChange&quot;
    /&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    // ...
    methods: {
      handleSizeChange(index) {
        this.calItemScrollY();
      },
      // 计算每一个「可视元素」的 scrollY
      async calItemScrollY() {
        await this.$nextTick();
        // 修正 vue diff 算法导致「可视元素」顺序不正确的问题
        this.$refs.items.sort((a, b) =&gt; a.index - b.index);

        // 获取「锚点元素」在「可视元素」中的序号
        const anchorDomIndex = this.$refs.items.findIndex(item =&gt; item.index === this.anchorItem.index);
        const anchorDom = this.$refs.items[anchorDomIndex];
        const anchorDomHeight = anchorDom.$el.getBoundingClientRect().height;

        // 通过「滚动容器」的「当前滚动高度」和「锚点元素」的 offset 算出其 scrollY
        this.$set(this.cachedScrollY, this.anchorItem.index, this.$refs.scroller.scrollTop - this.anchorItem.offset);
        this.$set(this.cachedHeight, this.anchorItem.index, anchorDomHeight);

        // 计算 anchorItem 后面的列表元素 scrollY
        for (let i = anchorDomIndex + 1; i &lt; this.$refs.items.length; i++) {
          const item = this.$refs.items[i];
          const { height } = item.$el.getBoundingClientRect();
          this.$set(this.cachedHeight, item.index, height);
          // 当前元素的 scrollY 是上一个元素的 scrollY + 上一个元素的高度
          const scrollY = this.cachedScrollY[item.index - 1] + this.cachedHeight[item.index - 1];
          this.$set(this.cachedScrollY, item.index, scrollY);
        }
        // 计算 anchorItem 前面的列表元素 scrollY
        for (let i = anchorDomIndex - 1; i &gt;= 0; i--) {
          const item = this.$refs.items[i];
          const { height } = item.$el.getBoundingClientRect();
          this.$set(this.cachedHeight, item.index, height);
          // 当前元素的 scrollY 是下一个元素的 scrollY - 当前元素的高度
          const scrollY = this.cachedScrollY[item.index + 1] - this.cachedHeight[item.index];
          this.$set(this.cachedScrollY, item.index, scrollY);
        }
      },
      // ...
    },
    // ...
  };
&lt;/script&gt;
</code></pre><h3 id="gundonggengxinkeshiyuansudongtaigaodu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'gundonggengxinkeshiyuansudongtaigaodu')">¶</a> 滚动更新「可视元素」|动态高度</h3>
<p>「可滚动高度」的计算已经在上面提过，而初始「可视元素」和固定高度的虚拟列表的计算是类似的，所以这里跳过这两点，只描述如何处理滚动更新「可视元素」。</p>
<p>根据滚动方向和偏移量，按顺序更新「锚点元素」→「头挂载元素」→「尾挂载元素」→「可视元素」：</p>
<pre  class="language-js"><code class="language-js">// ...
export default {
  // ...
  methods: {
    // ...
    handleScroll() {
      const delta = this.$refs.scroller.scrollTop - this.lastScrollTop;
      this.lastScrollTop = this.$refs.scroller.scrollTop;
      // 1.更新「锚点元素」
      this.updateAnchorItem(delta);
      // 更新「头挂载元素」→「尾挂载元素」→「可视元素」
      this.updateVisibleData();
    },
    async updateAnchorItem(delta) {
      const lastIndex = this.anchorItem.index;
      const lastOffset = this.anchorItem.offset;
      delta += lastOffset;

      let index = lastIndex;
      const isPositive = delta &gt;= 0;
      // 判断滚动方向
      if (isPositive) {
        // 用 delta 一直减去从「锚点元素」开始向下方向的「可视元素」高度，每减一次 index 前进一位
        while (index &lt; this.listData.length &amp;&amp; delta &gt; (this.cachedHeight[index] || ESTIMATED_HEIGHT)) {
          // 当 this.cachedHeight[index] 不存在时，说明可能被快速拖动滚动条而略过渲染，此时需要填充估计高度
          if (!this.cachedHeight[index]) {
            this.$set(this.cachedHeight, index, ESTIMATED_HEIGHT);
          }
          delta -= this.cachedHeight[index];
          index++;
        }
        if (index &gt;= this.listData.length) {
          this.anchorItem = { index: this.listData.length - 1, offset: 0 };
        } else {
          this.anchorItem = { index, offset: delta };
        }
      } else {
        // 用 delta 一直叠加从「锚点元素」开始向上方向的「可视元素」高度，每加一次 index 后退一位
        while (delta &lt; 0) {
          // 当 this.cachedHeight[index] 不存在时，说明可能被快速拖动滚动条而略过渲染，此时需要填充估计高度
          if (!this.cachedHeight[index - 1]) {
            this.$set(this.cachedHeight, index - 1, ESTIMATED_HEIGHT);
          }
          delta += this.cachedHeight[index - 1];
          index--;
        }
        if (index &lt; 0) {
          this.anchorItem = { index: 0, offset: 0 };
        } else {
          this.anchorItem = { index, offset: delta };
        }
      }
    },
    updateVisibleData() {
      // 2.更新「头挂载元素」，注意不能小于 0
      const start = (this.firstAttachedItem = Math.max(0, this.anchorItem.index - BUFFER_SIZE));
      // 3.更新「尾挂载元素」
      this.lastAttachedItem = this.firstAttachedItem + VISIBLE_COUNT + BUFFER_SIZE * 2;
      const end = Math.min(this.lastAttachedItem, this.listData.length);
      // 4.更新「可视元素」
      this.visibleData = this.listData.slice(start, end);
    },
    // ...
  },
  // ...
};
</code></pre><h3 id="xiuzhenggundongtiao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiuzhenggundongtiao')">¶</a> 修正滚动条</h3>
<p>到这一步，这个「动态高度虚拟列表」已经大致可用了，但是还有一个问题，就是当用户快速拖动滚动条，因为「滚动差值」很大，所以会略过中间元素的渲染，此时这些略过的元素在<code>cachedHeight</code>中用<code>ESTIMATED_HEIGHT</code>进行存储，因此会出现两种情况：</p>
<ol>
<li><strong>估算的「可滚动高度」小于实际的「可滚动高度」</strong>。比如略过了中间 20 个元素，这些略过元素的估算高度总值为 ESTIMATED_HEIGHT(180) * 20 = 3600，而假设实际元素真正渲染时的平均高度为 300，即略过元素的实际高度总值为 300 * 20 = 6000。可以得知差值为 3600 - 6000 = -2400，滚动到顶部时，无法滚动到第一个元素。</li>
<li><strong>估算的「可滚动高度」大于实际的「可滚动高度」</strong>。比如略过了中间 20 个元素，这些略过元素的估算高度总值为 ESTIMATED_HEIGHT(180) * 20 = 3600，而假设实际元素真正渲染时的平均高度为 100，即略过元素的实际高度总值为 100 * 20 = 2000。可以得知差值为 3600 - 2000 = 1600，滚动到顶部时会有空白部分。</li>
</ol>
<p>考虑在这种情况下，可能会有往回滚动的场景，所以必须在发现「可滚动高度」过小或过大的时候，必须进行及时修正。修改原来的<code>handleScroll</code>、<code>updateAnchorItem</code>和<code>calItemScrollY</code>方法，添加相关逻辑。</p>
<pre  class="language-js"><code class="language-js">export default {
  data() {
    return {
      // ...
      revising: false,
    };
  },
  // ...
  methods: {
    // ...
    handleScroll() {
      if (this.revising) return; // 修正滚动条时，屏蔽滚动逻辑
      // ...
    },
    async updateAnchorItem(delta) {
      // ...
      // 修正拖动过快导致的滚动到顶端滚动条不足的偏差
      if (this.cachedScrollY[this.firstAttachedItem] &lt;= -1) {
        console.log('revising insufficient');
        this.revising = true;
        // 需要的修正的滚动高度为「锚点元素」之前的元素总高度 + 「锚点元素」的 offset
        const actualScrollTop =
          this.cachedHeight.slice(0, Math.max(0, this.anchorItem.index)).reduce((sum, h) =&gt; (sum += h), 0) + this.anchorItem.offset;
        this.$refs.scroller.scrollTop = actualScrollTop;
        this.lastScrollTop = this.$refs.scroller.scrollTop;
        if (this.$refs.scroller.scrollTop === 0) {
          this.anchorItem = { index: 0, offset: 0 };
        }
        // 更改了 lastScrollTop 后，需要重新计算「可视元素」的 scrollY
        this.calItemScrollY();
        this.revising = false;
      }
    },
    // 计算每一个「可视元素」的 scrollY
    async calItemScrollY() {
      // ...
      // 修正拖动过快导致的滚动到顶端有空余的偏差
      if (this.cachedScrollY[0] &gt; 0) {
        console.log('revising redundant');
        this.revising = true;
        // 第一个列表元素的 cachedScrollY 即为多出的量
        const delta = this.cachedScrollY[0];
        const last = Math.min(this.lastAttachedItem, this.listData.length);
        for (let i = 0; i &lt; last; i++) {
          this.$set(this.cachedScrollY, i, this.cachedScrollY[i] - delta);
        }
        const scrollTop = this.cachedScrollY[this.anchorItem.index - 1]
          ? this.cachedScrollY[this.anchorItem.index - 1] + this.anchorItem.offset
          : this.anchorItem.offset;
        this.$refs.scroller.scrollTop = scrollTop;
        this.lastScrollTop = this.$refs.scroller.scrollTop;
        this.revising = false;
      }
    },
    // ...
  },
  // ...
};
</code></pre><p>打完收工，「动态高度虚拟列表」实现完成，打开开发者工具，可以观察到就算滚动条一直向下，列表元素的个数都是恒定的，而且无论是快速拖动滚动条还是实时改变窗口宽度，整个列表都能正确地渲染：</p>
<p><img src="_nuxt/img/pic-9.8431154.gif" alt=""></p>
<p>你可以点击<a href="https://lkangd.github.io/infinite-scroll-sample/#/height-dynamic" target="_blank">此处</a>进行体验。</p>
<h2 id="zongjie"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zongjie')">¶</a> 总结</h2>
<p>本文介绍了前端业务开发中长列表的常规优化手段「虚拟列表」的定义和它在 Vue 环境中的实现，就「固定高度虚拟列表」和「动态高度虚拟列表」两个场景下以一个简单的 demo 详细讲述了虚拟列表的实现思路。</p>
<p>阅读完本文后可以发现，以本文的思路实现「虚拟列表」的关键在于「锚点元素」的计算和更新，理解了这一点之后就可以发现后续的实现都是按部就班的。</p>
<p>文字表达可能会有疏漏，建议通过下载本文的<a href="https://github.com/lkangd/infinite-scroll-sample" target="_blank">代码库</a>（基于 Vue 2.x）运行调试，加深理解。</p>
<p>如果有不正确或难以理解的地方，欢迎通过邮件和留言进行指正讨论。</p>
<blockquote>
<p><strong>重要提示：</strong> 本文所有代码及示例项目只用于探讨虚拟列表的实现原理，请勿直接使用于生产。</p>
</blockquote>
<h4 id="cankao"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'cankao')">¶</a> 参考</h4>
<p><a href="https://developers.google.com/web/updates/2016/07/infinite-scroller#scroll_anchoring" target="_blank">Complexities of an Infinite Scroller</a><br>
<a href="https://itsze.ro/blog/2017/04/09/infinite-list-and-react.html" target="_blank">Infinite List and React</a><br>
<a href="https://github.com/dwqs/blog/issues/70" target="_blank">浅说虚拟列表的实现原理</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SCSS 环境下的 BEM 优雅实践]]></title>
            <link>/post/write-bem-with-scss/</link>
            <guid>/post/write-bem-with-scss/</guid>
            <description><![CDATA[如何优雅地编写易维护和具语义化的样式代码？]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#shimoshiBEM">什么是 BEM？</a><ul><li><a href="#BEMdedingyi">BEM 的定义</a></li><li><a href="#daimashixian">代码实现</a></li><li><a href="#BEMdeyoudian">BEM 的优点</a></li><li><a href="#BEMdequedian">BEM 的缺点</a></li></ul></li><li><a href="#shimoshiSCSS">什么是 SCSS？</a><ul><li><a href="#SCSSdeanzhuangshiyong">SCSS 的安装使用</a></li><li><a href="#SCSSxiadeBEMbianxie">SCSS 下的 BEM 编写</a></li></ul></li><li><a href="#zuhezengqiang">组合增强</a><ul><li><a href="#zengqiangyuyihua">增强语义化</a></li><li><a href="#wanzhengdaimashixian">完整代码实现</a></li><li><a href="#shiyongSnippet">使用 Snippet</a></li></ul></li><li><a href="#jieyu">结语</a></li></ul></div></p>
<h2 id="shimoshiBEM"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshiBEM')">¶</a> 什么是 BEM？</h2>
<p>「<a href="https://en.bem.info/methodology/" target="_blank">BEM</a>」是一种关于如何编写高可维护性的「CSS」代码的方法论，它提出的概念是将用户界面划分为独立的块，使复杂界面开发变得更加快速和简单。这种方法论背后的想法和现代前端开发的「组件化」理念是高度一致的，如最新的「web components」规范，流行的前端开源框架「Angular」、「React」和「Vue」等。</p>
<h3 id="BEMdedingyi"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdedingyi')">¶</a> BEM 的定义</h3>
<p>「BEM」这个词分别由<code>Block</code>、<code>Element</code>和<code>Modifier</code>组成，也即是 <strong><em>块</em></strong>、<strong><em>元素</em></strong> 和 <strong><em>修饰器</em></strong>，如下图所示：</p>
<p><img src="_nuxt/img/pic-bem-structure.d8797ba.png" alt=""></p>
<p>绿色标记的是「Block」，代表有意义的独立实体。蓝色标记的是「Element」，代表属于块的元素部分。红色标记的是「Modifier」，代表用来修改块或元素的标志。</p>
<h3 id="daimashixian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'daimashixian')">¶</a> 代码实现</h3>
<p>上图的「Alert」提示框用代码来实现是这样的：</p>
<pre  class="language-html"><code class="language-html">&lt;div class=&quot;alert alert--size-medium&quot;&gt;
  &lt;h1 class=&quot;alert__title&quot;&gt;Alert title&lt;/h1&gt;
  &lt;p class=&quot;alert__content&quot;&gt;Here is some alert message.&lt;/p&gt;
  &lt;div class=&quot;alert__btn-wrapper&quot;&gt;
    &lt;button class=&quot;alert__btn alert__btn--highlight&quot;&gt;Cancel&lt;/button&gt;
    &lt;button class=&quot;alert__btn&quot;&gt;Confirm&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p><strong><em>Note</em></strong>:留意这里的 HTML 结构，元素是可以包含元素的，同理「块」也是可以包含「块」的，我们使用「BEM」处理的不是嵌套关系。</p>
<pre  class="language-css"><code class="language-css">.alert {
  /* some code here */
}
.alert--size-medium {
  /* some code here */
}
.alert__title {
  /* some code here */
}
.alert__content {
  /* some code here */
}
.alert__btn-wrapper {
  /* some code here */
}
.alert__btn {
  /* some code here */
}
.alert__btn--highlight {
  /* some code here */
}
</code></pre><h3 id="BEMdeyoudian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdeyoudian')">¶</a> BEM 的优点</h3>
<p>使用了「BEM」之后，可以看到几个明显的好处：</p>
<ol>
<li>
<p><strong>模块化：</strong><br>
块的样式从不依赖于页面上的其他元素，所以永远不会遇到级联问题。而且当遇到需要将模块从已完成的项目转移到新的项目中的时候，「BEM」的结构代码很容易迁移。</p>
</li>
<li>
<p><strong>复用性：</strong><br>
以不同的方式组合独立的块，并根据情况重用它们，可以减少需要维护的 CSS 代码数量。</p>
</li>
<li>
<p><strong>结构化：</strong><br>
「BEM」给 CSS 代码提供了一个坚实的结构，保持简单和容易理解。</p>
</li>
</ol>
<p><a href="https://lkangd.com" target="_blank">本博客</a>的样式就是应用了「BEM」的理念去编写的，而且为了增强独立性，还在 Class 名称前面加了「cs-」的命名空间。</p>
<h3 id="BEMdequedian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'BEMdequedian')">¶</a> BEM 的缺点</h3>
<p>可以看到使用了「BEM」来编写 CSS 之后，每个 Class 的名字变得很长，所以才会有人吐槽这就像是老太太的裹脚布——又长又臭。这是个容易解决的小问题，现代前端开发已经普遍使用<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_preprocessor" target="_blank">「CSS 预处理器」</a>来帮助编码工作者更好地书写 CSS，利用这些预处理器的「嵌套」、「父类引用」、「模块」等规则，可以让「BEM」编写量变低，编写速度更快。下面来介绍当前最流行的一种预处理器 ——「SCSS」</p>
<hr>
<h2 id="shimoshiSCSS"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shimoshiSCSS')">¶</a> 什么是 SCSS？</h2>
<p><a href="https://sass-lang.com/" target="_blank">SCSS</a> 是一个「CSS 预处理器」， 它提供了很多「嵌套」、「父类引用」、「模块」方便快捷的规则来帮助你更加快速地编写 CSS，在你代码正式落地到业务之前转换为真正的 CSS。SCSS 的语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。</p>
<h3 id="SCSSdeanzhuangshiyong"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SCSSdeanzhuangshiyong')">¶</a> SCSS 的安装使用</h3>
<ol>
<li>
<p><strong>独立使用</strong><br>
安装命令：</p>
<pre  class="language-bash"><code class="language-bash">npm install -g sass
</code></pre><p>创建后缀为 index.scss 的文件，编写样式：</p>
<pre  class="language-css"><code class="language-css">.block {
  /* some code here */
  &amp;--modifier {
    /* some code here */
  }
  &amp;__element {
    /* some code here */
    &amp;--modifier {
      /* some code here */
    }
  }
}
</code></pre><p>运行转换命令：</p>
<pre  class="language-bash"><code class="language-bash">sass source/stylesheets/index.scss build/stylesheets/index.css
</code></pre><p>转换结果，index.css:</p>
<pre  class="language-css"><code class="language-css">.block {
  /* some code here */
}
.block--modifier {
  /* some code here */
}
.block__element {
  /* some code here */
}
.block__element--modifier {
  /* some code here */
}
</code></pre><p><strong><em>Tip</em></strong>: 你可以到<a href="https://www.sassmeister.com/" target="_blank">sassmeister</a>查看 SCSS 实时编译为 CSS 的代码。</p>
</li>
<li>
<p><strong>配合打包工具使用</strong><br>
这里只介绍配合 webpack 使用，安装 sass 和相关 loader 到项目内：</p>
<pre  class="language-bash"><code class="language-bash">npm install css-loader style-loader node-sass sass-loader -D
</code></pre><p>改写 webpack 配置，注意 loader 的顺序，执行打包命令之后就会对使用到的 scss 文件进行转换，转换结果跟上面一样：</p>
<pre  data-line="7" class="language-javascript"><code data-line="7" class="language-javascript">module.exports = {
  // 其它配置省略
  module: {
    rules: [
      {
        test: /\.scss/,
        use: ['style-loader', 'css-loader', 'sass-loader'],
      },
    ],
  },
};
</code></pre></li>
</ol>
<h3 id="SCSSxiadeBEMbianxie"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'SCSSxiadeBEMbianxie')">¶</a> SCSS 下的 BEM 编写</h3>
<p>使用 SCSS 对上面的「Alert」组件的 CSS 部分进行重写：</p>
<pre  class="language-css"><code class="language-css">.alert {
  /* some code here */
  &amp;--size-medium {
    /* some code here */
  }
  &amp;__title {
    /* some code here */
  }
  &amp;__content {
    /* some code here */
  }
  &amp;__btn-wrapper {
    /* some code here */
  }
  &amp;__btn {
    /* some code here */
    &amp;--highlight {
      /* some code here */
    }
  }
}
</code></pre><p>可以看到利用 SCSS 的嵌套和父类名称引用，不再需要重复编写前面相同的部分，节省了大量的编写工作。</p>
<p>看到这里你可能会疑惑，这跟使用其它 CSS 预处理器没有区别啊，而且看起来还是很长。虽然使用了块、元素和修饰符之间的连接符，能一眼分辨出当前 Class 的种类，但是当需要大量重复编写的话，会让人很也不爽。下面进入正题，看看如何使用 SCSS 的优势来解决这两个问题。</p>
<hr>
<h2 id="zuhezengqiang"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zuhezengqiang')">¶</a> 组合增强</h2>
<p>Sass 在版本 3.3 更新了一个新的@（At-Rules）规则：<a href="https://sass.bootcss.com/documentation/at-rules/at-root" target="_blank"><code>@at-root</code></a>。它的作用是将嵌套内的 CSS 嵌套作用域移至当前 SCSS 文件的根作用域，可以说这个规则真的是为「BEM」而生的，它可以让「BEM」编写起来更语义化、更快捷优雅。</p>
<h3 id="zengqiangyuyihua"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'zengqiangyuyihua')">¶</a> 增强语义化</h3>
<p>这一步需要借助 SCSS 的<a href="https://sass-lang.com/documentation/at-rules/mixin" target="_blank"><code>mixins</code></a>来给「BEM」三个部分定一个语义化的 mixin，以求一眼就可以看出 class 的种类，而且不用编写连接符，第一个简单版本是这样的：</p>
<pre  data-line="11,13" class="language-css"><code data-line="11,13" class="language-css">/* 先定义三种 class 的 mixin */
$element-separator: '__';
$modifier-separator: '--';

@mixin block($block) {
  .#{$block} {
    @content;
  }
}
@mixin element($element) {
  /* 这里使用@at-root 将 mixin 的内容体提升至根作用域，使生成的 element 代码其不再嵌套在 block 内 */
  @at-root {
    /* 这里符号 &amp; 拿到父选择器的部分 */
    #{&amp; + $element-separator + $element} {
      @content;
    }
  }
}
@mixin modifier($modifier) {
  @at-root {
    #{&amp; + $modifier-separator + $modifier} {
      @content;
    }
  }
}

/* 然后这样使用 */
@include block(alert) {
  /* some code here */
  @include modifier(size-medium) {
    /* some code here */
  }
  @include element(title) {
    /* some code here */
  }
  @include element(content) {
    /* some code here */
  }
  @include element(btn-wrapper) {
    /* some code here */
  }
  @include element(btn) {
    /* some code here */
    @include modifier(highlight) {
      /* some code here */
    }
  }
}
</code></pre><p>第一个简单粗暴直接拼接的版本会带来一个问题，就是当 block--modifier 内嵌 block__element 或者 block__element 嵌套 block__element 的时候，得到的代码不会是真正想要的：</p>
<pre  data-line="24,28" class="language-css"><code data-line="24,28" class="language-css">/* 比如当设置中型（size-medium） alert 时，title 需要改变 */
@include block(alert) {
  /* some code here */
  @include modifier(size-medium) {
    /* some code here */
    @include element(title) {
      /* some code here */
    }
  }
  @include element(btn-wrapper) {
    /* some code here */
    @include element(btn) {
      /* some code here */
    }
  }
}
/* 生成的CSS */
.alert {
  /* some code here */
}
.alert--size-medium {
  /* some code here */
}
/* 这里的期望其实是 .alert--size-medium .alert__title */
.alert--size-medium__title {
  /* some code here */
}
/* 这里的期望其实是 .alert__btn-wrapper .alert__title */
.alert__btn-wrapper__btn {
  /* some code here */
}
</code></pre><p>所以这里需要处理的问题有两个：</p>
<ol>
<li>判断<code>Element</code>的父选择器是不是包含连接符号，也就是“--”或者“__”；</li>
<li>如果遇到父选择器包含连接符号“--”或者“__”的情况，需要取到父选择器中的「block」部分，也就是「.alert--size-medium」中「.alert」；</li>
</ol>
<p>首先解决第一个问题，实现起来也很简单，用 SCSS 自带的字符串函数<a href="https://sass-lang.com/documentation/modules/string#index" target="_blank">str-index</a>来判断，然后加个流程控制就可以了：</p>
<pre  class="language-css"><code class="language-css">/* 封装一下判断函数 */
@function containsSeparator($selector) {
  $selector: selectorToString($selector);

  @if str-index($selector, $modifier-separator) or str-index($selector, $element-separator) {
    @return true;
  } @else {
    @return false;
  }
}
</code></pre><p>然后是第二问题，可以使用 SCSS <a href="https://sass-lang.com/documentation/variables#scope" target="_blank">全局变量</a>来记录 block 的选择器，而不再用使用原来的“&amp;”符号作为「block」的部分：</p>
<pre  class="language-css"><code class="language-css">/* 先改写block mixin，使其每次被调用时，记录当前的选择器 */
@mixin block($block) {
  $B: $block !global;
  .#{$block} {
    @content;
  }
}
/* 然后结合上一步的流程控制，改写 element mixin */
@mixin element($element) {
  $E: $element !global;
  @if containsSeparator(&amp;) {
    @at-root {
      /* 注意这里需要在前面添加“&amp; ”，维持嵌套规则 */
      &amp; #{'.' + $B + $element-separator + $element} {
        @content;
      }
    }
  } @else {
    @at-root {
      /* 原来的逻辑不变，这里符号 &amp; 拿到父选择器的部分 */
      #{&amp; + $element-separator + $element} {
        @content;
      }
    }
  }
}
</code></pre><p>然后就可以完美地解决两个问题了，无论你嵌套多少层，SCSS 都能输出正确的 CSS。</p>
<h3 id="wanzhengdaimashixian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'wanzhengdaimashixian')">¶</a> 完整代码实现</h3>
<p>其实这里可以再优化一下，将三种类型的 mixin 使用首字母缩写的方式来命名，也即是<code>b</code>，<code>e</code>，<code>m</code>。上面还提到需要加命名空间的情况，可以使用<code>B</code>来进行区别，完整实现代码如下：</p>
<pre  class="language-css"><code class="language-css">$name-space: 'cs-'; /* 根据需要自定义命名空间，比如本博客的“cs-” */
$element-separator: '__';
$modifier-separator: '--';

@function containsSeparator($selector) {
  $selector: selectorToString($selector);

  @if str-index($selector, $modifier-separator) or str-index($selector, $element-separator) {
    @return true;
  } @else {
    @return false;
  }
}

@mixin B($block) {
  $B: #{$name-space + $block} !global;
  .#{$B} {
    @content;
  }
}

@mixin b($block) {
  $B: $block !global;
  .#{$block} {
    @content;
  }
}

@mixin e($element) {
  $E: $element !global;
  @if containsSeparator(&amp;) {
    @at-root {
      &amp; #{'.' + $B + $element-separator + $element} {
        @content;
      }
    }
  } @else {
    @at-root {
      #{&amp; + $element-separator + $element} {
        @content;
      }
    }
  }
}
@mixin m($modifier) {
  @at-root {
    #{&amp; + $modifier-separator + $modifier} {
      @content;
    }
  }
}
</code></pre><h3 id="shiyongSnippet"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'shiyongSnippet')">¶</a> 使用 Snippet</h3>
<p>最后，需要设置代码编辑器来帮助编写海量的 <code>@include [mixin_name] {}</code> 关键字，因为我使用的是 VSCode，所以这里只说 VSCode 的设置方法，其它代码编辑器应该也是类似的。设置步骤如下：</p>
<ol>
<li>打开 VSCode 首选项，然后选择「用户代码片段」<br>
<img src="_nuxt/img/pic-vscode-snippet.06a5398.png" alt=""></li>
<li>在弹出的输入框内输入「scss.json」<br>
<img src="_nuxt/img/pic-vscode-snippet-2.5e76a69.png" alt=""></li>
<li>输入形如下面的内容</li>
</ol>
<pre  class="language-json"><code class="language-json">{
  // Place your snippets for scss here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // &quot;Print to console&quot;: {
  // 	&quot;prefix&quot;: &quot;log&quot;,
  // 	&quot;body&quot;: [
  // 		&quot;console.log('$1');&quot;,
  // 		&quot;$2&quot;
  // 	],
  // 	&quot;description&quot;: &quot;Log output to console&quot;
  // }
  &quot;Scss BEM B&quot;: {
    &quot;prefix&quot;: &quot;iB&quot;,
    &quot;body&quot;: [&quot;@include B($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM b&quot;: {
    &quot;prefix&quot;: &quot;ib&quot;,
    &quot;body&quot;: [&quot;@include b($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM e&quot;: {
    &quot;prefix&quot;: &quot;ie&quot;,
    &quot;body&quot;: [&quot;@include e($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM m&quot;: {
    &quot;prefix&quot;: &quot;im&quot;,
    &quot;body&quot;: [&quot;@include m($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM pseudo&quot;: {
    &quot;prefix&quot;: &quot;ip&quot;,
    &quot;body&quot;: [&quot;@include pseudo($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM when&quot;: {
    &quot;prefix&quot;: &quot;iw&quot;,
    &quot;body&quot;: [&quot;@include when($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM share rule&quot;: {
    &quot;prefix&quot;: &quot;isr&quot;,
    &quot;body&quot;: [&quot;@include share-rule($1) {&quot;, &quot;  $2&quot;, &quot;}&quot;]
  },
  &quot;Scss BEM extend rule&quot;: {
    &quot;prefix&quot;: &quot;ier&quot;,
    &quot;body&quot;: [&quot;@include extend-rule($1);&quot;]
  },
  &quot;Scss utils ellipsis&quot;: {
    &quot;prefix&quot;: &quot;ime&quot;,
    &quot;body&quot;: [&quot;@include utils-ellipsis;&quot;]
  },
  &quot;Scss utils transitions&quot;: {
    &quot;prefix&quot;: &quot;imt&quot;,
    &quot;body&quot;: [&quot;@include utils-transitions($1, $2, $3);&quot;]
  },
  &quot;Scss utils extend-click&quot;: {
    &quot;prefix&quot;: &quot;imec&quot;,
    &quot;body&quot;: [&quot;@include utils-extend-click;&quot;]
  },
  &quot;Scss utils bt-1px&quot;: {
    &quot;prefix&quot;: &quot;imbt1&quot;,
    &quot;body&quot;: [&quot;@include utils-bt-1px($1);&quot;]
  },
  &quot;Scss utils b1px&quot;: {
    &quot;prefix&quot;: &quot;imb1&quot;,
    &quot;body&quot;: [&quot;@include utils-b-1px($1);&quot;]
  },
  &quot;Scss utils bb-1px&quot;: {
    &quot;prefix&quot;: &quot;imbb1&quot;,
    &quot;body&quot;: [&quot;@include utils-bb-1px($1);&quot;]
  },
  &quot;Scss utils hide-scrollbar&quot;: {
    &quot;prefix&quot;: &quot;imhs&quot;,
    &quot;body&quot;: [&quot;@include utils-hide-scrollbar;&quot;]
  }
}
</code></pre><p>上面是我根据个人习惯自定义的 mixin 快捷 prefix，比如键入“ib”回车就编辑器就会自动带出<code>@include b($1){$2}</code>，并将光标定位到$1的位置，这个时候输入完 block 的名称后按「tab」键光标就会定位到$2 的位置，使用起来非常方便，就像下图这样子：</p>
<p><img src="_nuxt/img/pic-vscode-scss-bem.3dd70c6.gif" alt=""></p>
<h2 id="jieyu"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'jieyu')">¶</a> 结语</h2>
<p>社区里关于「如何编写高可维护的 CSS 代码」的讨论话题中，「BEM」一直占有一席之地，其结构化的 CSS 和 UI 的优势，使很多多人协作的前端项目受益。在 Github 的热门库<a href="https://github.com/kamranahmedse/developer-roadmap#frontend-roadmap" target="_blank">Front-end roadmap</a>中也是被广大开发者优先推荐的。</p>
<p>本文提到的「BEM」结合「SCSS」进行高效率编写代码的方式其实最早由<a href="https://twitter.com/marcmintel" target="_blank">Marc Mintel</a>在 medium <a href="https://medium.com/@marcmintel/pushing-bem-to-the-next-level-with-sass-3-4-5239d2371321" target="_blank">提出</a>，而且在热门的开源 UI 库<a href="https://element.eleme.io/" target="_blank">element.js</a>中<a href="https://github.com/ElemeFE/element/blob/dev/packages/theme-chalk/src/mixins/mixins.scss" target="_blank">大量使用</a>，其实现更为完善，可以前往继续学习。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我为何写博客]]></title>
            <link>/post/why-i-write-blog/</link>
            <guid>/post/why-i-write-blog/</guid>
            <description><![CDATA[满足一项名为“表达”的原始欲望]]></description>
            <content:encoded><![CDATA[<p><div class="cs-toc-dom"><ul><li><a href="#tishengzongjietilianzhishidenengli">提升总结、提炼知识的能力</a></li><li><a href="#xiangchengweiyouzhineirongshengchanzhezhegemubiaoqianjin">向“成为优质内容生产者”这个目标前进</a></li><li><a href="#xiangshouziyoubiaodadelequ">享受自由表达的乐趣</a></li><li><a href="#fenxianglewenjiaogepengyou">分享乐闻、交个朋友</a></li><li><a href="#guanyucibokedeqitasuisuinian">关于此博客的其它碎碎念</a></li></ul></div></p>
<p>人类作为处于地球食物链顶端的物种，跟其它社会性动物一样，起初也是通过交流和协作分工来提高生存和繁殖的几率，虽然时至今日<strong>交流</strong>已不再是一个人生存下去的必要条件，但是这种与生俱来的表达欲望它是恒定存在的，只是可能每个人的强度不一样，从我们或多或少地更新微博、Medium、Instagram、抖音 等社交软件这些行为就可以很好地印证这点。</p>
<p>曾经读过一本很精彩的小说《当尼采哭泣》里面有一段话给我留下了很深的印象：</p>
<blockquote>
<p>“我怀孕了，这里”，他轻拍着他的太阳穴，“怀了书，几乎完全组织好的书，只有我才可以生产出来的书。有时我把我的头痛视为分娩前的阵痛。”</p>
</blockquote>
<p>欧文 D.亚隆在这里用了一段很生动的描述去强化表达主人公尼采内心深处急切将脑海中的想法谱写成书的冲动，我偶尔也会有这种“阵痛”的错觉，虽然现在还不具备写一本书的能力和魄力，但是还是需要一个<strong>合适的平台</strong>去释放脑海中的这些胡思乱想。</p>
<p>现在互联网已经充斥着大量的 UGC（User-Generated Content 用户原创生产内容）平台了，基本上可以满足每个人或多或少的表达欲望，如前文所说的微博和 Instagram 等，我在每个觉得适合我的平台权衡了一番之后，决定还是亲自动手写一个属于自己的博客，下面来唠唠我写博客的几个初衷。</p>
<h2 id="tishengzongjietilianzhishidenengli"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'tishengzongjietilianzhishidenengli')">¶</a> 提升总结、提炼知识的能力</h2>
<p>有研究表明，人每天从醒来的一刻开始计算，每天大概要做 35,000 个决定，我们的大脑需要时刻处在紧张兴奋的状态才能支撑我们高效地过好每一天，而在这么跳跃的环境下，我们大部分获取的知识都是相对零散和碎片化的，稍不留神一觉睡去醒来后，这些记忆就消失殆尽了，所以只有将这些碎片化的知识通过自身思维的演绎和归纳整理，才能真正变为自己的东西。</p>
<p>方法有很多，那么怎么高效地做到这一步呢？这里介绍一种诺贝尔奖得主、物理学家理查德· 费曼曾经提出(传说)的学习法：</p>
<ul>
<li>第 1 步：教给孩子</li>
<li>第 2 步：查缺补漏</li>
<li>第 3 步：组织和简化</li>
<li>第 4 步(可选)：找个人试一试</li>
</ul>
<p>这种学习法的本质是“以教促学”，只有通过教会别人，才能算让自己学会。</p>
<p>而写博客就像费曼学习法第三点所说的，属于一种组织和简化的过程，通过整理、组织、构思日常汲取的碎片化知识, 让其以一篇力求每个人都能清晰阅读理解的博文形式展现出来，确保自己对目标知识融会贯通。</p>
<h2 id="xiangchengweiyouzhineirongshengchanzhezhegemubiaoqianjin"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangchengweiyouzhineirongshengchanzhezhegemubiaoqianjin')">¶</a> 向“成为优质内容生产者”这个目标前进</h2>
<p>在这个每个人都“挂在网上”的时代，一个优质的内容生产者，是具备可以自己想法变现的能力的。它的形式可以是“作家”、“网络授课者”、“Vlog 博主”等，在不影响正业的前提下，成为一个“斜杠青年”，给未来提供更多的可能。成为优质内容生产者的前提是具备清晰的逻辑思维，强大丰富且生动的表达能力，写博客可以帮助锻炼我们这些能力。当然前面所说的只是比较功利的一点，从积极的一面去理解，如果写下的这些文字能多多少少给别人一些正面的影响，让这个世界变得更好一点点，也挺不错的。</p>
<h2 id="xiangshouziyoubiaodadelequ"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'xiangshouziyoubiaodadelequ')">¶</a> 享受自由表达的乐趣</h2>
<p>我个人崇尚的表达方式，它应该是纯粹的，不媚俗的，遵从内心的，和自由的。在一些社交平台常常存在着大量的诱惑（点赞、打赏、转发等）去驱使我们去作出违心或多余的表达；存在着很多条条框框（意识形态、政府敏感等）去限制我们真正想表达的想法，如果你是一个激进主义者或者愤青（我不是），我想你会比我更明白这是什么意思。</p>
<h2 id="fenxianglewenjiaogepengyou"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'fenxianglewenjiaogepengyou')">¶</a> 分享乐闻、交个朋友</h2>
<p>当然，在这里我不限定只会写一些很有意义的博文或很有深度的技术分享，也会分享那些我觉得有意思的见闻，好玩的东西，读过有用的书等。希望每一个进来的人都能通过我写下的这些东西了解到<strong>我是一个什么样的人</strong>，<strong>我的一些想法</strong>和<strong>我做过的东西</strong>，哪怕是只有一点点也好。</p>
<p>如果你也有好的想法或者好玩的东西想要跟我分享，欢迎通过我的<a href="mailto:lkangd@gmail.com">邮箱</a>跟我交流。</p>
<h2 id="guanyucibokedeqitasuisuinian"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'guanyucibokedeqitasuisuinian')">¶</a> 关于此博客的其它碎碎念</h2>
<h4 id="yuming"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yuming')">¶</a> 域名</h4>
<p><code>lkangd.com</code>，<strong>lkangd</strong> 为个人名称缩写, 选用了更为国际化的 <strong>com</strong> 域名，费用首年 ￥ 50，续费大概 ￥ 100 每年。</p>
<h4 id="yongdaodejishuzhan"><a class="cs-header-anchor" href="" onclick="!this.getAttribute('href') &amp;&amp; this.setAttribute('href', window.location.origin+window.location.pathname+'#'+'yongdaodejishuzhan')">¶</a> 用到的技术栈</h4>
<ul>
<li>页面生成:  <strong>Nuxt.js</strong></li>
<li>文章转换:  <strong>Markdownit</strong></li>
<li>页面托管:  <strong>Github page</strong></li>
<li>自动部署:  <strong>Github + Travis CI</strong></li>
<li>邮件订阅:  <strong><a href="https://app.convertkit.com/" target="_blank">Convertkit</a></strong></li>
<li>评论系统（待定）:  <strong>Disqus or Valine</strong></li>
</ul>
]]></content:encoded>
        </item>
    </channel>
</rss>